module.exports = {

"[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;
}}),
"[project]/node_modules/proxy-compare/dist/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/* eslint @typescript-eslint/no-explicit-any: off */ // symbols
__turbopack_esm__({
    "affectedToPathList": (()=>affectedToPathList),
    "createProxy": (()=>createProxy),
    "getUntracked": (()=>getUntracked),
    "isChanged": (()=>isChanged),
    "markToTrack": (()=>markToTrack),
    "replaceNewProxy": (()=>replaceNewProxy),
    "trackMemo": (()=>trackMemo)
});
const TRACK_MEMO_SYMBOL = Symbol();
const GET_ORIGINAL_SYMBOL = Symbol();
// properties
const AFFECTED_PROPERTY = 'a';
const IS_TARGET_COPIED_PROPERTY = 'f';
const PROXY_PROPERTY = 'p';
const PROXY_CACHE_PROPERTY = 'c';
const TARGET_CACHE_PROPERTY = 't';
const NEXT_OBJECT_PROPERTY = 'n';
const CHANGED_PROPERTY = 'g';
const HAS_KEY_PROPERTY = 'h';
const ALL_OWN_KEYS_PROPERTY = 'w';
const HAS_OWN_KEY_PROPERTY = 'o';
const KEYS_PROPERTY = 'k';
// function to create a new bare proxy
let newProxy = (target, handler)=>new Proxy(target, handler);
// get object prototype
const getProto = Object.getPrototypeOf;
const objectsToTrack = new WeakMap();
// check if obj is a plain object or an array
const isObjectToTrack = (obj)=>obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
// check if it is object
const isObject = (x)=>typeof x === 'object' && x !== null;
// Properties that are both non-configurable and non-writable will break
// the proxy get trap when we try to return a recursive/child compare proxy
// from them. We can avoid this by making a copy of the target object with
// all descriptors marked as configurable, see `copyTargetObject`.
// See: https://github.com/dai-shi/proxy-compare/pull/8
const needsToCopyTargetObject = (obj)=>Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor)=>!descriptor.configurable && !descriptor.writable);
// Make a copy with all descriptors marked as configurable.
const copyTargetObject = (obj)=>{
    if (Array.isArray(obj)) {
        // Arrays need a special way to copy
        return Array.from(obj);
    }
    // For non-array objects, we create a new object keeping the prototype
    // with changing all configurable options (otherwise, proxies will complain)
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    Object.values(descriptors).forEach((desc)=>{
        desc.configurable = true;
    });
    return Object.create(getProto(obj), descriptors);
};
const createProxyHandler = (origObj, isTargetCopied)=>{
    const state = {
        [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
    };
    let trackObject = false; // for trackMemo
    const recordUsage = (type, key)=>{
        if (!trackObject) {
            let used = state[AFFECTED_PROPERTY].get(origObj);
            if (!used) {
                used = {};
                state[AFFECTED_PROPERTY].set(origObj, used);
            }
            if (type === ALL_OWN_KEYS_PROPERTY) {
                used[ALL_OWN_KEYS_PROPERTY] = true;
            } else {
                let set = used[type];
                if (!set) {
                    set = new Set();
                    used[type] = set;
                }
                set.add(key);
            }
        }
    };
    const recordObjectAsUsed = ()=>{
        trackObject = true;
        state[AFFECTED_PROPERTY].delete(origObj);
    };
    const handler = {
        get (target, key) {
            if (key === GET_ORIGINAL_SYMBOL) {
                return origObj;
            }
            recordUsage(KEYS_PROPERTY, key);
            return createProxy(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);
        },
        has (target, key) {
            if (key === TRACK_MEMO_SYMBOL) {
                recordObjectAsUsed();
                return true;
            }
            recordUsage(HAS_KEY_PROPERTY, key);
            return Reflect.has(target, key);
        },
        getOwnPropertyDescriptor (target, key) {
            recordUsage(HAS_OWN_KEY_PROPERTY, key);
            return Reflect.getOwnPropertyDescriptor(target, key);
        },
        ownKeys (target) {
            recordUsage(ALL_OWN_KEYS_PROPERTY);
            return Reflect.ownKeys(target);
        }
    };
    if (isTargetCopied) {
        handler.set = handler.deleteProperty = ()=>false;
    }
    return [
        handler,
        state
    ];
};
const getOriginalObject = (obj)=>// unwrap proxy
    obj[GET_ORIGINAL_SYMBOL] || // otherwise
    obj;
const createProxy = (obj, affected, proxyCache, targetCache)=>{
    if (!isObjectToTrack(obj)) return obj;
    let targetAndCopied = targetCache && targetCache.get(obj);
    if (!targetAndCopied) {
        const target = getOriginalObject(obj);
        if (needsToCopyTargetObject(target)) {
            targetAndCopied = [
                target,
                copyTargetObject(target)
            ];
        } else {
            targetAndCopied = [
                target
            ];
        }
        targetCache === null || targetCache === void 0 ? void 0 : targetCache.set(obj, targetAndCopied);
    }
    const [target, copiedTarget] = targetAndCopied;
    let handlerAndState = proxyCache && proxyCache.get(target);
    if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
        handlerAndState = createProxyHandler(target, !!copiedTarget);
        handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);
        if (proxyCache) {
            proxyCache.set(target, handlerAndState);
        }
    }
    handlerAndState[1][AFFECTED_PROPERTY] = affected;
    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;
    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache;
    return handlerAndState[1][PROXY_PROPERTY];
};
const isAllOwnKeysChanged = (prevObj, nextObj)=>{
    const prevKeys = Reflect.ownKeys(prevObj);
    const nextKeys = Reflect.ownKeys(nextObj);
    return prevKeys.length !== nextKeys.length || prevKeys.some((k, i)=>k !== nextKeys[i]);
};
const isChanged = (prevObj, nextObj, affected, cache, isEqual = Object.is)=>{
    if (isEqual(prevObj, nextObj)) {
        return false;
    }
    if (!isObject(prevObj) || !isObject(nextObj)) return true;
    const used = affected.get(getOriginalObject(prevObj));
    if (!used) return true;
    if (cache) {
        const hit = cache.get(prevObj);
        if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {
            return hit[CHANGED_PROPERTY];
        }
        // for object with cycles
        cache.set(prevObj, {
            [NEXT_OBJECT_PROPERTY]: nextObj,
            [CHANGED_PROPERTY]: false
        });
    }
    let changed = null;
    try {
        for (const key of used[HAS_KEY_PROPERTY] || []){
            changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
            if (changed) return changed;
        }
        if (used[ALL_OWN_KEYS_PROPERTY] === true) {
            changed = isAllOwnKeysChanged(prevObj, nextObj);
            if (changed) return changed;
        } else {
            for (const key of used[HAS_OWN_KEY_PROPERTY] || []){
                const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
                const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
                changed = hasPrev !== hasNext;
                if (changed) return changed;
            }
        }
        for (const key of used[KEYS_PROPERTY] || []){
            changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual);
            if (changed) return changed;
        }
        if (changed === null) changed = true;
        return changed;
    } finally{
        if (cache) {
            cache.set(prevObj, {
                [NEXT_OBJECT_PROPERTY]: nextObj,
                [CHANGED_PROPERTY]: changed
            });
        }
    }
};
const trackMemo = (obj)=>{
    if (isObjectToTrack(obj)) {
        return TRACK_MEMO_SYMBOL in obj;
    }
    return false;
};
const getUntracked = (obj)=>{
    if (isObjectToTrack(obj)) {
        return obj[GET_ORIGINAL_SYMBOL] || null;
    }
    return null;
};
const markToTrack = (obj, mark = true)=>{
    objectsToTrack.set(obj, mark);
};
const affectedToPathList = (obj, affected, onlyWithValues)=>{
    const list = [];
    const seen = new WeakSet();
    const walk = (x, path)=>{
        var _a, _b, _c;
        if (seen.has(x)) {
            // for object with cycles
            return;
        }
        if (isObject(x)) {
            seen.add(x);
        }
        const used = isObject(x) && affected.get(getOriginalObject(x));
        if (used) {
            (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key)=>{
                const segment = `:has(${String(key)})`;
                list.push(path ? [
                    ...path,
                    segment
                ] : [
                    segment
                ]);
            });
            if (used[ALL_OWN_KEYS_PROPERTY] === true) {
                const segment = ':ownKeys';
                list.push(path ? [
                    ...path,
                    segment
                ] : [
                    segment
                ]);
            } else {
                (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key)=>{
                    const segment = `:hasOwn(${String(key)})`;
                    list.push(path ? [
                        ...path,
                        segment
                    ] : [
                        segment
                    ]);
                });
            }
            (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key)=>{
                if (!onlyWithValues || 'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {
                    walk(x[key], path ? [
                        ...path,
                        key
                    ] : [
                        key
                    ]);
                }
            });
        } else if (path) {
            list.push(path);
        }
    };
    walk(obj);
    return list;
};
const replaceNewProxy = (fn)=>{
    newProxy = fn;
};
}}),
"[project]/node_modules/@zag-js/store/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "makeGlobal": (()=>makeGlobal),
    "proxy": (()=>proxy),
    "proxyWithComputed": (()=>proxyWithComputed),
    "ref": (()=>ref),
    "snapshot": (()=>snapshot),
    "subscribe": (()=>subscribe)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$proxy$2d$compare$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/proxy-compare/dist/index.js [app-rsc] (ecmascript)");
;
// src/global.ts
function getGlobal() {
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    if (typeof global !== "undefined") return global;
}
function makeGlobal(key, value) {
    const g = getGlobal();
    if (!g) return value();
    g[key] || (g[key] = value());
    return g[key];
}
var isDev = ()=>("TURBOPACK compile-time value", "development") !== "production";
var isObject = (x)=>typeof x === "object" && x !== null;
var proxyStateMap = makeGlobal("__zag__proxyStateMap", ()=>/* @__PURE__ */ new WeakMap());
var refSet = makeGlobal("__zag__refSet", ()=>/* @__PURE__ */ new WeakSet());
var isReactElement = (x)=>typeof x === "object" && x !== null && "$$typeof" in x;
var isVueElement = (x)=>typeof x === "object" && x !== null && "__v_isVNode" in x;
var isDOMElement = (x)=>typeof x === "object" && x !== null && "nodeType" in x && typeof x.nodeName === "string";
var isElement = (x)=>isReactElement(x) || isVueElement(x) || isDOMElement(x);
var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler)=>new Proxy(target, handler), canProxy = (x)=>isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !isElement(x) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise)=>{
    switch(promise.status){
        case "fulfilled":
            return promise.value;
        case "rejected":
            throw promise.reason;
        default:
            throw promise;
    }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise)=>{
    const cache = snapCache.get(target);
    if (cache?.[0] === version) {
        return cache[1];
    }
    const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$proxy$2d$compare$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["markToTrack"])(snap, true);
    snapCache.set(target, [
        version,
        snap
    ]);
    Reflect.ownKeys(target).forEach((key)=>{
        const value = Reflect.get(target, key);
        if (refSet.has(value)) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$proxy$2d$compare$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["markToTrack"])(value, false);
            snap[key] = value;
        } else if (value instanceof Promise) {
            Object.defineProperty(snap, key, {
                get () {
                    return handlePromise(value);
                }
            });
        } else if (proxyStateMap.has(value)) {
            snap[key] = snapshot(value, handlePromise);
        } else {
            snap[key] = value;
        }
    });
    return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [
    1,
    1
], proxyFunction2 = (initialObject)=>{
    if (!isObject(initialObject)) {
        throw new Error("object required");
    }
    const found = proxyCache.get(initialObject);
    if (found) {
        return found;
    }
    let version = versionHolder[0];
    const listeners = /* @__PURE__ */ new Set();
    const notifyUpdate = (op, nextVersion = ++versionHolder[0])=>{
        if (version !== nextVersion) {
            version = nextVersion;
            listeners.forEach((listener)=>listener(op, nextVersion));
        }
    };
    let checkVersion = versionHolder[1];
    const ensureVersion = (nextCheckVersion = ++versionHolder[1])=>{
        if (checkVersion !== nextCheckVersion && !listeners.size) {
            checkVersion = nextCheckVersion;
            propProxyStates.forEach(([propProxyState])=>{
                const propVersion = propProxyState[1](nextCheckVersion);
                if (propVersion > version) {
                    version = propVersion;
                }
            });
        }
        return version;
    };
    const createPropListener = (prop)=>(op, nextVersion)=>{
            const newOp = [
                ...op
            ];
            newOp[1] = [
                prop,
                ...newOp[1]
            ];
            notifyUpdate(newOp, nextVersion);
        };
    const propProxyStates = /* @__PURE__ */ new Map();
    const addPropListener = (prop, propProxyState)=>{
        if (isDev() && propProxyStates.has(prop)) {
            throw new Error("prop listener already exists");
        }
        if (listeners.size) {
            const remove = propProxyState[3](createPropListener(prop));
            propProxyStates.set(prop, [
                propProxyState,
                remove
            ]);
        } else {
            propProxyStates.set(prop, [
                propProxyState
            ]);
        }
    };
    const removePropListener = (prop)=>{
        const entry = propProxyStates.get(prop);
        if (entry) {
            propProxyStates.delete(prop);
            entry[1]?.();
        }
    };
    const addListener = (listener)=>{
        listeners.add(listener);
        if (listeners.size === 1) {
            propProxyStates.forEach(([propProxyState, prevRemove], prop)=>{
                if (isDev() && prevRemove) {
                    throw new Error("remove already exists");
                }
                const remove = propProxyState[3](createPropListener(prop));
                propProxyStates.set(prop, [
                    propProxyState,
                    remove
                ]);
            });
        }
        const removeListener = ()=>{
            listeners.delete(listener);
            if (listeners.size === 0) {
                propProxyStates.forEach(([propProxyState, remove], prop)=>{
                    if (remove) {
                        remove();
                        propProxyStates.set(prop, [
                            propProxyState
                        ]);
                    }
                });
            }
        };
        return removeListener;
    };
    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
    const handler = {
        deleteProperty (target, prop) {
            const prevValue = Reflect.get(target, prop);
            removePropListener(prop);
            const deleted = Reflect.deleteProperty(target, prop);
            if (deleted) {
                notifyUpdate([
                    "delete",
                    [
                        prop
                    ],
                    prevValue
                ]);
            }
            return deleted;
        },
        set (target, prop, value, receiver) {
            const hasPrevValue = Reflect.has(target, prop);
            const prevValue = Reflect.get(target, prop, receiver);
            if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
                return true;
            }
            removePropListener(prop);
            if (isObject(value)) {
                value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$proxy$2d$compare$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUntracked"])(value) || value;
            }
            let nextValue = value;
            if (Object.getOwnPropertyDescriptor(target, prop)?.set) ;
            else if (value instanceof Promise) {
                value.then((v)=>{
                    Object.assign(value, {
                        status: "fulfilled",
                        value: v
                    });
                    notifyUpdate([
                        "resolve",
                        [
                            prop
                        ],
                        v
                    ]);
                }).catch((e)=>{
                    Object.assign(value, {
                        status: "rejected",
                        reason: e
                    });
                    notifyUpdate([
                        "reject",
                        [
                            prop
                        ],
                        e
                    ]);
                });
            } else {
                if (!proxyStateMap.has(value) && canProxy(value)) {
                    nextValue = proxy(value);
                }
                const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
                if (childProxyState) {
                    addPropListener(prop, childProxyState);
                }
            }
            Reflect.set(target, prop, nextValue, receiver);
            notifyUpdate([
                "set",
                [
                    prop
                ],
                value,
                prevValue
            ]);
            return true;
        }
    };
    const proxyObject = newProxy(baseObject, handler);
    proxyCache.set(initialObject, proxyObject);
    const proxyState = [
        baseObject,
        ensureVersion,
        createSnapshot,
        addListener
    ];
    proxyStateMap.set(proxyObject, proxyState);
    Reflect.ownKeys(initialObject).forEach((key)=>{
        const desc = Object.getOwnPropertyDescriptor(initialObject, key);
        if (desc.get || desc.set) {
            Object.defineProperty(baseObject, key, desc);
        } else {
            proxyObject[key] = initialObject[key];
        }
    });
    return proxyObject;
})=>[
        // public functions
        proxyFunction2,
        // shared state
        proxyStateMap,
        refSet,
        // internal things
        objectIs,
        newProxy,
        canProxy,
        defaultHandlePromise,
        snapCache,
        createSnapshot,
        proxyCache,
        versionHolder
    ];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
    return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
    const proxyState = proxyStateMap.get(proxyObject);
    if (isDev() && !proxyState) {
        console.warn("Please use proxy object");
    }
    let promise;
    const ops = [];
    const addListener = proxyState[3];
    let isListenerActive = false;
    const listener = (op)=>{
        ops.push(op);
        if (notifyInSync) {
            callback(ops.splice(0));
            return;
        }
        if (!promise) {
            promise = Promise.resolve().then(()=>{
                promise = void 0;
                if (isListenerActive) {
                    callback(ops.splice(0));
                }
            });
        }
    };
    const removeListener = addListener(listener);
    isListenerActive = true;
    return ()=>{
        isListenerActive = false;
        removeListener();
    };
}
function snapshot(proxyObject, handlePromise) {
    const proxyState = proxyStateMap.get(proxyObject);
    if (isDev() && !proxyState) {
        console.warn("Please use proxy object");
    }
    const [target, ensureVersion, createSnapshot] = proxyState;
    return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
    refSet.add(obj);
    return obj;
}
// src/proxy-computed.ts
function proxyWithComputed(initialObject, computedFns) {
    const keys = Object.keys(computedFns);
    keys.forEach((key)=>{
        if (Object.getOwnPropertyDescriptor(initialObject, key)) {
            throw new Error("object property already defined");
        }
        const computedFn = computedFns[key];
        const { get, set } = typeof computedFn === "function" ? {
            get: computedFn
        } : computedFn;
        const desc = {};
        desc.get = ()=>get(snapshot(proxyObject));
        if (set) {
            desc.set = (newValue)=>set(proxyObject, newValue);
        }
        Object.defineProperty(initialObject, key, desc);
    });
    const proxyObject = proxy(initialObject);
    return proxyObject;
}
;
}}),
"[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/array.ts
__turbopack_esm__({
    "add": (()=>add),
    "addOrRemove": (()=>addOrRemove),
    "callAll": (()=>callAll),
    "cast": (()=>cast),
    "chunk": (()=>chunk),
    "clear": (()=>clear),
    "compact": (()=>compact),
    "createSplitProps": (()=>createSplitProps),
    "first": (()=>first),
    "fromLength": (()=>fromLength),
    "has": (()=>has),
    "hasProp": (()=>hasProp),
    "insertAt": (()=>insertAt),
    "invariant": (()=>invariant),
    "isArray": (()=>isArray),
    "isBoolean": (()=>isBoolean),
    "isDev": (()=>isDev),
    "isEmpty": (()=>isEmpty),
    "isEqual": (()=>isEqual),
    "isFunction": (()=>isFunction),
    "isNull": (()=>isNull),
    "isNumber": (()=>isNumber),
    "isObject": (()=>isObject),
    "isObjectLike": (()=>isObjectLike),
    "isPlainObject": (()=>isPlainObject),
    "isString": (()=>isString),
    "json": (()=>json),
    "last": (()=>last),
    "match": (()=>match),
    "next": (()=>next),
    "nextIndex": (()=>nextIndex),
    "noop": (()=>noop),
    "omit": (()=>omit),
    "pick": (()=>pick),
    "prev": (()=>prev),
    "prevIndex": (()=>prevIndex),
    "remove": (()=>remove),
    "removeAt": (()=>removeAt),
    "runIfFn": (()=>runIfFn),
    "splitProps": (()=>splitProps),
    "toArray": (()=>toArray),
    "tryCatch": (()=>tryCatch),
    "uniq": (()=>uniq),
    "uuid": (()=>uuid),
    "warn": (()=>warn)
});
function toArray(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [
        v
    ];
}
var fromLength = (length)=>Array.from(Array(length).keys());
var first = (v)=>v[0];
var last = (v)=>v[v.length - 1];
var isEmpty = (v)=>v.length === 0;
var has = (v, t)=>v.indexOf(t) !== -1;
var add = (v, ...items)=>v.concat(items);
var remove = (v, ...items)=>v.filter((t)=>!items.includes(t));
var removeAt = (v, i)=>v.filter((_, idx)=>idx !== i);
var insertAt = (v, i, ...items)=>[
        ...v.slice(0, i),
        ...items,
        ...v.slice(i)
    ];
var uniq = (v)=>Array.from(new Set(v));
var addOrRemove = (v, item)=>{
    if (has(v, item)) return remove(v, item);
    return add(v, item);
};
function clear(v) {
    while(v.length > 0)v.pop();
    return v;
}
function nextIndex(v, idx, opts = {}) {
    const { step = 1, loop = true } = opts;
    const next2 = idx + step;
    const len = v.length;
    const last2 = len - 1;
    if (idx === -1) return step > 0 ? 0 : last2;
    if (next2 < 0) return loop ? last2 : 0;
    if (next2 >= len) return loop ? 0 : idx > len ? len : idx;
    return next2;
}
function next(v, idx, opts = {}) {
    return v[nextIndex(v, idx, opts)];
}
function prevIndex(v, idx, opts = {}) {
    const { step = 1, loop = true } = opts;
    return nextIndex(v, idx, {
        step: -step,
        loop
    });
}
function prev(v, index, opts = {}) {
    return v[prevIndex(v, index, opts)];
}
var chunk = (v, size)=>{
    const res = [];
    return v.reduce((rows, value, index)=>{
        if (index % size === 0) rows.push([
            value
        ]);
        else last(rows)?.push(value);
        return rows;
    }, res);
};
// src/equal.ts
var isArrayLike = (value)=>value?.constructor.name === "Array";
var isArrayEqual = (a, b)=>{
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; i++){
        if (!isEqual(a[i], b[i])) return false;
    }
    return true;
};
var isEqual = (a, b)=>{
    if (Object.is(a, b)) return true;
    if (a == null && b != null || a != null && b == null) return false;
    if (typeof a?.isEqual === "function" && typeof b?.isEqual === "function") {
        return a.isEqual(b);
    }
    if (typeof a === "function" && typeof b === "function") {
        return a.toString() === b.toString();
    }
    if (isArrayLike(a) && isArrayLike(b)) {
        return isArrayEqual(Array.from(a), Array.from(b));
    }
    if (!(typeof a === "object") || !(typeof b === "object")) return false;
    const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
    const length = keys.length;
    for(let i = 0; i < length; i++){
        const hasKey = Reflect.has(a, keys[i]);
        if (!hasKey) return false;
    }
    for(let i = 0; i < length; i++){
        const key = keys[i];
        if (!isEqual(a[key], b[key])) return false;
    }
    return true;
};
// src/functions.ts
var runIfFn = (v, ...a)=>{
    const res = typeof v === "function" ? v(...a) : v;
    return res ?? void 0;
};
var cast = (v)=>v;
var noop = ()=>{};
var callAll = (...fns)=>(...a)=>{
        fns.forEach(function(fn) {
            fn?.(...a);
        });
    };
var uuid = /* @__PURE__ */ (()=>{
    let id = 0;
    return ()=>{
        id++;
        return id.toString(36);
    };
})();
function match(key, record, ...args) {
    if (key in record) {
        const fn = record[key];
        return typeof fn === "function" ? fn(...args) : fn;
    }
    const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);
    Error.captureStackTrace?.(error, match);
    throw error;
}
var tryCatch = (fn, fallback)=>{
    try {
        return fn();
    } catch (error) {
        if (error instanceof Error) {
            Error.captureStackTrace?.(error, tryCatch);
        }
        return fallback?.();
    }
};
// src/guard.ts
var isDev = ()=>("TURBOPACK compile-time value", "development") !== "production";
var isArray = (v)=>Array.isArray(v);
var isBoolean = (v)=>v === true || v === false;
var isObjectLike = (v)=>v != null && typeof v === "object";
var isObject = (v)=>isObjectLike(v) && !isArray(v);
var isNumber = (v)=>typeof v === "number" && !Number.isNaN(v);
var isString = (v)=>typeof v === "string";
var isFunction = (v)=>typeof v === "function";
var isNull = (v)=>v == null;
var hasProp = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v)=>Object.prototype.toString.call(v);
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);
var isPlainObject = (v)=>{
    if (!isObjectLike(v) || baseGetTag(v) != "[object Object]") return false;
    const proto = Object.getPrototypeOf(v);
    if (proto === null) return true;
    const Ctor = hasProp(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;
};
// src/split-props.ts
function splitProps(props, keys) {
    const rest = {};
    const result = {};
    const keySet = new Set(keys);
    for(const key in props){
        if (keySet.has(key)) {
            result[key] = props[key];
        } else {
            rest[key] = props[key];
        }
    }
    return [
        result,
        rest
    ];
}
var createSplitProps = (keys)=>{
    return function split(props) {
        return splitProps(props, keys);
    };
};
// src/object.ts
function compact(obj) {
    if (!isPlainObject2(obj) || obj === void 0) {
        return obj;
    }
    const keys = Reflect.ownKeys(obj).filter((key)=>typeof key === "string");
    const filtered = {};
    for (const key of keys){
        const value = obj[key];
        if (value !== void 0) {
            filtered[key] = compact(value);
        }
    }
    return filtered;
}
function json(value) {
    return JSON.parse(JSON.stringify(value));
}
var isPlainObject2 = (value)=>{
    return value && typeof value === "object" && value.constructor === Object;
};
function pick(obj, keys) {
    const filtered = {};
    for (const key of keys){
        const value = obj[key];
        if (value !== void 0) {
            filtered[key] = value;
        }
    }
    return filtered;
}
function omit(obj, keys) {
    return createSplitProps(keys)(obj)[1];
}
// src/warning.ts
function warn(...a) {
    const m = a.length === 1 ? a[0] : a[1];
    const c = a.length === 2 ? a[0] : true;
    if (c && ("TURBOPACK compile-time value", "development") !== "production") {
        console.warn(m);
    }
}
function invariant(...a) {
    const m = a.length === 1 ? a[0] : a[1];
    const c = a.length === 2 ? a[0] : true;
    if (c && ("TURBOPACK compile-time value", "development") !== "production") {
        throw new Error(m);
    }
}
;
}}),
"[project]/node_modules/@zag-js/collection/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GridCollection": (()=>GridCollection),
    "ListCollection": (()=>ListCollection),
    "TreeCollection": (()=>TreeCollection),
    "filePathToTree": (()=>filePathToTree),
    "flattenedToTree": (()=>flattenedToTree)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
;
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var fallback = {
    itemToValue (item) {
        if (typeof item === "string") return item;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isObject"])(item) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["hasProp"])(item, "value")) return item.value;
        return "";
    },
    itemToString (item) {
        if (typeof item === "string") return item;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isObject"])(item) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["hasProp"])(item, "label")) return item.label;
        return fallback.itemToValue(item);
    },
    isItemDisabled (item) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isObject"])(item) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["hasProp"])(item, "disabled")) return !!item.disabled;
        return false;
    }
};
var ListCollection = class {
    constructor(options){
        this.options = options;
        /**
     * The items in the collection
     */ __publicField(this, "items");
        this.items = [
            ...options.items
        ];
    }
    isEqual(other) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(this.items, other.items);
    }
    /**
   * Function to update the collection items
   */ setItems(items) {
        this.items = Array.from(items);
    }
    /**
   * Returns all the values in the collection
   */ getValues(items = this.items) {
        return Array.from(items).map((item)=>this.getItemValue(item)).filter(Boolean);
    }
    /**
   * Get the item based on its value
   */ find(value) {
        if (value == null) return null;
        const index = this.items.findIndex((item)=>this.getItemValue(item) === value);
        return index != null ? this.items[index] : null;
    }
    /**
   * Get the items based on its values
   */ findMany(values) {
        return Array.from(values).map((value)=>this.find(value)).filter(Boolean);
    }
    /**
   * Get the item based on its index
   */ at(index) {
        return this.items[index] ?? null;
    }
    sortFn(valueA, valueB) {
        const indexA = this.indexOf(valueA);
        const indexB = this.indexOf(valueB);
        return (indexA ?? 0) - (indexB ?? 0);
    }
    /**
   * Sort the values based on their index
   */ sort(values) {
        return [
            ...values
        ].sort(this.sortFn.bind(this));
    }
    /**
   * Convert an item to a value
   */ getItemValue(item) {
        if (item == null) return null;
        return this.options.itemToValue?.(item) ?? fallback.itemToValue(item);
    }
    /**
   * Whether an item is disabled
   */ getItemDisabled(item) {
        if (item == null) return false;
        return this.options.isItemDisabled?.(item) ?? fallback.isItemDisabled(item);
    }
    /**
   * Convert an item to a string
   */ stringifyItem(item) {
        if (item == null) return null;
        return this.options.itemToString?.(item) ?? fallback.itemToString(item);
    }
    /**
   * Convert a value to a string
   */ stringify(value) {
        if (value == null) return null;
        return this.stringifyItem(this.find(value));
    }
    /**
   * Convert an array of items to a string
   */ stringifyItems(items, separator = ", ") {
        return Array.from(items).map((item)=>this.stringifyItem(item)).filter(Boolean).join(separator);
    }
    /**
   * Convert an array of items to a string
   */ stringifyMany(value, separator) {
        return this.stringifyItems(this.findMany(value), separator);
    }
    /**
   * Whether the collection has a value
   */ has(value) {
        return this.indexOf(value) !== -1;
    }
    /**
   * Whether the collection has an item
   */ hasItem(item) {
        if (item == null) return false;
        return this.has(this.getItemValue(item));
    }
    /**
   * Returns the number of items in the collection
   */ get size() {
        return this.items.length;
    }
    /**
   * Returns the first value in the collection
   */ get firstValue() {
        let index = 0;
        while(this.getItemDisabled(this.at(index)))index++;
        return this.getItemValue(this.at(index));
    }
    /**
   * Returns the last value in the collection
   */ get lastValue() {
        let index = this.size - 1;
        while(this.getItemDisabled(this.at(index)))index--;
        return this.getItemValue(this.at(index));
    }
    /**
   * Returns the next value in the collection
   */ getNextValue(value, step = 1, clamp = false) {
        let index = this.indexOf(value);
        if (index === -1) return null;
        index = clamp ? Math.min(index + step, this.size - 1) : index + step;
        while(index <= this.size && this.getItemDisabled(this.at(index)))index++;
        return this.getItemValue(this.at(index));
    }
    /**
   * Returns the previous value in the collection
   */ getPreviousValue(value, step = 1, clamp = false) {
        let index = this.indexOf(value);
        if (index === -1) return null;
        index = clamp ? Math.max(index - step, 0) : index - step;
        while(index >= 0 && this.getItemDisabled(this.at(index)))index--;
        return this.getItemValue(this.at(index));
    }
    /**
   * Get the index of an item based on its key
   */ indexOf(value) {
        if (value == null) return -1;
        return this.items.findIndex((item)=>this.getItemValue(item) === value);
    }
    getByText(text, current) {
        let items = current != null ? wrap(this.items, this.indexOf(current)) : this.items;
        const isSingleKey = text.length === 1;
        if (isSingleKey) items = items.filter((item)=>this.getItemValue(item) !== current);
        return items.find((item)=>match(this.stringifyItem(item), text));
    }
    /**
   * Search for a value based on a query
   */ search(queryString, options) {
        const { state, currentValue, timeout = 350 } = options;
        const search = state.keysSoFar + queryString;
        const isRepeated = search.length > 1 && Array.from(search).every((char)=>char === search[0]);
        const query = isRepeated ? search[0] : search;
        const item = this.getByText(query, currentValue);
        const value = this.getItemValue(item);
        function cleanup() {
            clearTimeout(state.timer);
            state.timer = -1;
        }
        function update(value2) {
            state.keysSoFar = value2;
            cleanup();
            if (value2 !== "") {
                state.timer = +setTimeout(()=>{
                    update("");
                    cleanup();
                }, timeout);
            }
        }
        update(search);
        return value;
    }
    *[Symbol.iterator]() {
        yield* this.items;
    }
    insertBefore(value, item) {
        const index = this.indexOf(value);
        if (index === -1) return;
        this.items.splice(index, 0, item);
    }
    insertAfter(value, item) {
        const index = this.indexOf(value);
        if (index === -1) return;
        this.items.splice(index + 1, 0, item);
    }
    reorder(fromIndex, toIndex) {
        if (fromIndex === -1 || toIndex === -1) return;
        if (fromIndex === toIndex) return;
        const [removed] = this.items.splice(fromIndex, 1);
        this.items.splice(toIndex, 0, removed);
    }
    json() {
        return {
            size: this.size,
            first: this.firstValue,
            last: this.lastValue
        };
    }
};
var match = (label, query)=>{
    return !!label?.toLowerCase().startsWith(query.toLowerCase());
};
var wrap = (v, idx)=>{
    return v.map((_, index)=>v[(Math.max(idx, 0) + index) % v.length]);
};
// src/grid-collection.ts
var GridCollection = class extends ListCollection {
    constructor(options){
        const { columnCount } = options;
        super(options);
        __publicField(this, "columnCount");
        this.columnCount = columnCount;
    }
    /**
   * Returns the row data in the grid
   */ getRows() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["chunk"])([
            ...this.items
        ], this.columnCount);
    }
    /**
   * Returns the number of rows in the grid
   */ getRowCount() {
        return this.getRows().length;
    }
    /**
   * Returns the index of the specified row and column in the grid
   */ getCellIndex(row, column) {
        return row * this.columnCount + column;
    }
    /**
   * Returns the item at the specified row and column in the grid
   */ getCell(row, column) {
        return this.at(this.getCellIndex(row, column));
    }
    /**
   * Returns the value of the previous row in the grid, based on the current value
   */ getPreviousRowValue(value, clamp = false) {
        return this.getPreviousValue(value, this.columnCount, clamp);
    }
    /**
   * Returns the value of the next row in the grid, based on the current value
   */ getNextRowValue(value, clamp = false) {
        return this.getNextValue(value, this.columnCount, clamp);
    }
};
// src/tree-visit.ts
function access(node, indexPath, options) {
    for(let i = 0; i < indexPath.length; i++)node = options.getChildren(node, indexPath.slice(i + 1))[indexPath[i]];
    return node;
}
function ancestorIndexPaths(indexPaths) {
    const result = [];
    const seen = /* @__PURE__ */ new Set();
    for (const indexPath of indexPaths){
        for(let i = indexPath.length; i > 0; i--){
            const path = indexPath.slice(0, i);
            const key = path.join();
            if (seen.has(key)) break;
            seen.add(key);
            result.push(path);
        }
    }
    return result;
}
function compareIndexPaths(a, b) {
    for(let i = 0; i < Math.min(a.length, b.length); i++){
        if (a[i] < b[i]) return -1;
        if (a[i] > b[i]) return 1;
    }
    return a.length - b.length;
}
function find(node, options) {
    let found;
    visit(node, {
        ...options,
        onEnter: (child, indexPath)=>{
            if (options.predicate(child, indexPath)) {
                found = child;
                return "stop";
            }
        }
    });
    return found;
}
function findIndexPath(node, options) {
    let found;
    visit(node, {
        onEnter: (child, indexPath)=>{
            if (options.predicate(child, indexPath)) {
                found = [
                    ...indexPath
                ];
                return "stop";
            }
        },
        getChildren: options.getChildren
    });
    return found;
}
function reduce(node, options) {
    let result = options.initialResult;
    visit(node, {
        ...options,
        onEnter: (child, indexPath)=>{
            result = options.nextResult(result, child, indexPath);
        }
    });
    return result;
}
function flatMap(node, options) {
    return reduce(node, {
        ...options,
        initialResult: [],
        nextResult: (result, child, indexPath)=>{
            result.push(...options.transform(child, indexPath));
            return result;
        }
    });
}
function insertOperation(index, nodes) {
    return {
        type: "insert",
        index,
        nodes
    };
}
function removeOperation(indexes) {
    return {
        type: "remove",
        indexes
    };
}
function replaceOperation() {
    return {
        type: "replace"
    };
}
function splitIndexPath(indexPath) {
    return [
        indexPath.slice(0, -1),
        indexPath[indexPath.length - 1]
    ];
}
function getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */ new Map()) {
    const [parentIndexPath, index] = splitIndexPath(indexPath);
    for(let i = parentIndexPath.length - 1; i >= 0; i--){
        const parentKey = parentIndexPath.slice(0, i).join();
        switch(operations.get(parentKey)?.type){
            case "remove":
                continue;
        }
        operations.set(parentKey, replaceOperation());
    }
    const operation = operations.get(parentIndexPath.join());
    switch(operation?.type){
        case "remove":
            operations.set(parentIndexPath.join(), {
                type: "removeThenInsert",
                removeIndexes: operation.indexes,
                insertIndex: index,
                insertNodes: nodes
            });
            break;
        default:
            operations.set(parentIndexPath.join(), insertOperation(index, nodes));
    }
    return operations;
}
function getRemovalOperations(indexPaths) {
    const _ancestorIndexPaths = ancestorIndexPaths(indexPaths);
    const indexesToRemove = /* @__PURE__ */ new Map();
    for (const indexPath of _ancestorIndexPaths){
        const parentKey = indexPath.slice(0, -1).join();
        const value = indexesToRemove.get(parentKey) ?? [];
        value.push(indexPath[indexPath.length - 1]);
        indexesToRemove.set(parentKey, value);
    }
    const operations = /* @__PURE__ */ new Map();
    for (const indexPath of _ancestorIndexPaths){
        for(let i = indexPath.length - 1; i >= 0; i--){
            const parentKey = indexPath.slice(0, i).join();
            operations.set(parentKey, replaceOperation());
        }
    }
    for (const indexPath of _ancestorIndexPaths){
        const parentKey = indexPath.slice(0, -1).join();
        operations.set(parentKey, removeOperation(indexesToRemove.get(parentKey) ?? []));
    }
    return operations;
}
function getReplaceOperations(indexPath, node) {
    const operations = /* @__PURE__ */ new Map();
    const [parentIndexPath, index] = splitIndexPath(indexPath);
    for(let i = parentIndexPath.length - 1; i >= 0; i--){
        const parentKey = parentIndexPath.slice(0, i).join();
        operations.set(parentKey, replaceOperation());
    }
    operations.set(parentIndexPath.join(), {
        type: "removeThenInsert",
        removeIndexes: [
            index
        ],
        insertIndex: index,
        insertNodes: [
            node
        ]
    });
    return operations;
}
function mutate(node, operations, options) {
    return map(node, {
        ...options,
        getChildren: (node2, indexPath)=>{
            const key = indexPath.join();
            const operation = operations.get(key);
            switch(operation?.type){
                case "replace":
                case "remove":
                case "removeThenInsert":
                case "insert":
                    return options.getChildren(node2, indexPath);
                default:
                    return [];
            }
        },
        transform: (node2, children, indexPath)=>{
            const key = indexPath.join();
            const operation = operations.get(key);
            switch(operation?.type){
                case "remove":
                    return options.create(node2, children.filter((_, index)=>!operation.indexes.includes(index)), indexPath);
                case "removeThenInsert":
                    const updatedChildren = children.filter((_, index)=>!operation.removeIndexes.includes(index));
                    const adjustedIndex = operation.removeIndexes.reduce((index, removedIndex)=>removedIndex < index ? index - 1 : index, operation.insertIndex);
                    return options.create(node2, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);
                case "insert":
                    return options.create(node2, splice(children, operation.index, 0, ...operation.nodes), indexPath);
                case "replace":
                    return options.create(node2, children, indexPath);
                default:
                    return node2;
            }
        }
    });
}
function splice(array, start, deleteCount, ...items) {
    return [
        ...array.slice(0, start),
        ...items,
        ...array.slice(start + deleteCount)
    ];
}
function map(node, options) {
    const childrenMap = {};
    visit(node, {
        ...options,
        onLeave: (child, indexPath)=>{
            const keyIndexPath = [
                0,
                ...indexPath
            ];
            const key = keyIndexPath.join();
            const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);
            const parentKey = keyIndexPath.slice(0, -1).join();
            const parentChildren = childrenMap[parentKey] ?? [];
            parentChildren.push(transformed);
            childrenMap[parentKey] = parentChildren;
        }
    });
    return childrenMap[""][0];
}
function insert(node, options) {
    const { nodes, at } = options;
    if (at.length === 0) throw new Error(`Can't insert nodes at the root`);
    const state = getInsertionOperations(at, nodes);
    return mutate(node, state, options);
}
function replace(node, options) {
    if (options.at.length === 0) return options.node;
    const operations = getReplaceOperations(options.at, options.node);
    return mutate(node, operations, options);
}
function move(node, options) {
    if (options.indexPaths.length === 0) return node;
    for (const indexPath of options.indexPaths){
        if (indexPath.length === 0) throw new Error(`Can't move the root node`);
    }
    if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);
    const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);
    const nodesToInsert = _ancestorIndexPaths.map((indexPath)=>access(node, indexPath, options));
    const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));
    return mutate(node, operations, options);
}
function visit(node, options) {
    const { onEnter, onLeave, getChildren } = options;
    let indexPath = [];
    let stack = [
        {
            node
        }
    ];
    const getIndexPath = options.reuseIndexPath ? ()=>indexPath : ()=>indexPath.slice();
    while(stack.length > 0){
        let wrapper = stack[stack.length - 1];
        if (wrapper.state === void 0) {
            const enterResult = onEnter?.(wrapper.node, getIndexPath());
            if (enterResult === "stop") return;
            wrapper.state = enterResult === "skip" ? -1 : 0;
        }
        const children = wrapper.children || getChildren(wrapper.node, getIndexPath());
        wrapper.children || (wrapper.children = children);
        if (wrapper.state !== -1) {
            if (wrapper.state < children.length) {
                let currentIndex = wrapper.state;
                indexPath.push(currentIndex);
                stack.push({
                    node: children[currentIndex]
                });
                wrapper.state = currentIndex + 1;
                continue;
            }
            const leaveResult = onLeave?.(wrapper.node, getIndexPath());
            if (leaveResult === "stop") return;
        }
        indexPath.pop();
        stack.pop();
    }
}
// src/tree-collection.ts
var TreeCollection = class {
    constructor(options){
        this.options = options;
        __publicField(this, "rootNode");
        __publicField(this, "getNodeChildren", (node)=>{
            return this.options.nodeToChildren?.(node) ?? fallback2.nodeToChildren(node) ?? [];
        });
        __publicField(this, "getNodeValue", (node)=>{
            return this.options.nodeToValue?.(node) ?? fallback2.nodeToValue(node);
        });
        __publicField(this, "getNodeDisabled", (node)=>{
            return this.options.isNodeDisabled?.(node) ?? fallback2.isNodeDisabled(node);
        });
        __publicField(this, "stringify", (value)=>{
            const node = this.findNode(value);
            if (!node) return null;
            return this.stringifyNode(node);
        });
        __publicField(this, "stringifyNode", (node)=>{
            return this.options.nodeToString?.(node) ?? fallback2.nodeToString(node);
        });
        __publicField(this, "getFirstNode", (rootNode = this.rootNode)=>{
            let firstChild;
            visit(rootNode, {
                getChildren: this.getNodeChildren,
                onEnter: (node, indexPath)=>{
                    if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node)) {
                        firstChild = node;
                        return "stop";
                    }
                }
            });
            return firstChild;
        });
        __publicField(this, "getLastNode", (rootNode = this.rootNode, opts = {})=>{
            let lastChild;
            visit(rootNode, {
                getChildren: this.getNodeChildren,
                onEnter: (node, indexPath)=>{
                    const nodeValue = this.getNodeValue(node);
                    if (opts.skip?.({
                        value: nodeValue,
                        node,
                        indexPath
                    })) return "skip";
                    if (indexPath.length > 1) return "skip";
                    if (!this.getNodeDisabled(node)) {
                        lastChild = node;
                    }
                }
            });
            return lastChild;
        });
        __publicField(this, "findNode", (value, rootNode = this.rootNode)=>{
            return find(rootNode, {
                getChildren: this.getNodeChildren,
                predicate: (node)=>this.getNodeValue(node) === value
            });
        });
        __publicField(this, "sort", (values)=>{
            return values.reduce((acc, value)=>{
                const indexPath = this.getIndexPath(value);
                if (indexPath != null) acc.push({
                    value,
                    indexPath
                });
                return acc;
            }, []).sort((a, b)=>compareIndexPaths(a.indexPath, b.indexPath)).map(({ value })=>value);
        });
        __publicField(this, "getIndexPath", (value)=>{
            return findIndexPath(this.rootNode, {
                getChildren: this.getNodeChildren,
                predicate: (node)=>this.getNodeValue(node) === value
            });
        });
        __publicField(this, "getValuePath", (indexPath)=>{
            if (!indexPath) return [];
            const valuePath = [];
            let currentPath = [
                ...indexPath
            ];
            while(currentPath.length > 0){
                const node = this.at(currentPath);
                if (node) valuePath.unshift(this.getNodeValue(node));
                currentPath.pop();
            }
            return valuePath;
        });
        __publicField(this, "getDepth", (value)=>{
            const indexPath = findIndexPath(this.rootNode, {
                getChildren: this.getNodeChildren,
                predicate: (node)=>this.getNodeValue(node) === value
            });
            return indexPath?.length ?? 0;
        });
        __publicField(this, "isRootNode", (node)=>{
            return this.getNodeValue(node) === this.getNodeValue(this.rootNode);
        });
        __publicField(this, "contains", (parentIndexPath, valueIndexPath)=>{
            if (!parentIndexPath || !valueIndexPath) return false;
            return valueIndexPath.slice(0, parentIndexPath.length).every((_, i)=>parentIndexPath[i] === valueIndexPath[i]);
        });
        __publicField(this, "getNextNode", (value, opts = {})=>{
            let found = false;
            let nextNode;
            visit(this.rootNode, {
                getChildren: this.getNodeChildren,
                onEnter: (node, indexPath)=>{
                    if (this.isRootNode(node)) return;
                    const nodeValue = this.getNodeValue(node);
                    if (opts.skip?.({
                        value: nodeValue,
                        node,
                        indexPath
                    })) {
                        if (nodeValue === value) {
                            found = true;
                        }
                        return "skip";
                    }
                    if (found && !this.getNodeDisabled(node)) {
                        nextNode = node;
                        return "stop";
                    }
                    if (nodeValue === value) {
                        found = true;
                    }
                }
            });
            return nextNode;
        });
        __publicField(this, "getPreviousNode", (value, opts = {})=>{
            let previousNode;
            let found = false;
            visit(this.rootNode, {
                getChildren: this.getNodeChildren,
                onEnter: (node, indexPath)=>{
                    if (this.isRootNode(node)) return;
                    const nodeValue = this.getNodeValue(node);
                    if (opts.skip?.({
                        value: nodeValue,
                        node,
                        indexPath
                    })) {
                        return "skip";
                    }
                    if (nodeValue === value) {
                        found = true;
                        return "stop";
                    }
                    if (!this.getNodeDisabled(node)) {
                        previousNode = node;
                    }
                }
            });
            return found ? previousNode : void 0;
        });
        __publicField(this, "getParentNodes", (values)=>{
            const result = [];
            let indexPath = this.getIndexPath(values);
            while(indexPath && indexPath.length > 0){
                indexPath.pop();
                const parentNode = this.at(indexPath);
                if (parentNode && !this.isRootNode(parentNode)) {
                    result.unshift(parentNode);
                }
            }
            return result;
        });
        __publicField(this, "getParentNode", (value)=>{
            const indexPath = this.getIndexPath(value);
            return indexPath ? this.at(indexPath.slice(0, -1)) : void 0;
        });
        __publicField(this, "visit", (opts)=>{
            const { skip, ...rest } = opts;
            visit(this.rootNode, {
                ...rest,
                getChildren: this.getNodeChildren,
                onEnter: (node, indexPath)=>{
                    if (this.isRootNode(node)) return;
                    if (skip?.({
                        value: this.getNodeValue(node),
                        node,
                        indexPath
                    })) return "skip";
                    return rest.onEnter?.(node, indexPath);
                }
            });
        });
        __publicField(this, "getSiblingNodes", (indexPath)=>{
            const parentPath = indexPath.slice(0, -1);
            const parentNode = this.at(parentPath);
            if (!parentNode) return [];
            const depth = indexPath.length;
            const siblingNodes = [];
            visit(parentNode, {
                getChildren: this.getNodeChildren,
                onEnter: (node, path)=>{
                    if (this.isRootNode(node)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(path, indexPath)) return;
                    if (path.length === depth && this.isBranchNode(node)) {
                        siblingNodes.push(node);
                    }
                    return "skip";
                }
            });
            return siblingNodes;
        });
        __publicField(this, "getValues", (rootNode = this.rootNode)=>{
            const values = flatMap(rootNode, {
                getChildren: this.getNodeChildren,
                transform: (node)=>[
                        this.getNodeValue(node)
                    ]
            });
            return values.slice(1);
        });
        __publicField(this, "isSameDepth", (indexPath, depth)=>{
            if (depth == null) return true;
            return indexPath.length === depth;
        });
        __publicField(this, "isBranchNode", (node)=>{
            return this.getNodeChildren(node).length > 0;
        });
        __publicField(this, "getBranchValues", (rootNode = this.rootNode, opts = {})=>{
            let values = [];
            visit(rootNode, {
                getChildren: this.getNodeChildren,
                onEnter: (node, indexPath)=>{
                    const nodeValue = this.getNodeValue(node);
                    if (opts.skip?.({
                        value: nodeValue,
                        node,
                        indexPath
                    })) return "skip";
                    if (this.getNodeChildren(node).length > 0 && this.isSameDepth(indexPath, opts.depth)) {
                        values.push(this.getNodeValue(node));
                    }
                }
            });
            return values.slice(1);
        });
        __publicField(this, "flatten", (rootNode = this.rootNode)=>{
            const nodes = flatMap(rootNode, {
                getChildren: this.getNodeChildren,
                transform: (node, indexPath)=>{
                    const children = this.getNodeChildren(node).map((child)=>this.getNodeValue(child));
                    return [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])({
                            label: this.stringifyNode(node),
                            value: this.getNodeValue(node),
                            indexPath,
                            children: children.length > 0 ? children : void 0
                        })
                    ];
                }
            });
            return nodes.slice(1);
        });
        __publicField(this, "_create", (node, children)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])({
                ...node,
                children
            });
        });
        __publicField(this, "_insert", (rootNode, indexPath, nodes)=>{
            return insert(rootNode, {
                at: indexPath,
                nodes,
                getChildren: this.getNodeChildren,
                create: this._create
            });
        });
        __publicField(this, "_replace", (rootNode, indexPath, node)=>{
            return replace(rootNode, {
                at: indexPath,
                node,
                getChildren: this.getNodeChildren,
                create: this._create
            });
        });
        __publicField(this, "_move", (rootNode, indexPaths, to)=>{
            return move(rootNode, {
                indexPaths,
                to,
                getChildren: this.getNodeChildren,
                create: this._create
            });
        });
        __publicField(this, "replace", (indexPath, node)=>{
            return this._replace(this.rootNode, indexPath, node);
        });
        __publicField(this, "insertBefore", (indexPath, ...nodes)=>{
            const parentIndexPath = indexPath.slice(0, -1);
            const parentNode = this.at(parentIndexPath);
            if (!parentNode) return;
            return this._insert(this.rootNode, indexPath, nodes);
        });
        __publicField(this, "insertAfter", (indexPath, ...nodes)=>{
            const parentIndexPath = indexPath.slice(0, -1);
            const parentNode = this.at(parentIndexPath);
            if (!parentNode) return;
            const nextIndex = [
                ...parentIndexPath,
                indexPath[indexPath.length - 1] + 1
            ];
            return this._insert(this.rootNode, nextIndex, nodes);
        });
        __publicField(this, "reorder", (toIndexPath, ...fromIndexPaths)=>{
            return this._move(this.rootNode, fromIndexPaths, toIndexPath);
        });
        this.rootNode = options.rootNode;
    }
    isEqual(other) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(this.rootNode, other.rootNode);
    }
    at(indexPath) {
        return access(this.rootNode, indexPath, {
            getChildren: this.getNodeChildren
        });
    }
    json() {
        return this.getValues(this.rootNode);
    }
};
function flattenedToTree(nodes) {
    let rootNode = {
        value: "ROOT"
    };
    nodes.map((node)=>{
        const { indexPath, label, value } = node;
        if (!indexPath.length) {
            Object.assign(rootNode, {
                label,
                value,
                children: []
            });
            return;
        }
        rootNode = insert(rootNode, {
            at: indexPath,
            nodes: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])({
                    label,
                    value
                })
            ],
            getChildren: (node2)=>node2.children ?? [],
            create: (node2, children)=>{
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])({
                    ...node2,
                    children
                });
            }
        });
    });
    return new TreeCollection({
        rootNode
    });
}
function filePathToTree(paths) {
    const rootNode = {
        label: "",
        value: "ROOT",
        children: []
    };
    paths.forEach((path)=>{
        const parts = path.split("/");
        let currentNode = rootNode;
        parts.forEach((part)=>{
            let childNode = currentNode.children?.find((child)=>child.label === part);
            if (!childNode) {
                childNode = {
                    value: parts.slice(0, parts.indexOf(part) + 1).join("/"),
                    label: part
                };
                currentNode.children || (currentNode.children = []);
                currentNode.children.push(childNode);
            }
            currentNode = childNode;
        });
    });
    return new TreeCollection({
        rootNode
    });
}
var fallback2 = {
    nodeToValue (node) {
        if (typeof node === "string") return node;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isObject"])(node) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["hasProp"])(node, "value")) return node.value;
        return "";
    },
    nodeToString (node) {
        if (typeof node === "string") return node;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isObject"])(node) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["hasProp"])(node, "label")) return node.label;
        return fallback2.nodeToValue(node);
    },
    isNodeDisabled (node) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isObject"])(node) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["hasProp"])(node, "disabled")) return !!node.disabled;
        return false;
    },
    nodeToChildren (node) {
        return node.children;
    }
};
;
}}),
"[project]/node_modules/@pandacss/is-valid-prop/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/index.ts
__turbopack_esm__({
    "allCssProperties": (()=>allCssProperties),
    "isCssProperty": (()=>isCssProperty)
});
var userGeneratedStr = "";
var userGenerated = userGeneratedStr.split(",");
var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimingFunction,animationTimeline,appearance,aspectRatio,azimuth,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockStyle,borderBlockWidth,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineEnd,borderInlineColor,borderInlineStyle,borderInlineWidth,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,color,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicSize,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,direction,display,emptyCells,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontVariationSettings,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inputSecurity,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,printColorAdjust,quotes,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,scale,scrollbarColor,scrollbarGutter,scrollbarWidth,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockStart,scrollMarginBlockEnd,scrollMarginBottom,scrollMarginInline,scrollMarginInlineStart,scrollMarginInlineEnd,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockStart,scrollPaddingBlockEnd,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineStart,scrollPaddingInlineEnd,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,shapeImageThreshold,shapeMargin,shapeOutside,tabSize,tableLayout,textAlign,textAlignLast,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,zIndex,zoom,alignmentBaseline,baselineShift,clipRule,colorInterpolation,colorRendering,dominantBaseline,fill,fillOpacity,fillRule,floodColor,floodOpacity,glyphOrientationVertical,lightingColor,marker,markerEnd,markerMid,markerStart,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,textAnchor,vectorEffect";
var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
var properties = new Map(allCssProperties.map((prop)=>[
        prop,
        true
    ]));
function memo(fn) {
    const cache = /* @__PURE__ */ Object.create(null);
    return (arg)=>{
        if (cache[arg] === void 0) cache[arg] = fn(arg);
        return cache[arg];
    };
}
var cssPropertySelectorRegex = /&|@/;
var isCssProperty = /* @__PURE__ */ memo((prop)=>{
    return properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
});
;
}}),
"[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/prop-types.ts
__turbopack_esm__({
    "createNormalizer": (()=>createNormalizer),
    "createProps": (()=>createProps)
});
function createNormalizer(fn) {
    return new Proxy({}, {
        get () {
            return fn;
        }
    });
}
// src/create-props.ts
var createProps = ()=>(props)=>Array.from(new Set(props));
;
}}),
"[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/create-anatomy.ts
__turbopack_esm__({
    "createAnatomy": (()=>createAnatomy)
});
var createAnatomy = (name, parts = [])=>({
        parts: (...values)=>{
            if (isEmpty(parts)) {
                return createAnatomy(name, values);
            }
            throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
        },
        extendWith: (...values)=>createAnatomy(name, [
                ...parts,
                ...values
            ]),
        rename: (newName)=>createAnatomy(newName, parts),
        keys: ()=>parts,
        build: ()=>[
                ...new Set(parts)
            ].reduce((prev, part)=>Object.assign(prev, {
                    [part]: {
                        selector: [
                            `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
                            `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
                        ].join(", "),
                        attrs: {
                            "data-scope": toKebabCase(name),
                            "data-part": toKebabCase(part)
                        }
                    }
                }), {})
    });
var toKebabCase = (value)=>value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v)=>v.length === 0;
;
}}),
"[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/attrs.ts
__turbopack_esm__({
    "MAX_Z_INDEX": (()=>MAX_Z_INDEX),
    "ariaAttr": (()=>ariaAttr),
    "contains": (()=>contains),
    "createScope": (()=>createScope),
    "dataAttr": (()=>dataAttr),
    "defaultItemToId": (()=>defaultItemToId),
    "getActiveElement": (()=>getActiveElement),
    "getBeforeInputValue": (()=>getBeforeInputValue),
    "getByText": (()=>getByText),
    "getByTypeahead": (()=>getByTypeahead),
    "getComputedStyle": (()=>getComputedStyle),
    "getDataUrl": (()=>getDataUrl),
    "getDocument": (()=>getDocument),
    "getDocumentElement": (()=>getDocumentElement),
    "getEventTarget": (()=>getEventTarget),
    "getFirstFocusable": (()=>getFirstFocusable),
    "getFirstTabbable": (()=>getFirstTabbable),
    "getFocusables": (()=>getFocusables),
    "getInitialFocus": (()=>getInitialFocus),
    "getLastTabbable": (()=>getLastTabbable),
    "getNearestOverflowAncestor": (()=>getNearestOverflowAncestor),
    "getNextTabbable": (()=>getNextTabbable),
    "getNodeName": (()=>getNodeName),
    "getOverflowAncestors": (()=>getOverflowAncestors),
    "getParentNode": (()=>getParentNode),
    "getPlatform": (()=>getPlatform),
    "getScrollPosition": (()=>getScrollPosition),
    "getTabbableEdges": (()=>getTabbableEdges),
    "getTabbables": (()=>getTabbables),
    "getWindow": (()=>getWindow),
    "indexOfId": (()=>indexOfId),
    "isApple": (()=>isApple),
    "isComposingEvent": (()=>isComposingEvent),
    "isDocument": (()=>isDocument),
    "isDom": (()=>isDom),
    "isDownloadingEvent": (()=>isDownloadingEvent),
    "isEditableElement": (()=>isEditableElement),
    "isFirefox": (()=>isFirefox),
    "isFocusable": (()=>isFocusable),
    "isHTMLElement": (()=>isHTMLElement),
    "isHiddenElement": (()=>isHiddenElement),
    "isInView": (()=>isInView),
    "isIos": (()=>isIos),
    "isMac": (()=>isMac),
    "isNode": (()=>isNode),
    "isOpeningInNewTab": (()=>isOpeningInNewTab),
    "isOverflowElement": (()=>isOverflowElement),
    "isRootElement": (()=>isRootElement),
    "isSafari": (()=>isSafari),
    "isSelfTarget": (()=>isSelfTarget),
    "isShadowRoot": (()=>isShadowRoot),
    "isTabbable": (()=>isTabbable),
    "isTouchDevice": (()=>isTouchDevice),
    "isValidTabEvent": (()=>isValidTabEvent),
    "isVisualViewport": (()=>isVisualViewport),
    "isWebKit": (()=>isWebKit),
    "isWindow": (()=>isWindow),
    "itemById": (()=>itemById),
    "nextById": (()=>nextById),
    "nextTick": (()=>nextTick),
    "observeAttributes": (()=>observeAttributes),
    "observeChildren": (()=>observeChildren),
    "prevById": (()=>prevById),
    "proxyTabFocus": (()=>proxyTabFocus),
    "query": (()=>query),
    "queryAll": (()=>queryAll),
    "raf": (()=>raf),
    "scrollIntoView": (()=>scrollIntoView),
    "set": (()=>set),
    "setAttribute": (()=>setAttribute),
    "setProperty": (()=>setProperty),
    "setStyle": (()=>setStyle),
    "visuallyHiddenStyle": (()=>visuallyHiddenStyle),
    "waitForElement": (()=>waitForElement),
    "waitForElements": (()=>waitForElements)
});
var dataAttr = (guard)=>guard ? "" : void 0;
var ariaAttr = (guard)=>guard ? "true" : void 0;
// src/constants.ts
var MAX_Z_INDEX = 2147483647;
// src/is.ts
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isObject = (v)=>typeof v === "object" && v !== null;
var isHTMLElement = (el)=>isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el)=>isObject(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el)=>isObject(el) && el === el.window;
var isVisualViewport = (el)=>isObject(el) && el.constructor.name === "VisualViewport";
var getNodeName = (node)=>{
    if (isHTMLElement(node)) return node.localName || "";
    return "#document";
};
function isRootElement(node) {
    return [
        "html",
        "body",
        "#document"
    ].includes(getNodeName(node));
}
var isNode = (el)=>isObject(el) && el.nodeType !== void 0;
var isShadowRoot = (el)=>isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
// src/contains.ts
function contains(parent, child) {
    if (!parent || !child) return false;
    if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;
    return parent === child || parent.contains(child);
}
// src/env.ts
function getDocument(el) {
    if (isDocument(el)) return el;
    if (isWindow(el)) return el.document;
    return el?.ownerDocument ?? document;
}
function getDocumentElement(el) {
    return getDocument(el).documentElement;
}
function getWindow(el) {
    if (isShadowRoot(el)) return getWindow(el.host);
    if (isDocument(el)) return el.defaultView ?? window;
    if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;
    return window;
}
function getActiveElement(rootNode) {
    let activeElement = rootNode.activeElement;
    while(activeElement?.shadowRoot){
        const el = activeElement.shadowRoot.activeElement;
        if (el === activeElement) break;
        else activeElement = el;
    }
    return activeElement;
}
// src/data-url.ts
function getDataUrl(svg, opts) {
    const { type, quality = 0.92 } = opts;
    if (!svg) throw new Error("[get-data-url]: could not find the svg element");
    const win = getWindow(svg);
    const doc = win.document;
    const serializer = new win.XMLSerializer();
    const source = '<?xml version="1.0" standalone="no"?>\r\n' + serializer.serializeToString(svg);
    const svgString = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
    if (type === "image/svg+xml") {
        return Promise.resolve(svgString);
    }
    const svgBounds = svg.getBoundingClientRect();
    const dpr = win.devicePixelRatio || 1;
    const canvas = doc.createElement("canvas");
    const image = new win.Image();
    image.src = svgString;
    canvas.width = svgBounds.width * dpr;
    canvas.height = svgBounds.height * dpr;
    const context = canvas.getContext("2d");
    context.scale(dpr, dpr);
    return new Promise((resolve)=>{
        image.onload = ()=>{
            context.drawImage(image, 0, 0);
            resolve(canvas.toDataURL(type, quality));
        };
    });
}
// src/platform.ts
var isDom = ()=>typeof document !== "undefined";
function getPlatform() {
    const agent = navigator.userAgentData;
    return agent?.platform ?? navigator.platform;
}
var pt = (v)=>isDom() && v.test(getPlatform());
var ua = (v)=>isDom() && v.test(navigator.userAgent);
var vn = (v)=>isDom() && v.test(navigator.vendor);
var isTouchDevice = ()=>isDom() && !!navigator.maxTouchPoints;
var isMac = ()=>pt(/^Mac/);
var isSafari = ()=>isApple() && vn(/apple/i);
var isFirefox = ()=>ua(/firefox\//i);
var isApple = ()=>pt(/mac|iphone|ipad|ipod/i);
var isIos = ()=>pt(/iP(hone|ad|od)|iOS/);
var isWebKit = ()=>ua(/AppleWebKit/);
// src/event.ts
function getBeforeInputValue(event) {
    const { selectionStart, selectionEnd, value } = event.currentTarget;
    return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);
}
function getComposedPath(event) {
    return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();
}
function getEventTarget(event) {
    const composedPath = getComposedPath(event);
    return composedPath?.[0] ?? event.target;
}
var isSelfTarget = (event)=>{
    return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
    const element = event.currentTarget;
    if (!element) return false;
    const isAppleDevice = isApple();
    if (isAppleDevice && !event.metaKey) return false;
    if (!isAppleDevice && !event.ctrlKey) return false;
    const localName = element.localName;
    if (localName === "a") return true;
    if (localName === "button" && element.type === "submit") return true;
    if (localName === "input" && element.type === "submit") return true;
    return false;
}
function isDownloadingEvent(event) {
    const element = event.currentTarget;
    if (!element) return false;
    const localName = element.localName;
    if (!event.altKey) return false;
    if (localName === "a") return true;
    if (localName === "button" && element.type === "submit") return true;
    if (localName === "input" && element.type === "submit") return true;
    return false;
}
function isComposingEvent(event) {
    return event.nativeEvent?.isComposing ?? event.isComposing;
}
// src/get-by-id.ts
var defaultItemToId = (v)=>v.id;
function itemById(v, id, itemToId = defaultItemToId) {
    return v.find((item)=>itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
    const item = itemById(v, id, itemToId);
    return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
    let idx = indexOfId(v, id);
    idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
    return v[idx];
}
function prevById(v, id, loop = true) {
    let idx = indexOfId(v, id);
    if (idx === -1) return loop ? v[v.length - 1] : null;
    idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
    return v[idx];
}
// src/sanitize.ts
var sanitize = (str)=>str.split("").map((char)=>{
        const code = char.charCodeAt(0);
        if (code > 0 && code < 128) return char;
        if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
        return "";
    }).join("").trim();
// src/get-by-text.ts
var getValueText = (item)=>sanitize(item.dataset?.valuetext ?? item.textContent ?? "");
var match = (valueText, query2)=>valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
var wrap = (v, idx)=>{
    return v.map((_, index)=>v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText(v, text, currentId, itemToId = defaultItemToId) {
    const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
    let items = currentId ? wrap(v, index) : v;
    const isSingleKey = text.length === 1;
    if (isSingleKey) {
        items = items.filter((item)=>itemToId(item) !== currentId);
    }
    return items.find((item)=>match(getValueText(item), text));
}
// src/get-by-typeahead.ts
function getByTypeaheadImpl(_items, options) {
    const { state, activeId, key, timeout = 350, itemToId } = options;
    const search = state.keysSoFar + key;
    const isRepeated = search.length > 1 && Array.from(search).every((char)=>char === search[0]);
    const query2 = isRepeated ? search[0] : search;
    let items = _items.slice();
    const next = getByText(items, query2, activeId, itemToId);
    function cleanup() {
        clearTimeout(state.timer);
        state.timer = -1;
    }
    function update(value) {
        state.keysSoFar = value;
        cleanup();
        if (value !== "") {
            state.timer = +setTimeout(()=>{
                update("");
                cleanup();
            }, timeout);
        }
    }
    update(search);
    return next;
}
var getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {
    defaultOptions: {
        keysSoFar: "",
        timer: -1
    },
    isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
    return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
// src/get-computed-style.ts
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle(el) {
    if (!styleCache.has(el)) {
        styleCache.set(el, getWindow(el).getComputedStyle(el));
    }
    return styleCache.get(el);
}
// src/get-parent-node.ts
function getParentNode(node) {
    if (getNodeName(node) === "html") {
        return node;
    }
    const result = // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
}
// src/get-scroll-position.ts
function getScrollPosition(element) {
    if (isHTMLElement(element)) {
        return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
        };
    }
    return {
        scrollLeft: element.scrollX,
        scrollTop: element.scrollY
    };
}
// src/tabbable.ts
var isHTMLElement2 = (element)=>typeof element === "object" && element !== null && element.nodeType === 1;
var isFrame = (element)=>isHTMLElement2(element) && element.tagName === "IFRAME";
function isVisible(el) {
    if (!isHTMLElement2(el)) return false;
    return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
}
function hasNegativeTabIndex(element) {
    const tabIndex = parseInt(element.getAttribute("tabindex") || "0", 10);
    return tabIndex < 0;
}
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false)=>{
    if (!container) return [];
    const elements = Array.from(container.querySelectorAll(focusableSelector));
    const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
    if (include && isHTMLElement2(container) && isFocusable(container)) {
        elements.unshift(container);
    }
    const focusableElements = elements.filter(isFocusable);
    focusableElements.forEach((element, i)=>{
        if (isFrame(element) && element.contentDocument) {
            const frameBody = element.contentDocument.body;
            focusableElements.splice(i, 1, ...getFocusables(frameBody));
        }
    });
    return focusableElements;
};
function isFocusable(element) {
    if (!element || element.closest("[inert]")) return false;
    return element.matches(focusableSelector) && isVisible(element);
}
function getFirstFocusable(container, includeContainer) {
    const [first] = getFocusables(container, includeContainer);
    return first || null;
}
function getTabbables(container, includeContainer) {
    if (!container) return [];
    const elements = Array.from(container.querySelectorAll(focusableSelector));
    const tabbableElements = elements.filter(isTabbable);
    if (includeContainer && isTabbable(container)) {
        tabbableElements.unshift(container);
    }
    tabbableElements.forEach((element, i)=>{
        if (isFrame(element) && element.contentDocument) {
            const frameBody = element.contentDocument.body;
            const allFrameTabbable = getTabbables(frameBody);
            tabbableElements.splice(i, 1, ...allFrameTabbable);
        }
    });
    if (!tabbableElements.length && includeContainer) {
        return elements;
    }
    return tabbableElements;
}
function isTabbable(el) {
    if (el != null && el.tabIndex > 0) return true;
    return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getFirstTabbable(container, includeContainer) {
    const [first] = getTabbables(container, includeContainer);
    return first || null;
}
function getLastTabbable(container, includeContainer) {
    const elements = getTabbables(container, includeContainer);
    return elements[elements.length - 1] || null;
}
function getTabbableEdges(container, includeContainer) {
    const elements = getTabbables(container, includeContainer);
    const first = elements[0] || null;
    const last = elements[elements.length - 1] || null;
    return [
        first,
        last
    ];
}
function getNextTabbable(container, current) {
    const tabbables = getTabbables(container);
    const doc = container?.ownerDocument || document;
    const currentElement = current ?? doc.activeElement;
    if (!currentElement) return null;
    const index = tabbables.indexOf(currentElement);
    return tabbables[index + 1] || null;
}
// src/initial-focus.ts
function getInitialFocus(options) {
    const { root, getInitialEl, filter, enabled = true } = options;
    if (!enabled) return;
    let node = null;
    node || (node = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
    node || (node = root?.querySelector("[data-autofocus],[autofocus]"));
    if (!node) {
        const tabbables = getTabbables(root);
        node = filter ? tabbables.filter(filter)[0] : tabbables[0];
    }
    return node || root || void 0;
}
function isValidTabEvent(event) {
    const container = event.currentTarget;
    if (!container) return false;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container);
    const doc = container.ownerDocument || document;
    if (doc.activeElement === firstTabbable && event.shiftKey) return false;
    if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
    if (!firstTabbable && !lastTabbable) return false;
    return true;
}
// src/is-editable-element.ts
function isEditableElement(el) {
    if (el == null || !isHTMLElement(el)) {
        return false;
    }
    try {
        const win = getWindow(el);
        return el instanceof win.HTMLInputElement && el.selectionStart != null || /(textarea|select)/.test(el.localName) || el.isContentEditable;
    } catch  {
        return false;
    }
}
// src/is-hidden-element.ts
function isHiddenElement(node) {
    if (node.parentElement && isHiddenElement(node.parentElement)) return true;
    return node.hidden;
}
// src/is-overflow-element.ts
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement(el) {
    const win = getWindow(el);
    const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
    return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![
        "inline",
        "contents"
    ].includes(display);
}
// src/raf.ts
function nextTick(fn) {
    const set2 = /* @__PURE__ */ new Set();
    function raf2(fn2) {
        const id = globalThis.requestAnimationFrame(fn2);
        set2.add(()=>globalThis.cancelAnimationFrame(id));
    }
    raf2(()=>raf2(fn));
    return function cleanup() {
        set2.forEach((fn2)=>fn2());
    };
}
function raf(fn) {
    const id = globalThis.requestAnimationFrame(fn);
    return ()=>{
        globalThis.cancelAnimationFrame(id);
    };
}
// src/observe-attributes.ts
function observeAttributesImpl(node, options) {
    if (!node) return;
    const { attributes, callback: fn } = options;
    const win = node.ownerDocument.defaultView || window;
    const obs = new win.MutationObserver((changes)=>{
        for (const change of changes){
            if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
                fn(change);
            }
        }
    });
    obs.observe(node, {
        attributes: true,
        attributeFilter: attributes
    });
    return ()=>obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? raf : (v)=>v();
    const cleanups2 = [];
    cleanups2.push(func(()=>{
        const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
        cleanups2.push(observeAttributesImpl(node, options));
    }));
    return ()=>{
        cleanups2.forEach((fn)=>fn?.());
    };
}
// src/observe-children.ts
function observeChildrenImpl(node, options) {
    const { callback: fn } = options;
    if (!node) return;
    const win = node.ownerDocument.defaultView || window;
    const obs = new win.MutationObserver(fn);
    obs.observe(node, {
        childList: true,
        subtree: true
    });
    return ()=>obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? raf : (v)=>v();
    const cleanups2 = [];
    cleanups2.push(func(()=>{
        const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
        cleanups2.push(observeChildrenImpl(node, options));
    }));
    return ()=>{
        cleanups2.forEach((fn)=>fn?.());
    };
}
// src/overflow.ts
function getNearestOverflowAncestor(el) {
    const parentNode = getParentNode(el);
    if (isRootElement(parentNode)) {
        return getDocument(parentNode).body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
        return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(el, list = []) {
    const scrollableAncestor = getNearestOverflowAncestor(el);
    const isBody = scrollableAncestor === el.ownerDocument.body;
    const win = getWindow(scrollableAncestor);
    if (isBody) {
        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
var getRect = (el)=>{
    if (isHTMLElement(el)) {
        return el.getBoundingClientRect();
    }
    if (isVisualViewport(el)) {
        return {
            top: 0,
            left: 0,
            bottom: el.height,
            right: el.width
        };
    }
    return {
        top: 0,
        left: 0,
        bottom: el.innerHeight,
        right: el.innerWidth
    };
};
function isInView(el, ancestor) {
    if (!isHTMLElement(el)) return true;
    const ancestorRect = getRect(ancestor);
    const elRect = el.getBoundingClientRect();
    return elRect.top >= ancestorRect.top && elRect.left >= ancestorRect.left && elRect.bottom <= ancestorRect.bottom && elRect.right <= ancestorRect.right;
}
// src/proxy-tab-focus.ts
function proxyTabFocusImpl(container, options = {}) {
    const { triggerElement, onFocus } = options;
    const doc = container?.ownerDocument || document;
    const body = doc.body;
    function onKeyDown(event) {
        if (event.key !== "Tab") return;
        let elementToFocus = null;
        const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);
        const noTabbableElements = !firstTabbable && !lastTabbable;
        if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {
            elementToFocus = triggerElement;
        } else if (!event.shiftKey && doc.activeElement === triggerElement) {
            elementToFocus = firstTabbable;
        } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {
            elementToFocus = getNextTabbable(body, triggerElement);
        }
        if (!elementToFocus) return;
        event.preventDefault();
        if (typeof onFocus === "function") {
            onFocus(elementToFocus);
        } else {
            elementToFocus.focus();
        }
    }
    doc?.addEventListener("keydown", onKeyDown, true);
    return ()=>{
        doc?.removeEventListener("keydown", onKeyDown, true);
    };
}
function proxyTabFocus(container, options) {
    const { defer, triggerElement, ...restOptions } = options;
    const func = defer ? raf : (v)=>v();
    const cleanups2 = [];
    cleanups2.push(func(()=>{
        const node = typeof container === "function" ? container() : container;
        const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
        cleanups2.push(proxyTabFocusImpl(node, {
            triggerElement: trigger,
            ...restOptions
        }));
    }));
    return ()=>{
        cleanups2.forEach((fn)=>fn?.());
    };
}
// src/query.ts
function queryAll(root, selector) {
    return Array.from(root?.querySelectorAll(selector) ?? []);
}
function query(root, selector) {
    return root?.querySelector(selector) ?? null;
}
// src/scope.ts
function createScope(methods) {
    const dom = {
        getRootNode: (ctx)=>ctx.getRootNode?.() ?? document,
        getDoc: (ctx)=>getDocument(dom.getRootNode(ctx)),
        getWin: (ctx)=>dom.getDoc(ctx).defaultView ?? window,
        getActiveElement: (ctx)=>getActiveElement(dom.getRootNode(ctx)),
        isActiveElement: (ctx, elem)=>elem === dom.getActiveElement(ctx),
        getById: (ctx, id)=>dom.getRootNode(ctx).getElementById(id),
        setValue: (elem, value)=>{
            if (elem == null || value == null) return;
            const valueAsString = value.toString();
            if (elem.value === valueAsString) return;
            elem.value = value.toString();
        }
    };
    return {
        ...dom,
        ...methods
    };
}
// src/scroll-into-view.ts
function isScrollable(el) {
    return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options) {
    const { rootEl, ...scrollOptions } = options || {};
    if (!el || !rootEl) {
        return;
    }
    if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {
        return;
    }
    el.scrollIntoView(scrollOptions);
}
// src/set.ts
var cleanups = /* @__PURE__ */ new WeakMap();
function set(element, key, setup) {
    if (!cleanups.has(element)) {
        cleanups.set(element, /* @__PURE__ */ new Map());
    }
    const elementCleanups = cleanups.get(element);
    const prevCleanup = elementCleanups.get(key);
    if (!prevCleanup) {
        elementCleanups.set(key, setup());
        return ()=>{
            elementCleanups.get(key)?.();
            elementCleanups.delete(key);
        };
    }
    const cleanup = setup();
    const nextCleanup = ()=>{
        cleanup();
        prevCleanup();
        elementCleanups.delete(key);
    };
    elementCleanups.set(key, nextCleanup);
    return ()=>{
        const isCurrent = elementCleanups.get(key) === nextCleanup;
        if (!isCurrent) return;
        cleanup();
        elementCleanups.set(key, prevCleanup);
    };
}
function setAttribute(element, attr, value) {
    const setup = ()=>{
        const previousValue = element.getAttribute(attr);
        element.setAttribute(attr, value);
        return ()=>{
            if (previousValue == null) {
                element.removeAttribute(attr);
            } else {
                element.setAttribute(attr, previousValue);
            }
        };
    };
    return set(element, attr, setup);
}
function setProperty(element, property, value) {
    const setup = ()=>{
        const exists = property in element;
        const previousValue = element[property];
        element[property] = value;
        return ()=>{
            if (!exists) {
                delete element[property];
            } else {
                element[property] = previousValue;
            }
        };
    };
    return set(element, property, setup);
}
function setStyle(element, style) {
    if (!element) return ()=>{};
    const setup = ()=>{
        const prevStyle = element.style.cssText;
        Object.assign(element.style, style);
        return ()=>{
            element.style.cssText = prevStyle;
        };
    };
    return set(element, "style", setup);
}
// src/visually-hidden.ts
var visuallyHiddenStyle = {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px",
    whiteSpace: "nowrap",
    wordWrap: "normal"
};
// src/wait-for.ts
var fps = 1e3 / 60;
function waitForElement(query2, cb) {
    const el = query2();
    if (isHTMLElement(el) && el.isConnected) {
        cb(el);
        return ()=>void 0;
    } else {
        const timerId = setInterval(()=>{
            const el2 = query2();
            if (isHTMLElement(el2) && el2.isConnected) {
                cb(el2);
                clearInterval(timerId);
            }
        }, fps);
        return ()=>clearInterval(timerId);
    }
}
function waitForElements(queries, cb) {
    const cleanups2 = [];
    queries?.forEach((query2)=>{
        const clean = waitForElement(query2, cb);
        cleanups2.push(clean);
    });
    return ()=>{
        cleanups2.forEach((fn)=>fn());
    };
}
;
}}),
"[project]/node_modules/@zag-js/text-selection/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "disableTextSelection": (()=>disableTextSelection),
    "restoreTextSelection": (()=>restoreTextSelection)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
;
// src/index.ts
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
    const { target, doc } = options;
    const docNode = doc ?? document;
    const rootEl = docNode.documentElement;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isIos"])()) {
        if (state === "default") {
            userSelect = rootEl.style.webkitUserSelect;
            rootEl.style.webkitUserSelect = "none";
        }
        state = "disabled";
    } else if (target) {
        elementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
    return ()=>restoreTextSelection({
            target,
            doc: docNode
        });
}
function restoreTextSelection(options = {}) {
    const { target, doc } = options;
    const docNode = doc ?? document;
    const rootEl = docNode.documentElement;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isIos"])()) {
        if (state !== "disabled") return;
        state = "restoring";
        setTimeout(()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nextTick"])(()=>{
                if (state === "restoring") {
                    if (rootEl.style.webkitUserSelect === "none") {
                        rootEl.style.webkitUserSelect = userSelect || "";
                    }
                    userSelect = "";
                    state = "default";
                }
            });
        }, 300);
    } else {
        if (target && elementMap.has(target)) {
            const prevUserSelect = elementMap.get(target);
            if (target.style.userSelect === "none") {
                target.style.userSelect = prevUserSelect ?? "";
            }
            if (target.getAttribute("style") === "") {
                target.removeAttribute("style");
            }
            elementMap.delete(target);
        }
    }
}
function disableTextSelection(options = {}) {
    const { defer, target, ...restOptions } = options;
    const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = typeof target === "function" ? target() : target;
        cleanups.push(disableTextSelectionImpl({
            ...restOptions,
            target: node
        }));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn?.());
    };
}
;
}}),
"[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "addDomEvent": (()=>addDomEvent),
    "clickIfLink": (()=>clickIfLink),
    "fireBlurEvent": (()=>fireBlurEvent),
    "fireCustomEvent": (()=>fireCustomEvent),
    "getEventKey": (()=>getEventKey),
    "getEventPoint": (()=>getEventPoint),
    "getEventStep": (()=>getEventStep),
    "getNativeEvent": (()=>getNativeEvent),
    "getRelativePoint": (()=>getRelativePoint),
    "isContextMenuEvent": (()=>isContextMenuEvent),
    "isKeyboardClick": (()=>isKeyboardClick),
    "isLeftClick": (()=>isLeftClick),
    "isModifierKey": (()=>isModifierKey),
    "isPrintableKey": (()=>isPrintableKey),
    "isVirtualClick": (()=>isVirtualClick),
    "isVirtualPointerEvent": (()=>isVirtualPointerEvent),
    "queueBeforeEvent": (()=>queueBeforeEvent),
    "requestPointerLock": (()=>requestPointerLock),
    "trackPointerMove": (()=>trackPointerMove),
    "trackPress": (()=>trackPress),
    "trackVisualViewport": (()=>trackVisualViewport)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$text$2d$selection$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/text-selection/dist/index.mjs [app-rsc] (ecmascript)");
;
;
// src/add-dom-event.ts
var addDomEvent = (target, eventName, handler, options)=>{
    const node = typeof target === "function" ? target() : target;
    node?.addEventListener(eventName, handler, options);
    return ()=>{
        node?.removeEventListener(eventName, handler, options);
    };
};
function isKeyboardClick(e) {
    return e.detail === 0 || e.clientX === 0 && e.clientY === 0;
}
function isPrintableKey(e) {
    return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
function isVirtualPointerEvent(e) {
    return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse";
}
function isVirtualClick(e) {
    if (e.mozInputSource === 0 && e.isTrusted) return true;
    return e.detail === 0 && !e.pointerType;
}
var isLeftClick = (e)=>e.button === 0;
var isContextMenuEvent = (e)=>{
    return e.button === 2 || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isMac"])() && e.ctrlKey && e.button === 0;
};
var isModifierKey = (e)=>e.ctrlKey || e.altKey || e.metaKey;
// src/queue-before-event.ts
function queueBeforeEvent(element, type, cb) {
    const createTimer = (callback)=>{
        const timerId = requestAnimationFrame(callback);
        return ()=>cancelAnimationFrame(timerId);
    };
    const cancelTimer = createTimer(()=>{
        element.removeEventListener(type, callSync, true);
        cb();
    });
    const callSync = ()=>{
        cancelTimer();
        cb();
    };
    element.addEventListener(type, callSync, {
        once: true,
        capture: true
    });
    return cancelTimer;
}
// src/click-link.ts
function isLinkElement(element) {
    return element?.matches("a[href]") ?? false;
}
function clickIfLink(element) {
    if (!isLinkElement(element)) return;
    const click = ()=>element.click();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFirefox"])()) {
        queueBeforeEvent(element, "keyup", click);
    } else {
        queueMicrotask(click);
    }
}
// src/fire-event.ts
function fireCustomEvent(el, type, init) {
    if (!el) return;
    const win = el.ownerDocument.defaultView || window;
    const event = new win.CustomEvent(type, init);
    return el.dispatchEvent(event);
}
function fireBlurEvent(el, init) {
    const win = el.ownerDocument.defaultView || window;
    const event = new win.FocusEvent("blur", init);
    const allowed = el.dispatchEvent(event);
    const bubbleInit = {
        ...init,
        bubbles: true
    };
    el.dispatchEvent(new win.FocusEvent("focusout", bubbleInit));
    return allowed;
}
// src/get-event-key.ts
var keyMap = {
    Up: "ArrowUp",
    Down: "ArrowDown",
    Esc: "Escape",
    " ": "Space",
    ",": "Comma",
    Left: "ArrowLeft",
    Right: "ArrowRight"
};
var rtlKeyMap = {
    ArrowLeft: "ArrowRight",
    ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
    const { dir = "ltr", orientation = "horizontal" } = options;
    let { key } = event;
    key = keyMap[key] ?? key;
    const isRtl = dir === "rtl" && orientation === "horizontal";
    if (isRtl && key in rtlKeyMap) {
        key = rtlKeyMap[key];
    }
    return key;
}
// src/get-event-point.ts
function pointFromTouch(e, type = "client") {
    const point = e.touches[0] || e.changedTouches[0];
    return {
        x: point[`${type}X`],
        y: point[`${type}Y`]
    };
}
function pointFromMouse(point, type = "client") {
    return {
        x: point[`${type}X`],
        y: point[`${type}Y`]
    };
}
var isTouchEvent = (event)=>"touches" in event && event.touches.length > 0;
function getEventPoint(event, type = "client") {
    return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type);
}
// src/get-event-step.ts
var PAGE_KEYS = /* @__PURE__ */ new Set([
    "PageUp",
    "PageDown"
]);
var ARROW_KEYS = /* @__PURE__ */ new Set([
    "ArrowUp",
    "ArrowDown",
    "ArrowLeft",
    "ArrowRight"
]);
function getEventStep(event) {
    if (event.ctrlKey || event.metaKey) {
        return 0.1;
    } else {
        const isPageKey = PAGE_KEYS.has(event.key);
        const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.has(event.key);
        return isSkipKey ? 10 : 1;
    }
}
// src/get-native-event.ts
function getNativeEvent(event) {
    return event.nativeEvent ?? event;
}
// src/get-point-value.ts
function clamp(value) {
    return Math.max(0, Math.min(1, value));
}
function getRelativePoint(point, element) {
    const { left, top, width, height } = element.getBoundingClientRect();
    const offset = {
        x: point.x - left,
        y: point.y - top
    };
    const percent = {
        x: clamp(offset.x / width),
        y: clamp(offset.y / height)
    };
    function getPercentValue(options = {}) {
        const { dir = "ltr", orientation = "horizontal", inverted } = options;
        const invertX = typeof inverted === "object" ? inverted.x : inverted;
        const invertY = typeof inverted === "object" ? inverted.y : inverted;
        if (orientation === "horizontal") {
            return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
        }
        return invertY ? 1 - percent.y : percent.y;
    }
    return {
        offset,
        percent,
        getPercentValue
    };
}
// src/request-pointer-lock.ts
function requestPointerLock(doc, fn) {
    const body = doc.body;
    const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
    const isLocked = ()=>!!doc.pointerLockElement;
    function onPointerChange() {
        fn?.(isLocked());
    }
    function onPointerError(event) {
        if (isLocked()) fn?.(false);
        console.error("PointerLock error occured:", event);
        doc.exitPointerLock();
    }
    if (!supported) return;
    try {
        body.requestPointerLock();
    } catch  {}
    const cleanup = [
        addDomEvent(doc, "pointerlockchange", onPointerChange, false),
        addDomEvent(doc, "pointerlockerror", onPointerError, false)
    ];
    return ()=>{
        cleanup.forEach((cleanup2)=>cleanup2());
        doc.exitPointerLock();
    };
}
function trackPointerMove(doc, handlers) {
    const { onPointerMove, onPointerUp } = handlers;
    const history = [];
    const handleMove = (event)=>{
        const point = getEventPoint(event);
        history.push({
            ...point,
            timestamp: performance.now()
        });
        const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
        const moveBuffer = event.pointerType === "touch" ? 10 : 5;
        if (distance < moveBuffer) return;
        if (event.pointerType === "mouse" && event.button === 0) {
            onPointerUp();
            return;
        }
        onPointerMove({
            point,
            event,
            velocity: getVelocity(history, 0.1)
        });
    };
    const cleanups = [
        addDomEvent(doc, "pointermove", handleMove, false),
        addDomEvent(doc, "pointerup", onPointerUp, false),
        addDomEvent(doc, "pointercancel", onPointerUp, false),
        addDomEvent(doc, "contextmenu", onPointerUp, false),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$text$2d$selection$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["disableTextSelection"])({
            doc
        })
    ];
    return ()=>{
        cleanups.forEach((cleanup)=>cleanup());
        history.length = 0;
    };
}
function lastDevicePoint(history) {
    return history[history.length - 1];
}
function ms(seconds) {
    return seconds * 1e3;
}
function sec(milliseconds) {
    return milliseconds / 1e3;
}
function getVelocity(history, timeDelta) {
    if (history.length < 2) return {
        x: 0,
        y: 0
    };
    let i = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while(i >= 0){
        timestampedPoint = history[i];
        if (lastPoint.timestamp - timestampedPoint.timestamp > ms(timeDelta)) {
            break;
        }
        i--;
    }
    if (!timestampedPoint) return {
        x: 0,
        y: 0
    };
    const time = sec(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time === 0) return {
        x: 0,
        y: 0
    };
    const currentVelocity = {
        x: (lastPoint.x - timestampedPoint.x) / time,
        y: (lastPoint.y - timestampedPoint.y) / time
    };
    if (currentVelocity.x === Infinity) currentVelocity.x = 0;
    if (currentVelocity.y === Infinity) currentVelocity.y = 0;
    return {
        x: Math.abs(currentVelocity.x),
        y: Math.abs(currentVelocity.y)
    };
}
// src/pipe.ts
var pipe = (...fns)=>(arg)=>fns.reduce((acc, fn)=>fn(acc), arg);
var noop = ()=>void 0;
// src/track-press.ts
function trackPress(options) {
    const { pointerNode, keyboardNode = pointerNode, onPress, onPressStart, onPressEnd, isValidKey = (e)=>e.key === "Enter" } = options;
    if (!pointerNode) return noop;
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(pointerNode);
    const doc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocument"])(pointerNode);
    let removeStartListeners = noop;
    let removeEndListeners = noop;
    let removeAccessibleListeners = noop;
    const getInfo = (event)=>({
            point: getEventPoint(event),
            event
        });
    function startPress(event) {
        onPressStart?.(getInfo(event));
    }
    function cancelPress(event) {
        onPressEnd?.(getInfo(event));
    }
    const startPointerPress = (startEvent)=>{
        removeEndListeners();
        const endPointerPress = (endEvent)=>{
            const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(endEvent);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["contains"])(pointerNode, target)) {
                onPress?.(getInfo(endEvent));
            } else {
                onPressEnd?.(getInfo(endEvent));
            }
        };
        const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, {
            passive: !onPress
        });
        const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, {
            passive: !onPressEnd
        });
        removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
        if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
            startEvent.preventDefault();
        }
        startPress(startEvent);
    };
    const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, {
        passive: !onPressStart
    });
    const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
    removeStartListeners = pipe(removePointerListener, removeFocusListener);
    function startAccessiblePress() {
        const handleKeydown = (keydownEvent)=>{
            if (!isValidKey(keydownEvent)) return;
            const handleKeyup = (keyupEvent)=>{
                if (!isValidKey(keyupEvent)) return;
                const evt2 = new win.PointerEvent("pointerup");
                const info = getInfo(evt2);
                onPress?.(info);
                onPressEnd?.(info);
            };
            removeEndListeners();
            removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
            const evt = new win.PointerEvent("pointerdown");
            startPress(evt);
        };
        const handleBlur = ()=>{
            const evt = new win.PointerEvent("pointercancel");
            cancelPress(evt);
        };
        const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
        const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
        removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    }
    return function() {
        removeStartListeners();
        removeEndListeners();
        removeAccessibleListeners();
    };
}
// src/track-visual-viewport.ts
function trackVisualViewport(doc, fn) {
    const win = doc?.defaultView || window;
    const onResize = ()=>{
        fn?.(getViewportSize(win));
    };
    onResize();
    return addDomEvent(win.visualViewport ?? win, "resize", onResize);
}
function getViewportSize(win) {
    return {
        width: win.visualViewport?.width || win.innerWidth,
        height: win.visualViewport?.height || win.innerHeight
    };
}
;
}}),
"[project]/node_modules/klona/full/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "klona": (()=>klona)
});
function set(obj, key, val) {
    if (typeof val.value === 'object') val.value = klona(val.value);
    if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {
        Object.defineProperty(obj, key, val);
    } else obj[key] = val.value;
}
function klona(x) {
    if (typeof x !== 'object') return x;
    var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);
    if (str === '[object Object]') {
        tmp = Object.create(x.__proto__ || null);
    } else if (str === '[object Array]') {
        tmp = Array(x.length);
    } else if (str === '[object Set]') {
        tmp = new Set;
        x.forEach(function(val) {
            tmp.add(klona(val));
        });
    } else if (str === '[object Map]') {
        tmp = new Map;
        x.forEach(function(val, key) {
            tmp.set(klona(key), klona(val));
        });
    } else if (str === '[object Date]') {
        tmp = new Date(+x);
    } else if (str === '[object RegExp]') {
        tmp = new RegExp(x.source, x.flags);
    } else if (str === '[object DataView]') {
        tmp = new x.constructor(klona(x.buffer));
    } else if (str === '[object ArrayBuffer]') {
        tmp = x.slice(0);
    } else if (str.slice(-6) === 'Array]') {
        // ArrayBuffer.isView(x)
        // ~> `new` bcuz `Buffer.slice` => ref
        tmp = new x.constructor(x);
    }
    if (tmp) {
        for(list = Object.getOwnPropertySymbols(x); i < list.length; i++){
            set(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));
        }
        for(i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++){
            if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k]) continue;
            set(tmp, k, Object.getOwnPropertyDescriptor(x, k));
        }
    }
    return tmp || x;
}
}}),
"[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Machine": (()=>Machine),
    "choose": (()=>choose),
    "createMachine": (()=>createMachine),
    "deepMerge": (()=>deepMerge),
    "guards": (()=>guards),
    "isMachine": (()=>isMachine),
    "mergeProps": (()=>mergeProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$klona$2f$full$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/klona/full/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/store/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
function deepMerge(source, ...objects) {
    for (const obj of objects){
        const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(obj);
        for(const key in target){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isPlainObject"])(obj[key])) {
                if (!source[key]) {
                    source[key] = {};
                }
                deepMerge(source[key], obj[key]);
            } else {
                source[key] = obj[key];
            }
        }
    }
    return source;
}
function structuredClone(v) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$klona$2f$full$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["klona"])(v);
}
function toEvent(event) {
    const obj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(event) ? {
        type: event
    } : event;
    return obj;
}
function toArray(value) {
    if (!value) return [];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isArray"])(value) ? value.slice() : [
        value
    ];
}
function isGuardHelper(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isObject"])(value) && value.predicate != null;
}
// src/guard-utils.ts
var Truthy = ()=>true;
function exec(guardMap, ctx, event, meta) {
    return (guard)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(guard)) {
            return !!guardMap[guard]?.(ctx, event, meta);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFunction"])(guard)) {
            return guard(ctx, event, meta);
        }
        return guard.predicate(guardMap)(ctx, event, meta);
    };
}
function or(...conditions) {
    return {
        predicate: (guardMap)=>(ctx, event, meta)=>conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)
    };
}
function and(...conditions) {
    return {
        predicate: (guardMap)=>(ctx, event, meta)=>conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)
    };
}
function not(condition) {
    return {
        predicate: (guardMap)=>(ctx, event, meta)=>{
                return !exec(guardMap, ctx, event, meta)(condition);
            }
    };
}
function stateIn(...values) {
    return (_ctx, _evt, meta)=>meta.state.matches(...values);
}
var guards = {
    or,
    and,
    not,
    stateIn
};
function choose(actions) {
    return {
        predicate: (guardMap)=>(ctx, event, meta)=>actions.find((def)=>{
                    const guard = def.guard ?? Truthy;
                    return exec(guardMap, ctx, event, meta)(guard);
                })?.actions
    };
}
function determineGuardFn(guard, guardMap) {
    guard = guard ?? Truthy;
    return (context, event, meta)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(guard)) {
            const value = guardMap[guard];
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFunction"])(value) ? value(context, event, meta) : value;
        }
        if (isGuardHelper(guard)) {
            return guard.predicate(guardMap)(context, event, meta);
        }
        return guard?.(context, event, meta);
    };
}
function determineActionsFn(values, guardMap) {
    return (context, event, meta)=>{
        if (isGuardHelper(values)) {
            return values.predicate(guardMap)(context, event, meta);
        }
        return values;
    };
}
function createProxy(config) {
    const computedContext = config.computed ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cast"])({});
    const initialContext = config.context ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cast"])({});
    const initialTags = config.initial ? config.states?.[config.initial]?.tags : [];
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["proxy"])({
        value: config.initial ?? "",
        previousValue: "",
        event: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cast"])({}),
        previousEvent: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cast"])({}),
        context: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["proxyWithComputed"])(initialContext, computedContext),
        done: false,
        tags: initialTags ?? [],
        hasTag (tag) {
            return this.tags.includes(tag);
        },
        matches (...value) {
            return value.includes(this.value);
        },
        can (event) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cast"])(this).nextEvents.includes(event);
        },
        get nextEvents () {
            const stateEvents = config.states?.[this.value]?.["on"] ?? {};
            const globalEvents = config?.on ?? {};
            return Object.keys({
                ...stateEvents,
                ...globalEvents
            });
        },
        get changed () {
            if (this.event.value === "machine.init" /* Init */  || !this.previousValue) return false;
            return this.value !== this.previousValue;
        }
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cast"])(state);
}
function determineDelayFn(delay, delaysMap) {
    return (context, event)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isNumber"])(delay)) return delay;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFunction"])(delay)) {
            return delay(context, event);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(delay)) {
            const value = Number.parseFloat(delay);
            if (!Number.isNaN(value)) {
                return value;
            }
            if (delaysMap) {
                const valueOrFn = delaysMap?.[delay];
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["invariant"])(valueOrFn == null, `[@zag-js/core > determine-delay] Cannot determine delay for \`${delay}\`. It doesn't exist in \`options.delays\``);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFunction"])(valueOrFn) ? valueOrFn(context, event) : valueOrFn;
            }
        }
    };
}
function toTarget(target) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(target) ? {
        target
    } : target;
}
function determineTransitionFn(transitions, guardMap) {
    return (context, event, meta)=>{
        return toArray(transitions).map(toTarget).find((transition)=>{
            const determineGuard = determineGuardFn(transition.guard, guardMap);
            const guard = determineGuard(context, event, meta);
            return guard ?? transition.target ?? transition.actions;
        });
    };
}
// src/machine.ts
var Machine = class {
    // Let's get started!
    constructor(config, options){
        __publicField(this, "status", "Not Started" /* NotStarted */ );
        __publicField(this, "state");
        __publicField(this, "initialState");
        __publicField(this, "initialContext");
        __publicField(this, "id");
        __publicField(this, "type", "machine" /* Machine */ );
        // Cleanup function map (per state)
        __publicField(this, "activityEvents", /* @__PURE__ */ new Map());
        __publicField(this, "delayedEvents", /* @__PURE__ */ new Map());
        // state update listeners the user can opt-in for
        __publicField(this, "stateListeners", /* @__PURE__ */ new Set());
        __publicField(this, "doneListeners", /* @__PURE__ */ new Set());
        __publicField(this, "contextWatchers", /* @__PURE__ */ new Set());
        // Cleanup functions (for `subscribe`)
        __publicField(this, "removeStateListener", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["noop"]);
        // For Parent <==> Spawned Actor relationship
        __publicField(this, "parent");
        __publicField(this, "children", /* @__PURE__ */ new Map());
        // A map of guard, action, delay implementations
        __publicField(this, "guardMap");
        __publicField(this, "actionMap");
        __publicField(this, "delayMap");
        __publicField(this, "activityMap");
        __publicField(this, "sync");
        __publicField(this, "options");
        __publicField(this, "config");
        __publicField(this, "_created", ()=>{
            const event = toEvent("machine.created" /* Created */ );
            this.executeActions(this.config?.created, event);
        });
        // Starts the interpreted machine.
        __publicField(this, "start", (init)=>{
            this.state.value = "";
            this.state.tags = [];
            if (this.status === "Running" /* Running */ ) {
                return this;
            }
            this.status = "Running" /* Running */ ;
            this.removeStateListener = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["subscribe"])(this.state, ()=>{
                this.stateListeners.forEach((listener)=>{
                    listener(this.stateSnapshot);
                });
            }, this.sync);
            this.setupContextWatchers();
            this.executeActivities(toEvent("machine.start" /* Start */ ), toArray(this.config.activities), "machine.start" /* Start */ );
            this.executeActions(this.config.entry, toEvent("machine.start" /* Start */ ));
            const event = toEvent("machine.init" /* Init */ );
            const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isObject"])(init) ? init.value : init;
            const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isObject"])(init) ? init.context : void 0;
            if (context) {
                this.setContext(context);
            }
            const transition = {
                target: target ?? this.config.initial
            };
            const next = this.getNextStateInfo(transition, event);
            this.initialState = next;
            this.performStateChangeEffects(this.state.value, next, event);
            return this;
        });
        __publicField(this, "setupContextWatchers", ()=>{
            const { watch } = this.config;
            if (!watch) return;
            let prev = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["snapshot"])(this.state.context);
            const cleanup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["subscribe"])(this.state.context, ()=>{
                const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["snapshot"])(this.state.context);
                for (const [key, fn] of Object.entries(watch)){
                    const isEqual = this.options.compareFns?.[key] ?? Object.is;
                    if (isEqual(prev[key], next[key])) continue;
                    this.executeActions(fn, this.state.event);
                }
                prev = next;
            });
            this.contextWatchers.add(cleanup);
        });
        // Stops the interpreted machine
        __publicField(this, "stop", ()=>{
            if (this.status === "Stopped" /* Stopped */ ) return;
            this.performExitEffects(this.state.value, toEvent("machine.stop" /* Stop */ ));
            this.executeActions(this.config.exit, toEvent("machine.stop" /* Stop */ ));
            this.setState("");
            this.setEvent("machine.stop" /* Stop */ );
            this.stopStateListeners();
            this.stopChildren();
            this.stopActivities();
            this.stopDelayedEvents();
            this.stopContextWatchers();
            this.status = "Stopped" /* Stopped */ ;
            return this;
        });
        __publicField(this, "stopStateListeners", ()=>{
            this.removeStateListener();
            this.stateListeners.clear();
        });
        __publicField(this, "stopContextWatchers", ()=>{
            this.contextWatchers.forEach((fn)=>fn());
            this.contextWatchers.clear();
        });
        __publicField(this, "stopDelayedEvents", ()=>{
            this.delayedEvents.forEach((state)=>{
                state.forEach((stop)=>stop());
            });
            this.delayedEvents.clear();
        });
        // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)
        __publicField(this, "stopActivities", (state)=>{
            if (state) {
                this.activityEvents.get(state)?.forEach((stop)=>stop());
                this.activityEvents.get(state)?.clear();
                this.activityEvents.delete(state);
            } else {
                this.activityEvents.forEach((state2)=>{
                    state2.forEach((stop)=>stop());
                    state2.clear();
                });
                this.activityEvents.clear();
            }
        });
        /**
     * Function to send event to spawned child machine or actor
     */ __publicField(this, "sendChild", (evt, to)=>{
            const event = toEvent(evt);
            const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["runIfFn"])(to, this.contextSnapshot);
            const child = this.children.get(id);
            if (!child) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["invariant"])(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);
            }
            child.send(event);
        });
        /**
     * Function to stop a running child machine or actor
     */ __publicField(this, "stopChild", (id)=>{
            if (!this.children.has(id)) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["invariant"])(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);
            }
            this.children.get(id).stop();
            this.children.delete(id);
        });
        __publicField(this, "removeChild", (id)=>{
            this.children.delete(id);
        });
        // Stop and delete spawned actors
        __publicField(this, "stopChildren", ()=>{
            this.children.forEach((child)=>child.stop());
            this.children.clear();
        });
        __publicField(this, "setParent", (parent)=>{
            this.parent = parent;
        });
        __publicField(this, "spawn", (src, id)=>{
            const actor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["runIfFn"])(src);
            if (id) actor.id = id;
            actor.type = "machine.actor" /* Actor */ ;
            actor.setParent(this);
            this.children.set(actor.id, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cast"])(actor));
            actor.onDone(()=>{
                this.removeChild(actor.id);
            }).start();
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cast"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(actor));
        });
        __publicField(this, "stopActivity", (key)=>{
            if (!this.state.value) return;
            const cleanups = this.activityEvents.get(this.state.value);
            cleanups?.get(key)?.();
            cleanups?.delete(key);
        });
        __publicField(this, "addActivityCleanup", (state, key, cleanup)=>{
            if (!state) return;
            if (!this.activityEvents.has(state)) {
                this.activityEvents.set(state, /* @__PURE__ */ new Map([
                    [
                        key,
                        cleanup
                    ]
                ]));
            } else {
                this.activityEvents.get(state)?.set(key, cleanup);
            }
        });
        __publicField(this, "setState", (target)=>{
            this.state.previousValue = this.state.value;
            this.state.value = target;
            const stateNode = this.getStateNode(target);
            if (target == null) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clear"])(this.state.tags);
            } else {
                this.state.tags = toArray(stateNode?.tags);
            }
        });
        /**
     * To used within side effects for React or Vue to update context
     */ __publicField(this, "setContext", (context)=>{
            if (!context) return;
            deepMerge(this.state.context, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(context));
        });
        __publicField(this, "setOptions", (options)=>{
            const opts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(options);
            this.actionMap = {
                ...this.actionMap,
                ...opts.actions
            };
            this.delayMap = {
                ...this.delayMap,
                ...opts.delays
            };
            this.activityMap = {
                ...this.activityMap,
                ...opts.activities
            };
            this.guardMap = {
                ...this.guardMap,
                ...opts.guards
            };
        });
        __publicField(this, "getStateNode", (state)=>{
            if (!state) return;
            return this.config.states?.[state];
        });
        __publicField(this, "getNextStateInfo", (transitions, event)=>{
            const transition = this.determineTransition(transitions, event);
            const isTargetless = !transition?.target;
            const target = transition?.target ?? this.state.value;
            const changed = this.state.value !== target;
            const stateNode = this.getStateNode(target);
            const reenter = !isTargetless && !changed && !transition?.internal;
            const info = {
                reenter,
                transition,
                stateNode,
                target,
                changed
            };
            this.log("NextState:", `[${event.type}]`, this.state.value, "---->", info.target);
            return info;
        });
        __publicField(this, "getAfterActions", (transition, delay)=>{
            let id;
            const current = this.state.value;
            return {
                entry: ()=>{
                    id = globalThis.setTimeout(()=>{
                        const next = this.getNextStateInfo(transition, this.state.event);
                        this.performStateChangeEffects(current, next, this.state.event);
                    }, delay);
                },
                exit: ()=>{
                    globalThis.clearTimeout(id);
                }
            };
        });
        /**
     * All `after` events leverage `setTimeout` and `clearTimeout`,
     * we invoke the `clearTimeout` on exit and `setTimeout` on entry.
     *
     * To achieve this, we split the `after` defintion into `entry` and `exit`
     *  functions and append them to the state's `entry` and `exit` actions
     */ __publicField(this, "getDelayedEventActions", (state)=>{
            const stateNode = this.getStateNode(state);
            const event = this.state.event;
            if (!stateNode || !stateNode.after) return;
            const entries = [];
            const exits = [];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isArray"])(stateNode.after)) {
                const transition = this.determineTransition(stateNode.after, event);
                if (!transition) return;
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["hasProp"])(transition, "delay")) {
                    throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);
                }
                const determineDelay = determineDelayFn(transition.delay, this.delayMap);
                const __delay = determineDelay(this.contextSnapshot, event);
                const actions = this.getAfterActions(transition, __delay);
                entries.push(actions.entry);
                exits.push(actions.exit);
                return {
                    entries,
                    exits
                };
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isObject"])(stateNode.after)) {
                for(const delay in stateNode.after){
                    const transition = stateNode.after[delay];
                    const determineDelay = determineDelayFn(delay, this.delayMap);
                    const __delay = determineDelay(this.contextSnapshot, event);
                    const actions = this.getAfterActions(transition, __delay);
                    entries.push(actions.entry);
                    exits.push(actions.exit);
                }
            }
            return {
                entries,
                exits
            };
        });
        /**
     * Function to executes defined actions. It can accept actions as string
     * (referencing `options.actions`) or actual functions.
     */ __publicField(this, "executeActions", (actions, event)=>{
            const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
            for (const action of toArray(pickedActions)){
                const fn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(action) ? this.actionMap?.[action] : action;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["warn"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(action) && !fn, `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``);
                fn?.(this.state.context, event, this.meta);
            }
        });
        /**
     * Function to execute running activities and registers
     * their cleanup function internally (to be called later on when we exit the state)
     */ __publicField(this, "executeActivities", (event, activities, state)=>{
            for (const activity of activities){
                const fn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(activity) ? this.activityMap?.[activity] : activity;
                if (!fn) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["warn"])(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
                    continue;
                }
                const cleanup = fn(this.state.context, event, this.meta);
                if (cleanup) {
                    const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(activity) ? activity : activity.name || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["uuid"])();
                    this.addActivityCleanup(state ?? this.state.value, key, cleanup);
                }
            }
        });
        /**
     * Normalizes the `every` definition to transition. `every` can be:
     * - An array of possible actions to run (we need to pick the first match based on guard)
     * - An object of intervals and actions
     */ __publicField(this, "createEveryActivities", (every, callbackfn)=>{
            if (!every) return;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isArray"])(every)) {
                const picked = toArray(every).find((transition)=>{
                    const delayOrFn = transition.delay;
                    const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
                    const delay2 = determineDelay2(this.contextSnapshot, this.state.event);
                    const determineGuard = determineGuardFn(transition.guard, this.guardMap);
                    const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);
                    return guard ?? delay2 != null;
                });
                if (!picked) return;
                const determineDelay = determineDelayFn(picked.delay, this.delayMap);
                const delay = determineDelay(this.contextSnapshot, this.state.event);
                const activity = ()=>{
                    const id = globalThis.setInterval(()=>{
                        this.executeActions(picked.actions, this.state.event);
                    }, delay);
                    return ()=>{
                        globalThis.clearInterval(id);
                    };
                };
                callbackfn(activity);
            } else {
                for(const interval in every){
                    const actions = every?.[interval];
                    const determineDelay = determineDelayFn(interval, this.delayMap);
                    const delay = determineDelay(this.contextSnapshot, this.state.event);
                    const activity = ()=>{
                        const id = globalThis.setInterval(()=>{
                            this.executeActions(actions, this.state.event);
                        }, delay);
                        return ()=>{
                            globalThis.clearInterval(id);
                        };
                    };
                    callbackfn(activity);
                }
            }
        });
        __publicField(this, "setEvent", (event)=>{
            this.state.previousEvent = this.state.event;
            this.state.event = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(toEvent(event));
        });
        __publicField(this, "performExitEffects", (current, event)=>{
            const currentState = this.state.value;
            if (currentState === "") return;
            const stateNode = current ? this.getStateNode(current) : void 0;
            this.stopActivities(currentState);
            const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
            const exitActions = toArray(_exit);
            const afterExitActions = this.delayedEvents.get(currentState);
            if (afterExitActions) {
                exitActions.push(...afterExitActions);
            }
            this.executeActions(exitActions, event);
            this.delayedEvents.delete(currentState);
        });
        __publicField(this, "performEntryEffects", (next, event)=>{
            const stateNode = this.getStateNode(next);
            const activities = toArray(stateNode?.activities);
            this.createEveryActivities(stateNode?.every, (activity)=>{
                activities.unshift(activity);
            });
            if (activities.length > 0) {
                this.executeActivities(event, activities);
            }
            const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
            const entryActions = toArray(pickedActions);
            const afterActions = this.getDelayedEventActions(next);
            if (stateNode?.after && afterActions) {
                this.delayedEvents.set(next, afterActions?.exits);
                entryActions.push(...afterActions.entries);
            }
            this.executeActions(entryActions, event);
            if (stateNode?.type === "final") {
                this.state.done = true;
                this.doneListeners.forEach((listener)=>{
                    listener(this.stateSnapshot);
                });
                this.stop();
            }
        });
        __publicField(this, "performTransitionEffects", (transitions, event)=>{
            const transition = this.determineTransition(transitions, event);
            this.executeActions(transition?.actions, event);
        });
        /**
     * Performs all the requires side-effects or reactions when
     * we move from state A => state B.
     *
     * The Effect order:
     * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)
     */ __publicField(this, "performStateChangeEffects", (current, next, event)=>{
            this.setEvent(event);
            const changed = next.changed || next.reenter;
            if (changed) {
                this.performExitEffects(current, event);
            }
            this.performTransitionEffects(next.transition, event);
            this.setState(next.target);
            if (changed) {
                this.performEntryEffects(next.target, event);
            }
        });
        __publicField(this, "determineTransition", (transition, event)=>{
            const fn = determineTransitionFn(transition, this.guardMap);
            return fn?.(this.contextSnapshot, event, this.guardMeta);
        });
        /**
     * Function to send event to parent machine from spawned child
     */ __publicField(this, "sendParent", (evt)=>{
            if (!this.parent) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["invariant"])("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
            }
            const event = toEvent(evt);
            this.parent?.send(event);
        });
        __publicField(this, "log", (...args)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isDev"])() && this.options.debug) {
                console.log(...args);
            }
        });
        /**
     * Function to send an event to current machine
     */ __publicField(this, "send", (evt)=>{
            const event = toEvent(evt);
            this.transition(this.state.value, event);
        });
        __publicField(this, "transition", (state, evt)=>{
            const stateNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(state) ? this.getStateNode(state) : state?.stateNode;
            const event = toEvent(evt);
            if (!stateNode && !this.config.on) {
                const msg = this.status === "Stopped" /* Stopped */  ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state}, \`event\`: ${event.type}`;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["warn"])(msg);
                return;
            }
            const transitions = // @ts-expect-error - Fix this
            stateNode?.on?.[event.type] ?? this.config.on?.[event.type];
            const next = this.getNextStateInfo(transitions, event);
            this.performStateChangeEffects(this.state.value, next, event);
            return next.stateNode;
        });
        __publicField(this, "subscribe", (listener)=>{
            this.stateListeners.add(listener);
            if (this.status === "Running" /* Running */ ) {
                listener(this.stateSnapshot);
            }
            return ()=>{
                this.stateListeners.delete(listener);
            };
        });
        __publicField(this, "onDone", (listener)=>{
            this.doneListeners.add(listener);
            return this;
        });
        __publicField(this, "onTransition", (listener)=>{
            this.stateListeners.add(listener);
            if (this.status === "Running" /* Running */ ) {
                listener(this.stateSnapshot);
            }
            return this;
        });
        this.config = structuredClone(config);
        this.options = structuredClone(options ?? {});
        this.id = this.config.id ?? `machine-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["uuid"])()}`;
        this.guardMap = this.options?.guards ?? {};
        this.actionMap = this.options?.actions ?? {};
        this.delayMap = this.options?.delays ?? {};
        this.activityMap = this.options?.activities ?? {};
        this.sync = this.options?.sync ?? false;
        this.state = createProxy(this.config);
        this.initialContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["snapshot"])(this.state.context);
    }
    // immutable state value
    get stateSnapshot() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cast"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["snapshot"])(this.state));
    }
    getState() {
        return this.stateSnapshot;
    }
    // immutable context value
    get contextSnapshot() {
        return this.stateSnapshot.context;
    }
    /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */ get self() {
        const self = this;
        return {
            id: this.id,
            send: this.send.bind(this),
            sendParent: this.sendParent.bind(this),
            sendChild: this.sendChild.bind(this),
            stop: this.stop.bind(this),
            stopChild: this.stopChild.bind(this),
            spawn: this.spawn.bind(this),
            stopActivity: this.stopActivity.bind(this),
            get state () {
                return self.stateSnapshot;
            },
            get initialContext () {
                return self.initialContext;
            },
            get initialState () {
                return self.initialState?.target ?? "";
            }
        };
    }
    get meta() {
        return {
            state: this.stateSnapshot,
            guards: this.guardMap,
            send: this.send.bind(this),
            self: this.self,
            initialContext: this.initialContext,
            initialState: this.initialState?.target ?? "",
            getState: ()=>this.stateSnapshot,
            getAction: (key)=>this.actionMap[key],
            getGuard: (key)=>this.guardMap[key]
        };
    }
    get guardMeta() {
        return {
            state: this.stateSnapshot
        };
    }
    get [Symbol.toStringTag]() {
        return "Machine";
    }
    getHydrationState() {
        const state = this.getState();
        return {
            value: state.value,
            tags: state.tags
        };
    }
};
var createMachine = (config, options)=>new Machine(config, options);
var isMachine = (value)=>{
    return value instanceof Machine || value?.type === "machine" /* Machine */ ;
};
var clsx = (...args)=>args.map((str)=>str?.trim?.()).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style)=>{
    const res = {};
    let match;
    while(match = CSS_REGEX.exec(style)){
        res[match[1]] = match[2];
    }
    return res;
};
var css = (a, b)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(a)) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(b)) return `${a};${b}`;
        a = serialize(a);
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(b)) {
        b = serialize(b);
    }
    return Object.assign({}, a ?? {}, b ?? {});
};
function mergeProps(...args) {
    let result = {};
    for (let props of args){
        for(let key in result){
            if (key.startsWith("on") && typeof result[key] === "function" && typeof props[key] === "function") {
                result[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["callAll"])(props[key], result[key]);
                continue;
            }
            if (key === "className" || key === "class") {
                result[key] = clsx(result[key], props[key]);
                continue;
            }
            if (key === "style") {
                result[key] = css(result[key], props[key]);
                continue;
            }
            result[key] = props[key] !== void 0 ? props[key] : result[key];
        }
        for(let key in props){
            if (result[key] === void 0) {
                result[key] = props[key];
            }
        }
    }
    return result;
}
;
}}),
"[project]/node_modules/@zag-js/accordion/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "itemProps": (()=>itemProps),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitItemProps": (()=>splitItemProps),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
;
;
;
;
;
;
// src/accordion.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `accordion:${ctx.id}`,
    getItemId: (ctx, value)=>ctx.ids?.item?.(value) ?? `accordion:${ctx.id}:item:${value}`,
    getItemContentId: (ctx, value)=>ctx.ids?.itemContent?.(value) ?? `accordion:${ctx.id}:content:${value}`,
    getItemTriggerId: (ctx, value)=>ctx.ids?.itemTrigger?.(value) ?? `accordion:${ctx.id}:trigger:${value}`,
    getRootEl: (ctx)=>dom.getById(ctx, dom.getRootId(ctx)),
    getTriggerEls: (ctx)=>{
        const ownerId = CSS.escape(dom.getRootId(ctx));
        const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["queryAll"])(dom.getRootEl(ctx), selector);
    },
    getFirstTriggerEl: (ctx)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["first"])(dom.getTriggerEls(ctx)),
    getLastTriggerEl: (ctx)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["last"])(dom.getTriggerEls(ctx)),
    getNextTriggerEl: (ctx, id)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nextById"])(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id)),
    getPrevTriggerEl: (ctx, id)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["prevById"])(dom.getTriggerEls(ctx), dom.getItemTriggerId(ctx, id))
});
// src/accordion.connect.ts
function connect(state, send, normalize) {
    const focusedValue = state.context.focusedValue;
    const value = state.context.value;
    const multiple = state.context.multiple;
    function setValue(value2) {
        let nextValue = value2;
        if (multiple && nextValue.length > 1) {
            nextValue = [
                nextValue[0]
            ];
        }
        send({
            type: "VALUE.SET",
            value: nextValue
        });
    }
    function getItemState(props2) {
        return {
            expanded: value.includes(props2.value),
            focused: focusedValue === props2.value,
            disabled: Boolean(props2.disabled ?? state.context.disabled)
        };
    }
    return {
        focusedValue,
        value,
        setValue,
        getItemState,
        getRootProps () {
            return normalize.element({
                ...parts.root.attrs,
                dir: state.context.dir,
                id: dom.getRootId(state.context),
                "data-orientation": state.context.orientation
            });
        },
        getItemProps (props2) {
            const itemState = getItemState(props2);
            return normalize.element({
                ...parts.item.attrs,
                dir: state.context.dir,
                id: dom.getItemId(state.context, props2.value),
                "data-state": itemState.expanded ? "open" : "closed",
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.focused),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
                "data-orientation": state.context.orientation
            });
        },
        getItemContentProps (props2) {
            const itemState = getItemState(props2);
            return normalize.element({
                ...parts.itemContent.attrs,
                dir: state.context.dir,
                role: "region",
                id: dom.getItemContentId(state.context, props2.value),
                "aria-labelledby": dom.getItemTriggerId(state.context, props2.value),
                hidden: !itemState.expanded,
                "data-state": itemState.expanded ? "open" : "closed",
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.focused),
                "data-orientation": state.context.orientation
            });
        },
        getItemIndicatorProps (props2) {
            const itemState = getItemState(props2);
            return normalize.element({
                ...parts.itemIndicator.attrs,
                dir: state.context.dir,
                "aria-hidden": true,
                "data-state": itemState.expanded ? "open" : "closed",
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.focused),
                "data-orientation": state.context.orientation
            });
        },
        getItemTriggerProps (props2) {
            const { value: value2 } = props2;
            const itemState = getItemState(props2);
            return normalize.button({
                ...parts.itemTrigger.attrs,
                type: "button",
                dir: state.context.dir,
                id: dom.getItemTriggerId(state.context, value2),
                "aria-controls": dom.getItemContentId(state.context, value2),
                "aria-expanded": itemState.expanded,
                disabled: itemState.disabled,
                "data-orientation": state.context.orientation,
                "aria-disabled": itemState.disabled,
                "data-state": itemState.expanded ? "open" : "closed",
                "data-ownedby": dom.getRootId(state.context),
                onFocus () {
                    if (itemState.disabled) return;
                    send({
                        type: "TRIGGER.FOCUS",
                        value: value2
                    });
                },
                onBlur () {
                    if (itemState.disabled) return;
                    send("TRIGGER.BLUR");
                },
                onClick (event) {
                    if (itemState.disabled) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isSafari"])()) {
                        event.currentTarget.focus();
                    }
                    send({
                        type: "TRIGGER.CLICK",
                        value: value2
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (itemState.disabled) return;
                    const keyMap = {
                        ArrowDown () {
                            if (state.context.isHorizontal) return;
                            send({
                                type: "GOTO.NEXT",
                                value: value2
                            });
                        },
                        ArrowUp () {
                            if (state.context.isHorizontal) return;
                            send({
                                type: "GOTO.PREV",
                                value: value2
                            });
                        },
                        ArrowRight () {
                            if (!state.context.isHorizontal) return;
                            send({
                                type: "GOTO.NEXT",
                                value: value2
                            });
                        },
                        ArrowLeft () {
                            if (!state.context.isHorizontal) return;
                            send({
                                type: "GOTO.PREV",
                                value: value2
                            });
                        },
                        Home () {
                            send({
                                type: "GOTO.FIRST",
                                value: value2
                            });
                        },
                        End () {
                            send({
                                type: "GOTO.LAST",
                                value: value2
                            });
                        }
                    };
                    const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventKey"])(event, {
                        dir: state.context.dir,
                        orientation: state.context.orientation
                    });
                    const exec = keyMap[key];
                    if (exec) {
                        exec(event);
                        event.preventDefault();
                    }
                }
            });
        }
    };
}
var { and, not } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guards"];
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "accordion",
        initial: "idle",
        context: {
            focusedValue: null,
            value: [],
            collapsible: false,
            multiple: false,
            orientation: "vertical",
            ...ctx
        },
        watch: {
            value: "coarseValue",
            multiple: "coarseValue"
        },
        created: "coarseValue",
        computed: {
            isHorizontal: (ctx2)=>ctx2.orientation === "horizontal"
        },
        on: {
            "VALUE.SET": {
                actions: [
                    "setValue"
                ]
            }
        },
        states: {
            idle: {
                on: {
                    "TRIGGER.FOCUS": {
                        target: "focused",
                        actions: "setFocusedValue"
                    }
                }
            },
            focused: {
                on: {
                    "GOTO.NEXT": {
                        actions: "focusNextTrigger"
                    },
                    "GOTO.PREV": {
                        actions: "focusPrevTrigger"
                    },
                    "TRIGGER.CLICK": [
                        {
                            guard: and("isExpanded", "canToggle"),
                            actions: [
                                "collapse"
                            ]
                        },
                        {
                            guard: not("isExpanded"),
                            actions: [
                                "expand"
                            ]
                        }
                    ],
                    "GOTO.FIRST": {
                        actions: "focusFirstTrigger"
                    },
                    "GOTO.LAST": {
                        actions: "focusLastTrigger"
                    },
                    "TRIGGER.BLUR": {
                        target: "idle",
                        actions: "clearFocusedValue"
                    }
                }
            }
        }
    }, {
        guards: {
            canToggle: (ctx2)=>!!ctx2.collapsible || !!ctx2.multiple,
            isExpanded: (ctx2, evt)=>ctx2.value.includes(evt.value)
        },
        actions: {
            collapse (ctx2, evt) {
                const next = ctx2.multiple ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["remove"])(ctx2.value, evt.value) : [];
                set.value(ctx2, ctx2.multiple ? next : []);
            },
            expand (ctx2, evt) {
                const next = ctx2.multiple ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["add"])(ctx2.value, evt.value) : [
                    evt.value
                ];
                set.value(ctx2, next);
            },
            focusFirstTrigger (ctx2) {
                dom.getFirstTriggerEl(ctx2)?.focus();
            },
            focusLastTrigger (ctx2) {
                dom.getLastTriggerEl(ctx2)?.focus();
            },
            focusNextTrigger (ctx2) {
                if (!ctx2.focusedValue) return;
                const triggerEl = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);
                triggerEl?.focus();
            },
            focusPrevTrigger (ctx2) {
                if (!ctx2.focusedValue) return;
                const triggerEl = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);
                triggerEl?.focus();
            },
            setFocusedValue (ctx2, evt) {
                set.focusedValue(ctx2, evt.value);
            },
            clearFocusedValue (ctx2) {
                set.focusedValue(ctx2, null);
            },
            setValue (ctx2, evt) {
                set.value(ctx2, evt.value);
            },
            coarseValue (ctx2) {
                if (!ctx2.multiple && ctx2.value.length > 1) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["warn"])(`The value of accordion should be a single value when multiple is false.`);
                    ctx2.value = [
                        ctx2.value[0]
                    ];
                }
            }
        }
    });
}
var invoke = {
    change (ctx) {
        ctx.onValueChange?.({
            value: Array.from(ctx.value)
        });
    },
    focusChange (ctx) {
        ctx.onFocusChange?.({
            value: ctx.focusedValue
        });
    }
};
var set = {
    value (ctx, value) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value, value)) return;
        ctx.value = value;
        invoke.change(ctx);
    },
    focusedValue (ctx, value) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.focusedValue, value)) return;
        ctx.focusedValue = value;
        invoke.focusChange(ctx);
    }
};
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "collapsible",
    "dir",
    "disabled",
    "getRootNode",
    "id",
    "ids",
    "multiple",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "value"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
var itemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "value",
    "disabled"
]);
var splitItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(itemProps);
;
}}),
"[project]/node_modules/@zag-js/accordion/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as accordionAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "accordionAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$accordion$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$accordion$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/accordion/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/interact-outside/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "trackInteractOutside": (()=>trackInteractOutside)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
// src/index.ts
// src/frame-utils.ts
function getWindowFrames(win) {
    const frames = {
        each (cb) {
            for(let i = 0; i < win.frames?.length; i += 1){
                const frame = win.frames[i];
                if (frame) cb(frame);
            }
        },
        addEventListener (event, listener, options) {
            frames.each((frame)=>{
                try {
                    frame.document.addEventListener(event, listener, options);
                } catch  {}
            });
            return ()=>{
                try {
                    frames.removeEventListener(event, listener, options);
                } catch  {}
            };
        },
        removeEventListener (event, listener, options) {
            frames.each((frame)=>{
                try {
                    frame.document.removeEventListener(event, listener, options);
                } catch  {}
            });
        }
    };
    return frames;
}
function getParentWindow(win) {
    const parent = win.frameElement != null ? win.parent : null;
    return {
        addEventListener: (event, listener, options)=>{
            try {
                parent?.addEventListener(event, listener, options);
            } catch  {}
            return ()=>{
                try {
                    parent?.removeEventListener(event, listener, options);
                } catch  {}
            };
        },
        removeEventListener: (event, listener, options)=>{
            try {
                parent?.removeEventListener(event, listener, options);
            } catch  {}
        }
    };
}
// src/index.ts
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
    for (const node of composedPath){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(node) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFocusable"])(node)) return true;
    }
    return false;
}
var isPointerEvent = (event)=>"clientY" in event;
function isEventPointWithin(node, event) {
    if (!isPointerEvent(event) || !node) return false;
    const rect = node.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return false;
    return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isEventWithinScrollbar(event, target) {
    if (!target || !isPointerEvent(event)) return false;
    const isScrollableY = target.scrollHeight > target.clientHeight;
    const onScrollbarY = isScrollableY && event.clientX > target.clientWidth;
    const isScrollableX = target.scrollWidth > target.clientWidth;
    const onScrollbarX = isScrollableX && event.clientY > target.clientHeight;
    return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node, options) {
    const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
    if (!node) return;
    const doc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocument"])(node);
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(node);
    const frames = getWindowFrames(win);
    const parentWin = getParentWindow(win);
    function isEventOutside(event) {
        const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(target)) return false;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["contains"])(node, target)) return false;
        if (isEventPointWithin(node, event)) return false;
        if (isEventWithinScrollbar(event, target)) return false;
        const scrollParent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNearestOverflowAncestor"])(node);
        if (isEventWithinScrollbar(event, scrollParent)) return false;
        return !exclude?.(target);
    }
    const pointerdownCleanups = /* @__PURE__ */ new Set();
    function onPointerDown(event) {
        function handler() {
            const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
            const composedPath = event.composedPath?.() ?? [
                event.target
            ];
            func(()=>{
                if (!node || !isEventOutside(event)) return;
                if (onPointerDownOutside || onInteractOutside) {
                    const handler2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["callAll"])(onPointerDownOutside, onInteractOutside);
                    node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, {
                        once: true
                    });
                }
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fireCustomEvent"])(node, POINTER_OUTSIDE_EVENT, {
                    bubbles: false,
                    cancelable: true,
                    detail: {
                        originalEvent: event,
                        contextmenu: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isContextMenuEvent"])(event),
                        focusable: isComposedPathFocusable(composedPath)
                    }
                });
            });
        }
        if (event.pointerType === "touch") {
            pointerdownCleanups.forEach((fn)=>fn());
            pointerdownCleanups.add((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])(doc, "click", handler, {
                once: true
            }));
            pointerdownCleanups.add(parentWin.addEventListener("click", handler, {
                once: true
            }));
            pointerdownCleanups.add(frames.addEventListener("click", handler, {
                once: true
            }));
        } else {
            handler();
        }
    }
    const cleanups = /* @__PURE__ */ new Set();
    const timer = setTimeout(()=>{
        cleanups.add((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])(doc, "pointerdown", onPointerDown, true));
        cleanups.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
        cleanups.add(frames.addEventListener("pointerdown", onPointerDown, true));
    }, 0);
    function onFocusin(event) {
        const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
        func(()=>{
            if (!node || !isEventOutside(event)) return;
            if (onFocusOutside || onInteractOutside) {
                const handler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["callAll"])(onFocusOutside, onInteractOutside);
                node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, {
                    once: true
                });
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fireCustomEvent"])(node, FOCUS_OUTSIDE_EVENT, {
                bubbles: false,
                cancelable: true,
                detail: {
                    originalEvent: event,
                    contextmenu: false,
                    focusable: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFocusable"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(event))
                }
            });
        });
    }
    cleanups.add((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])(doc, "focusin", onFocusin, true));
    cleanups.add(parentWin.addEventListener("focusin", onFocusin, true));
    cleanups.add(frames.addEventListener("focusin", onFocusin, true));
    return ()=>{
        clearTimeout(timer);
        pointerdownCleanups.forEach((fn)=>fn());
        cleanups.forEach((fn)=>fn());
    };
}
function trackInteractOutside(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
        cleanups.push(trackInteractOutsideImpl(node, options));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn?.());
    };
}
;
}}),
"[project]/node_modules/@zag-js/dismissable/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "trackDismissableBranch": (()=>trackDismissableBranch),
    "trackDismissableElement": (()=>trackDismissableElement)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$interact$2d$outside$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/interact-outside/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
// src/dismissable-layer.ts
function trackEscapeKeydown(node, fn) {
    const handleKeyDown = (event)=>{
        if (event.key !== "Escape") return;
        if (event.isComposing) return;
        fn?.(event);
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocument"])(node), "keydown", handleKeyDown, {
        capture: true
    });
}
var layerStack = {
    layers: [],
    branches: [],
    count () {
        return this.layers.length;
    },
    pointerBlockingLayers () {
        return this.layers.filter((layer)=>layer.pointerBlocking);
    },
    topMostPointerBlockingLayer () {
        return [
            ...this.pointerBlockingLayers()
        ].slice(-1)[0];
    },
    hasPointerBlockingLayer () {
        return this.pointerBlockingLayers().length > 0;
    },
    isBelowPointerBlockingLayer (node) {
        const index = this.indexOf(node);
        const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf(this.topMostPointerBlockingLayer()?.node) : -1;
        return index < highestBlockingIndex;
    },
    isTopMost (node) {
        const layer = this.layers[this.count() - 1];
        return layer?.node === node;
    },
    getNestedLayers (node) {
        return Array.from(this.layers).slice(this.indexOf(node) + 1);
    },
    isInNestedLayer (node, target) {
        return this.getNestedLayers(node).some((layer)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["contains"])(layer.node, target));
    },
    isInBranch (target) {
        return Array.from(this.branches).some((branch)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["contains"])(branch, target));
    },
    add (layer) {
        const num = this.layers.push(layer);
        layer.node.style.setProperty("--layer-index", `${num}`);
    },
    addBranch (node) {
        this.branches.push(node);
    },
    remove (node) {
        const index = this.indexOf(node);
        if (index < 0) return;
        if (index < this.count() - 1) {
            const _layers = this.getNestedLayers(node);
            _layers.forEach((layer)=>layer.dismiss());
        }
        this.layers.splice(index, 1);
        node.style.removeProperty("--layer-index");
    },
    removeBranch (node) {
        const index = this.branches.indexOf(node);
        if (index >= 0) this.branches.splice(index, 1);
    },
    indexOf (node) {
        return this.layers.findIndex((layer)=>layer.node === node);
    },
    dismiss (node) {
        this.layers[this.indexOf(node)]?.dismiss();
    },
    clear () {
        this.remove(this.layers[0].node);
    }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
    layerStack.layers.forEach(({ node })=>{
        node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? "none" : "auto";
    });
}
function clearPointerEvent(node) {
    node.style.pointerEvents = "";
}
function disablePointerEventsOutside(node, peristentElements) {
    const doc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocument"])(node);
    const cleanups = [];
    if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
        originalBodyPointerEvents = document.body.style.pointerEvents;
        queueMicrotask(()=>{
            doc.body.style.pointerEvents = "none";
            doc.body.setAttribute("data-inert", "");
        });
    }
    if (peristentElements) {
        const persistedCleanup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["waitForElements"])(peristentElements, (el)=>{
            cleanups.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["setStyle"])(el, {
                pointerEvents: "auto"
            }));
        });
        cleanups.push(persistedCleanup);
    }
    return ()=>{
        if (layerStack.hasPointerBlockingLayer()) return;
        queueMicrotask(()=>{
            doc.body.style.pointerEvents = originalBodyPointerEvents;
            doc.body.removeAttribute("data-inert");
            if (doc.body.style.length === 0) doc.body.removeAttribute("style");
        });
        cleanups.forEach((fn)=>fn());
    };
}
// src/dismissable-layer.ts
function trackDismissableElementImpl(node, options) {
    if (!node) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["warn"])("[@zag-js/dismissable] node is `null` or `undefined`");
        return;
    }
    const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
    const layer = {
        dismiss: onDismiss,
        node,
        pointerBlocking
    };
    layerStack.add(layer);
    assignPointerEventToLayers();
    function onPointerDownOutside(event) {
        const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(event.detail.originalEvent);
        if (layerStack.isBelowPointerBlockingLayer(node) || layerStack.isInBranch(target)) return;
        options.onPointerDownOutside?.(event);
        options.onInteractOutside?.(event);
        if (event.defaultPrevented) return;
        if (debug) {
            console.log("onPointerDownOutside:", event.detail.originalEvent);
        }
        onDismiss?.();
    }
    function onFocusOutside(event) {
        const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(event.detail.originalEvent);
        if (layerStack.isInBranch(target)) return;
        options.onFocusOutside?.(event);
        options.onInteractOutside?.(event);
        if (event.defaultPrevented) return;
        if (debug) {
            console.log("onFocusOutside:", event.detail.originalEvent);
        }
        onDismiss?.();
    }
    function onEscapeKeyDown(event) {
        if (!layerStack.isTopMost(node)) return;
        options.onEscapeKeyDown?.(event);
        if (!event.defaultPrevented && onDismiss) {
            event.preventDefault();
            onDismiss();
        }
    }
    function exclude(target) {
        if (!node) return false;
        const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
        const _containers = Array.isArray(containers) ? containers : [
            containers
        ];
        const persistentElements = options.persistentElements?.map((fn)=>fn()).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"]);
        if (persistentElements) _containers.push(...persistentElements);
        return _containers.some((node2)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["contains"])(node2, target)) || layerStack.isInNestedLayer(node, target);
    }
    const cleanups = [
        pointerBlocking ? disablePointerEventsOutside(node, options.persistentElements) : void 0,
        trackEscapeKeydown(node, onEscapeKeyDown),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$interact$2d$outside$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackInteractOutside"])(node, {
            exclude,
            onFocusOutside,
            onPointerDownOutside,
            defer: options.defer
        })
    ];
    return ()=>{
        layerStack.remove(node);
        assignPointerEventToLayers();
        clearPointerEvent(node);
        cleanups.forEach((fn)=>fn?.());
    };
}
function trackDismissableElement(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFunction"])(nodeOrFn) ? nodeOrFn() : nodeOrFn;
        cleanups.push(trackDismissableElementImpl(node, options));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn?.());
    };
}
function trackDismissableBranch(nodeOrFn, options = {}) {
    const { defer } = options;
    const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFunction"])(nodeOrFn) ? nodeOrFn() : nodeOrFn;
        if (!node) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["warn"])("[@zag-js/dismissable] branch node is `null` or `undefined`");
            return;
        }
        layerStack.addBranch(node);
        cleanups.push(()=>{
            layerStack.removeBranch(node);
        });
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn?.());
    };
}
;
}}),
"[project]/node_modules/@zag-js/remove-scroll/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "preventBodyScroll": (()=>preventBodyScroll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
;
// src/index.ts
var LOCK_CLASSNAME = "data-scroll-lock";
function assignStyle(el, style) {
    if (!el) return;
    const previousStyle = Object.keys(style).reduce((acc, key)=>{
        acc[key] = el.style.getPropertyValue(key);
        return acc;
    }, {});
    Object.assign(el.style, style);
    return ()=>{
        Object.assign(el.style, previousStyle);
    };
}
function setCSSProperty(el, property, value) {
    if (!el) return;
    const previousValue = el.style.getPropertyValue(property);
    el.style.setProperty(property, value);
    return ()=>{
        if (previousValue) {
            el.style.setProperty(property, previousValue);
        } else {
            el.style.removeProperty(property);
        }
    };
}
function getPaddingProperty(documentElement) {
    const documentLeft = documentElement.getBoundingClientRect().left;
    const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
    return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
    const doc = _document ?? document;
    const win = doc.defaultView ?? window;
    const { documentElement, body } = doc;
    const locked = body.hasAttribute(LOCK_CLASSNAME);
    if (locked) return;
    body.setAttribute(LOCK_CLASSNAME, "");
    const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
    const setScrollbarWidthProperty = ()=>setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
    const paddingProperty = getPaddingProperty(documentElement);
    const setStyle = ()=>assignStyle(body, {
            overflow: "hidden",
            [paddingProperty]: `${scrollbarWidth}px`
        });
    const setIOSStyle = ()=>{
        const { scrollX, scrollY, visualViewport } = win;
        const offsetLeft = visualViewport?.offsetLeft ?? 0;
        const offsetTop = visualViewport?.offsetTop ?? 0;
        const restoreStyle = assignStyle(body, {
            position: "fixed",
            overflow: "hidden",
            top: `${-(scrollY - Math.floor(offsetTop))}px`,
            left: `${-(scrollX - Math.floor(offsetLeft))}px`,
            right: "0",
            [paddingProperty]: `${scrollbarWidth}px`
        });
        return ()=>{
            restoreStyle?.();
            win.scrollTo({
                left: scrollX,
                top: scrollY,
                behavior: "instant"
            });
        };
    };
    const cleanups = [
        setScrollbarWidthProperty(),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isIos"])() ? setIOSStyle() : setStyle()
    ];
    return ()=>{
        cleanups.forEach((fn)=>fn?.());
        body.removeAttribute(LOCK_CLASSNAME);
    };
}
;
}}),
"[project]/node_modules/tabbable/dist/index.esm.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/ // NOTE: separate `:not()` selectors has broader browser support than the newer
//  `:not([inert], [inert] *)` (Feb 2023)
// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes
//  the entire query to fail, resulting in no nodes found, which will break a lot
//  of things... so we have to rely on JS to identify nodes inside an inert container
__turbopack_esm__({
    "focusable": (()=>focusable),
    "getTabIndex": (()=>getTabIndex),
    "isFocusable": (()=>isFocusable),
    "isTabbable": (()=>isTabbable),
    "tabbable": (()=>tabbable)
});
var candidateSelectors = [
    'input:not([inert])',
    'select:not([inert])',
    'textarea:not([inert])',
    'a[href]:not([inert])',
    'button:not([inert])',
    '[tabindex]:not(slot):not([inert])',
    'audio[controls]:not([inert])',
    'video[controls]:not([inert])',
    '[contenteditable]:not([contenteditable="false"]):not([inert])',
    'details>summary:first-of-type:not([inert])',
    'details:not([inert])'
];
var candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');
var NoElement = typeof Element === 'undefined';
var matches = NoElement ? function() {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    var _element$getRootNode;
    return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
    return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
/**
 * Determines if a node is inert or in an inert ancestor.
 * @param {Element} [node]
 * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to
 *  see if any of them are inert. If false, only `node` itself is considered.
 * @returns {boolean} True if inert itself or by way of being in an inert ancestor.
 *  False if `node` is falsy.
 */ var isInert = function isInert(node, lookUp) {
    var _node$getAttribute;
    if (lookUp === void 0) {
        lookUp = true;
    }
    // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`
    //  JS API property; we have to check the attribute, which can either be empty or 'true';
    //  if it's `null` (not specified) or 'false', it's an active element
    var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');
    var inert = inertAtt === '' || inertAtt === 'true';
    // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`
    //  if it weren't for `matches()` not being a function on shadow roots; the following
    //  code works for any kind of node
    // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`
    //  so it likely would not support `:is([inert] *)` either...
    var result = inert || lookUp && node && isInert(node.parentNode); // recursive
    return result;
};
/**
 * Determines if a node's content is editable.
 * @param {Element} [node]
 * @returns True if it's content-editable; false if it's not or `node` is falsy.
 */ var isContentEditable = function isContentEditable(node) {
    var _node$getAttribute2;
    // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have
    //  to use the attribute directly to check for this, which can either be empty or 'true';
    //  if it's `null` (not specified) or 'false', it's a non-editable element
    var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');
    return attValue === '' || attValue === 'true';
};
/**
 * @param {Element} el container to check in
 * @param {boolean} includeContainer add container to check
 * @param {(node: Element) => boolean} filter filter candidates
 * @returns {Element[]}
 */ var getCandidates = function getCandidates(el, includeContainer, filter) {
    // even if `includeContainer=false`, we still have to check it for inertness because
    //  if it's inert, all its children are inert
    if (isInert(el)) {
        return [];
    }
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
};
/**
 * @callback GetShadowRoot
 * @param {Element} element to check for shadow root
 * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.
 */ /**
 * @callback ShadowRootFilter
 * @param {Element} shadowHostNode the element which contains shadow content
 * @returns {boolean} true if a shadow root could potentially contain valid candidates.
 */ /**
 * @typedef {Object} CandidateScope
 * @property {Element} scopeParent contains inner candidates
 * @property {Element[]} candidates list of candidates found in the scope parent
 */ /**
 * @typedef {Object} IterativeOptions
 * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;
 *  if a function, implies shadow support is enabled and either returns the shadow root of an element
 *  or a boolean stating if it has an undisclosed shadow root
 * @property {(node: Element) => boolean} filter filter candidates
 * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list
 * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;
 */ /**
 * @param {Element[]} elements list of element containers to match candidates from
 * @param {boolean} includeContainer add container list to check
 * @param {IterativeOptions} options
 * @returns {Array.<Element|CandidateScope>}
 */ var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while(elementsToCheck.length){
        var element = elementsToCheck.shift();
        if (isInert(element, false)) {
            continue;
        }
        if (element.tagName === 'SLOT') {
            // add shadow dom slot scope (slot itself cannot be focusable)
            var assigned = element.assignedElements();
            var content = assigned.length ? assigned : element.children;
            var nestedCandidates = getCandidatesIteratively(content, true, options);
            if (options.flatten) {
                candidates.push.apply(candidates, nestedCandidates);
            } else {
                candidates.push({
                    scopeParent: element,
                    candidates: nestedCandidates
                });
            }
        } else {
            // check candidate element
            var validCandidate = matches.call(element, candidateSelector);
            if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
                candidates.push(element);
            }
            // iterate over shadow content if possible
            var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
            typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);
            // no inert look up because we're already drilling down and checking for inertness
            //  on the way down, so all containers to this root node should have already been
            //  vetted as non-inert
            var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
            if (shadowRoot && validShadowRoot) {
                // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed
                //  shadow exists, so look at light dom children as fallback BUT create a scope for any
                //  child candidates found because they're likely slotted elements (elements that are
                //  children of the web component element (which has the shadow), in the light dom, but
                //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,
                //  _after_ we return from this recursive call
                var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
                if (options.flatten) {
                    candidates.push.apply(candidates, _nestedCandidates);
                } else {
                    candidates.push({
                        scopeParent: element,
                        candidates: _nestedCandidates
                    });
                }
            } else {
                // there's not shadow so just dig into the element's (light dom) children
                //  __without__ giving the element special scope treatment
                elementsToCheck.unshift.apply(elementsToCheck, element.children);
            }
        }
    }
    return candidates;
};
/**
 * @private
 * Determines if the node has an explicitly specified `tabindex` attribute.
 * @param {HTMLElement} node
 * @returns {boolean} True if so; false if not.
 */ var hasTabIndex = function hasTabIndex(node) {
    return !isNaN(parseInt(node.getAttribute('tabindex'), 10));
};
/**
 * Determine the tab index of a given node.
 * @param {HTMLElement} node
 * @returns {number} Tab order (negative, 0, or positive number).
 * @throws {Error} If `node` is falsy.
 */ var getTabIndex = function getTabIndex(node) {
    if (!node) {
        throw new Error('No node provided');
    }
    if (node.tabIndex < 0) {
        // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
        // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
        // yet they are still part of the regular tab order; in FF, they get a default
        // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
        // order, consider their tab index to be 0.
        // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
        // so if they don't have a tabindex attribute specifically set, assume it's 0.
        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
            return 0;
        }
    }
    return node.tabIndex;
};
/**
 * Determine the tab index of a given node __for sort order purposes__.
 * @param {HTMLElement} node
 * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,
 *  has tabIndex -1, but needs to be sorted by document order in order for its content to be
 *  inserted into the correct sort position.
 * @returns {number} Tab order (negative, 0, or positive number).
 */ var getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {
    var tabIndex = getTabIndex(node);
    if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
        return 0;
    }
    return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput(node) {
    return node.tagName === 'INPUT';
};
var isHiddenInput = function isHiddenInput(node) {
    return isInput(node) && node.type === 'hidden';
};
var isDetailsWithSummary = function isDetailsWithSummary(node) {
    var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function(child) {
        return child.tagName === 'SUMMARY';
    });
    return r;
};
var getCheckedRadio = function getCheckedRadio(nodes, form) {
    for(var i = 0; i < nodes.length; i++){
        if (nodes[i].checked && nodes[i].form === form) {
            return nodes[i];
        }
    }
};
var isTabbableRadio = function isTabbableRadio(node) {
    if (!node.name) {
        return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios(name) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };
    var radioSet;
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    } else {
        try {
            radioSet = queryRadios(node.name);
        } catch (err) {
            // eslint-disable-next-line no-console
            console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
            return false;
        }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
};
var isRadio = function isRadio(node) {
    return isInput(node) && node.type === 'radio';
};
var isNonTabbableRadio = function isNonTabbableRadio(node) {
    return isRadio(node) && !isTabbableRadio(node);
};
// determines if a node is ultimately attached to the window's document
var isNodeAttached = function isNodeAttached(node) {
    var _nodeRoot;
    // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
    //  (but NOT _the_ document; see second 'If' comment below for more).
    // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
    //  is attached, and the one we need to check if it's in the document or not (because the
    //  shadow, and all nodes it contains, is never considered in the document since shadows
    //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
    //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
    //  visibility, including all the nodes it contains). The host could be any normal node,
    //  or a custom element (i.e. web component). Either way, that's the one that is considered
    //  part of the document, not the shadow root, nor any of its children (i.e. the node being
    //  tested).
    // To further complicate things, we have to look all the way up until we find a shadow HOST
    //  that is attached (or find none) because the node might be in nested shadows...
    // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
    //  document (per the docs) and while it's a Document-type object, that document does not
    //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
    //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
    //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
    //  node is actually detached.
    // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible
    //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed
    //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then
    //  `ownerDocument` will be `null`, hence the optional chaining on it.
    var nodeRoot = node && getRootNode(node);
    var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
    // in some cases, a detached node will return itself as the root instead of a document or
    //  shadow root object, in which case, we shouldn't try to look further up the host chain
    var attached = false;
    if (nodeRoot && nodeRoot !== node) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
        while(!attached && nodeRootHost){
            var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
            // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
            //  which means we need to get the host's host and check if that parent host is contained
            //  in (i.e. attached to) the document
            nodeRoot = getRootNode(nodeRootHost);
            nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
            attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
        }
    }
    return attached;
};
var isZeroArea = function isZeroArea(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
};
var isHidden = function isHidden(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    // NOTE: visibility will be `undefined` if node is detached from the document
    //  (see notes about this further down), which means we will consider it visible
    //  (this is legacy behavior from a very long way back)
    // NOTE: we check this regardless of `displayCheck="none"` because this is a
    //  _visibility_ check, not a _display_ check
    if (getComputedStyle(node).visibility === 'hidden') {
        return true;
    }
    var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
    }
    if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
        if (typeof getShadowRoot === 'function') {
            // figure out if we should consider the node to be in an undisclosed shadow and use the
            //  'non-zero-area' fallback
            var originalNode = node;
            while(node){
                var parentElement = node.parentElement;
                var rootNode = getRootNode(node);
                if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
                ) {
                    // node has an undisclosed shadow which means we can only treat it as a black box, so we
                    //  fall back to a non-zero-area test
                    return isZeroArea(node);
                } else if (node.assignedSlot) {
                    // iterate up slot
                    node = node.assignedSlot;
                } else if (!parentElement && rootNode !== node.ownerDocument) {
                    // cross shadow boundary
                    node = rootNode.host;
                } else {
                    // iterate up normal dom
                    node = parentElement;
                }
            }
            node = originalNode;
        }
        // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.
        if (isNodeAttached(node)) {
            // this works wherever the node is: if there's at least one client rect, it's
            //  somehow displayed; it also covers the CSS 'display: contents' case where the
            //  node itself is hidden in place of its contents; and there's no need to search
            //  up the hierarchy either
            return !node.getClientRects().length;
        }
        // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.
        //
        // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
        //  nodes as visible with the 'none' fallback.__
        if (displayCheck !== 'legacy-full') {
            return true; // hidden
        }
    // else, fallback to 'none' mode and consider the node visible
    } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
    }
    // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
    //  it's visible
    return false;
};
// form fields (nested) inside a disabled fieldset are not focusable/tabbable
//  unless they are in the _first_ <legend> element of the top-most disabled
//  fieldset
var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        // check if `node` is contained in a disabled <fieldset>
        while(parentNode){
            if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
                // look for the first <legend> among the children of the disabled <fieldset>
                for(var i = 0; i < parentNode.children.length; i++){
                    var child = parentNode.children.item(i);
                    // when the first <legend> (in document order) is found
                    if (child.tagName === 'LEGEND') {
                        // if its parent <fieldset> is not nested in another disabled <fieldset>,
                        // return whether `node` is a descendant of its first <legend>
                        return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
                    }
                }
                // the disabled <fieldset> containing `node` has no <legend>
                return true;
            }
            parentNode = parentNode.parentElement;
        }
    }
    // else, node's tabbable/focusable state should not be affected by a fieldset's
    //  enabled/disabled state
    return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
    if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
    //  because we're limited in the type of selectors we can use in JSDom (see related
    //  note related to `candidateSelectors`)
    isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
    }
    return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
    if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
        return false;
    }
    return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
    }
    // If a custom element has an explicit negative tabindex,
    // browsers will not allow tab targeting said element's children.
    return false;
};
/**
 * @param {Array.<Element|CandidateScope>} candidates
 * @returns Element[]
 */ var sortByOrder = function sortByOrder(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i) {
        var isScope = !!item.scopeParent;
        var element = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element, isScope);
        var elements = isScope ? sortByOrder(item.candidates) : element;
        if (candidateTabindex === 0) {
            isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
        } else {
            orderedTabbables.push({
                documentOrder: i,
                tabIndex: candidateTabindex,
                item: item,
                isScope: isScope,
                content: elements
            });
        }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
    }, []).concat(regularTabbables);
};
var tabbable = function tabbable(container, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([
            container
        ], options.includeContainer, {
            filter: isNodeMatchingSelectorTabbable.bind(null, options),
            flatten: false,
            getShadowRoot: options.getShadowRoot,
            shadowRootFilter: isValidShadowRootTabbable
        });
    } else {
        candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    }
    return sortByOrder(candidates);
};
var focusable = function focusable(container, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([
            container
        ], options.includeContainer, {
            filter: isNodeMatchingSelectorFocusable.bind(null, options),
            flatten: true,
            getShadowRoot: options.getShadowRoot
        });
    } else {
        candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    }
    return candidates;
};
var isTabbable = function isTabbable(node, options) {
    options = options || {};
    if (!node) {
        throw new Error('No node provided');
    }
    if (matches.call(node, candidateSelector) === false) {
        return false;
    }
    return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* #__PURE__ */ candidateSelectors.concat('iframe').join(',');
var isFocusable = function isFocusable(node, options) {
    options = options || {};
    if (!node) {
        throw new Error('No node provided');
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
};
;
 //# sourceMappingURL=index.esm.js.map
}}),
"[project]/node_modules/focus-trap/dist/focus-trap.esm.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*!
* focus-trap 7.6.0
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/ __turbopack_esm__({
    "createFocusTrap": (()=>createFocusTrap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/tabbable/dist/index.esm.js [app-rsc] (ecmascript)");
;
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread2(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
var activeFocusTraps = {
    activateTrap: function activateTrap(trapStack, trap) {
        if (trapStack.length > 0) {
            var activeTrap = trapStack[trapStack.length - 1];
            if (activeTrap !== trap) {
                activeTrap.pause();
            }
        }
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex === -1) {
            trapStack.push(trap);
        } else {
            // move this existing trap to the front of the queue
            trapStack.splice(trapIndex, 1);
            trapStack.push(trap);
        }
    },
    deactivateTrap: function deactivateTrap(trapStack, trap) {
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex !== -1) {
            trapStack.splice(trapIndex, 1);
        }
        if (trapStack.length > 0) {
            trapStack[trapStack.length - 1].unpause();
        }
    }
};
var isSelectableInput = function isSelectableInput(node) {
    return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
};
var isEscapeEvent = function isEscapeEvent(e) {
    return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
};
var isTabEvent = function isTabEvent(e) {
    return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
};
// checks for TAB by default
var isKeyForward = function isKeyForward(e) {
    return isTabEvent(e) && !e.shiftKey;
};
// checks for SHIFT+TAB by default
var isKeyBackward = function isKeyBackward(e) {
    return isTabEvent(e) && e.shiftKey;
};
var delay = function delay(fn) {
    return setTimeout(fn, 0);
};
// Array.find/findIndex() are not supported on IE; this replicates enough
//  of Array.findIndex() for our needs
var findIndex = function findIndex(arr, fn) {
    var idx = -1;
    arr.every(function(value, i) {
        if (fn(value)) {
            idx = i;
            return false; // break
        }
        return true; // next
    });
    return idx;
};
/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */ var valueOrHandler = function valueOrHandler(value) {
    for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        params[_key - 1] = arguments[_key];
    }
    return typeof value === 'function' ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget(event) {
    // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the
    //  shadow host. However, event.target.composedPath() will be an array of
    //  nodes "clicked" from inner-most (the actual element inside the shadow) to
    //  outer-most (the host HTML document). If we have access to composedPath(),
    //  then use its first element; otherwise, fall back to event.target (and
    //  this only works for an _open_ shadow DOM; otherwise,
    //  composedPath()[0] === event.target always).
    return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;
};
// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this
//  current instance use the same stack if `userOptions.trapStack` isn't specified
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap(elements, userOptions) {
    // SSR: a live trap shouldn't be created in this type of environment so this
    //  should be safe code to execute if the `document` option isn't specified
    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
    var config = _objectSpread2({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true,
        isKeyForward: isKeyForward,
        isKeyBackward: isKeyBackward
    }, userOptions);
    var state = {
        // containers given to createFocusTrap()
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying tabbable nodes in `containers` in the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{
        //   container: HTMLElement,
        //   tabbableNodes: Array<HTMLElement>, // empty if none
        //   focusableNodes: Array<HTMLElement>, // empty if none
        //   posTabIndexesFound: boolean,
        //   firstTabbableNode: HTMLElement|undefined,
        //   lastTabbableNode: HTMLElement|undefined,
        //   firstDomTabbableNode: HTMLElement|undefined,
        //   lastDomTabbableNode: HTMLElement|undefined,
        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
        // }>}
        containerGroups: [],
        // same order/length as `containers` list
        // references to objects in `containerGroups`, but only those that actually have
        //  tabbable nodes in them
        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
        //  the same length
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        // timer ID for when delayInitialFocus is true and initial focus in this trap
        //  has been delayed during activation
        delayInitialFocusTimer: undefined,
        // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
        recentNavEvent: undefined
    };
    var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later
    /**
   * Gets a configuration option value.
   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
   *  value will be taken from this object. Otherwise, value will be taken from base configuration.
   * @param {string} optionName Name of the option whose value is sought.
   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
   */ var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];
    };
    /**
   * Finds the index of the container that contains the element.
   * @param {HTMLElement} element
   * @param {Event} [event] If available, and `element` isn't directly found in any container,
   *  the event's composed path is used to see if includes any known trap containers in the
   *  case where the element is inside a Shadow DOM.
   * @returns {number} Index of the container in either `state.containers` or
   *  `state.containerGroups` (the order/length of these lists are the same); -1
   *  if the element isn't found.
   */ var findContainerIndex = function findContainerIndex(element, event) {
        var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;
        // NOTE: search `containerGroups` because it's possible a group contains no tabbable
        //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)
        //  and we still need to find the element in there
        return state.containerGroups.findIndex(function(_ref) {
            var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
            return container.contains(element) || (//  web components if the `tabbableOptions.getShadowRoot` option was used for
            //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
            //  look inside web components even if open)
            composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
                return node === element;
            });
        });
    };
    /**
   * Gets the node for the given option, which is expected to be an option that
   *  can be either a DOM node, a string that is a selector to get a node, `false`
   *  (if a node is explicitly NOT given), or a function that returns any of these
   *  values.
   * @param {string} optionName
   * @returns {undefined | false | HTMLElement | SVGElement} Returns
   *  `undefined` if the option is not specified; `false` if the option
   *  resolved to `false` (node explicitly not given); otherwise, the resolved
   *  DOM node.
   * @throws {Error} If the option is set, not `false`, and is not, or does not
   *  resolve to a node.
   */ var getNodeForOption = function getNodeForOption(optionName) {
        var optionValue = config[optionName];
        if (typeof optionValue === 'function') {
            for(var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                params[_key2 - 1] = arguments[_key2];
            }
            optionValue = optionValue.apply(void 0, params);
        }
        if (optionValue === true) {
            optionValue = undefined; // use default value
        }
        if (!optionValue) {
            if (optionValue === undefined || optionValue === false) {
                return optionValue;
            }
            // else, empty string (invalid), null (invalid), 0 (invalid)
            throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point
        if (typeof optionValue === 'string') {
            node = doc.querySelector(optionValue); // resolve to node, or null if fails
            if (!node) {
                throw new Error("`".concat(optionName, "` as selector refers to no known node"));
            }
        }
        return node;
    };
    var getInitialFocusNode = function getInitialFocusNode() {
        var node = getNodeForOption('initialFocus');
        // false explicitly indicates we want no initialFocus at all
        if (node === false) {
            return false;
        }
        if (node === undefined || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFocusable"])(node, config.tabbableOptions)) {
            // option not specified nor focusable: use fallback options
            if (findContainerIndex(doc.activeElement) >= 0) {
                node = doc.activeElement;
            } else {
                var firstTabbableGroup = state.tabbableGroups[0];
                var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
                // NOTE: `fallbackFocus` option function cannot return `false` (not supported)
                node = firstTabbableNode || getNodeForOption('fallbackFocus');
            }
        }
        if (!node) {
            throw new Error('Your focus-trap needs to have at least one focusable element');
        }
        return node;
    };
    var updateTabbableNodes = function updateTabbableNodes() {
        state.containerGroups = state.containers.map(function(container) {
            var tabbableNodes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["tabbable"])(container, config.tabbableOptions);
            // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes
            //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes
            //  are focusable but not tabbable
            var focusableNodes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["focusable"])(container, config.tabbableOptions);
            var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;
            var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;
            var firstDomTabbableNode = focusableNodes.find(function(node) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isTabbable"])(node);
            });
            var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isTabbable"])(node);
            });
            var posTabIndexesFound = !!tabbableNodes.find(function(node) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTabIndex"])(node) > 0;
            });
            return {
                container: container,
                tabbableNodes: tabbableNodes,
                focusableNodes: focusableNodes,
                /** True if at least one node with positive `tabindex` was found in this container. */ posTabIndexesFound: posTabIndexesFound,
                /** First tabbable node in container, __tabindex__ order; `undefined` if none. */ firstTabbableNode: firstTabbableNode,
                /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */ lastTabbableNode: lastTabbableNode,
                // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
                //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
                //  because that API doesn't work with Shadow DOM as well as it should (@see
                //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
                //  to address an edge case related to positive tabindex support, this seems like a much easier,
                //  "close enough most of the time" alternative for positive tabindexes which should generally
                //  be avoided anyway...
                /** First tabbable node in container, __DOM__ order; `undefined` if none. */ firstDomTabbableNode: firstDomTabbableNode,
                /** Last tabbable node in container, __DOM__ order; `undefined` if none. */ lastDomTabbableNode: lastDomTabbableNode,
                /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */ nextTabbableNode: function nextTabbableNode(node) {
                    var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                    var nodeIdx = tabbableNodes.indexOf(node);
                    if (nodeIdx < 0) {
                        // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):
                        //  since `node` should at least have been focusable, we assume that's the case and mimic
                        //  what browsers do, which is set focus to the next node in __document position order__,
                        //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE
                        //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to
                        //  basic DOM order
                        if (forward) {
                            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isTabbable"])(el);
                            });
                        }
                        return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isTabbable"])(el);
                        });
                    }
                    return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
                }
            };
        });
        state.tabbableGroups = state.containerGroups.filter(function(group) {
            return group.tabbableNodes.length > 0;
        });
        // throw if no groups have tabbable nodes and we don't have a fallback focus node either
        if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option
        ) {
            throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');
        }
        // NOTE: Positive tabindexes are only properly supported in single-container traps because
        //  doing it across multiple containers where tabindexes could be all over the place
        //  would require Tabbable to support multiple containers, would require additional
        //  specialized Shadow DOM support, and would require Tabbable's multi-container support
        //  to look at those containers in document position order rather than user-provided
        //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on
        //  https://github.com/focus-trap/focus-trap/issues/375 for more details.
        if (state.containerGroups.find(function(g) {
            return g.posTabIndexesFound;
        }) && state.containerGroups.length > 1) {
            throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
        }
    };
    /**
   * Gets the current activeElement. If it's a web-component and has open shadow-root
   * it will recursively search inside shadow roots for the "true" activeElement.
   *
   * @param {Document | ShadowRoot} el
   *
   * @returns {HTMLElement} The element that currently has the focus
   **/ var _getActiveElement = function getActiveElement(el) {
        var activeElement = el.activeElement;
        if (!activeElement) {
            return;
        }
        if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
            return _getActiveElement(activeElement.shadowRoot);
        }
        return activeElement;
    };
    var _tryFocus = function tryFocus(node) {
        if (node === false) {
            return;
        }
        if (node === _getActiveElement(document)) {
            return;
        }
        if (!node || !node.focus) {
            _tryFocus(getInitialFocusNode());
            return;
        }
        node.focus({
            preventScroll: !!config.preventScroll
        });
        // NOTE: focus() API does not trigger focusIn event so set MRU node manually
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
            node.select();
        }
    };
    var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {
        var node = getNodeForOption('setReturnFocus', previousActiveElement);
        return node ? node : node === false ? false : previousActiveElement;
    };
    /**
   * Finds the next node (in either direction) where focus should move according to a
   *  keyboard focus-in event.
   * @param {Object} params
   * @param {Node} [params.target] Known target __from which__ to navigate, if any.
   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event
   *  will be used to determine the `target`). Ignored if `target` is specified.
   * @param {boolean} [params.isBackward] True if focus should move backward.
   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be
   *  determined given the current state of the trap.
   */ var findNextNavNode = function findNextNavNode(_ref2) {
        var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
        target = target || getActualTarget(event);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
            // make sure the target is actually contained in a group
            // NOTE: the target may also be the container itself if it's focusable
            //  with tabIndex='-1' and was given initial focus
            var containerIndex = findContainerIndex(target, event);
            var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;
            if (containerIndex < 0) {
                // target not found in any group: quite possible focus has escaped the trap,
                //  so bring it back into...
                if (isBackward) {
                    // ...the last node in the last group
                    destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
                } else {
                    // ...the first node in the first group
                    destinationNode = state.tabbableGroups[0].firstTabbableNode;
                }
            } else if (isBackward) {
                // REVERSE
                // is the target the first tabbable node in a group?
                var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
                    var firstTabbableNode = _ref3.firstTabbableNode;
                    return target === firstTabbableNode;
                });
                if (startOfGroupIndex < 0 && (containerGroup.container === target || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFocusable"])(target, config.tabbableOptions) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isTabbable"])(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
                    // an exception case where the target is either the container itself, or
                    //  a non-tabbable node that was given focus (i.e. tabindex is negative
                    //  and user clicked on it or node was programmatically given focus)
                    //  and is not followed by any other tabbable node, in which
                    //  case, we should handle shift+tab as if focus were on the container's
                    //  first tabbable node, and go to the last tabbable node of the LAST group
                    startOfGroupIndex = containerIndex;
                }
                if (startOfGroupIndex >= 0) {
                    // YES: then shift+tab should go to the last tabbable node in the
                    //  previous group (and wrap around to the last tabbable node of
                    //  the LAST group if it's the first tabbable node of the FIRST group)
                    var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
                    var destinationGroup = state.tabbableGroups[destinationGroupIndex];
                    destinationNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTabIndex"])(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
                } else if (!isTabEvent(event)) {
                    // user must have customized the nav keys so we have to move focus manually _within_
                    //  the active group: do this based on the order determined by tabbable()
                    destinationNode = containerGroup.nextTabbableNode(target, false);
                }
            } else {
                // FORWARD
                // is the target the last tabbable node in a group?
                var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
                    var lastTabbableNode = _ref4.lastTabbableNode;
                    return target === lastTabbableNode;
                });
                if (lastOfGroupIndex < 0 && (containerGroup.container === target || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFocusable"])(target, config.tabbableOptions) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isTabbable"])(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
                    // an exception case where the target is the container itself, or
                    //  a non-tabbable node that was given focus (i.e. tabindex is negative
                    //  and user clicked on it or node was programmatically given focus)
                    //  and is not followed by any other tabbable node, in which
                    //  case, we should handle tab as if focus were on the container's
                    //  last tabbable node, and go to the first tabbable node of the FIRST group
                    lastOfGroupIndex = containerIndex;
                }
                if (lastOfGroupIndex >= 0) {
                    // YES: then tab should go to the first tabbable node in the next
                    //  group (and wrap around to the first tabbable node of the FIRST
                    //  group if it's the last tabbable node of the LAST group)
                    var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
                    var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
                    destinationNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTabIndex"])(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
                } else if (!isTabEvent(event)) {
                    // user must have customized the nav keys so we have to move focus manually _within_
                    //  the active group: do this based on the order determined by tabbable()
                    destinationNode = containerGroup.nextTabbableNode(target);
                }
            }
        } else {
            // no groups available
            // NOTE: the fallbackFocus option does not support returning false to opt-out
            destinationNode = getNodeForOption('fallbackFocus');
        }
        return destinationNode;
    };
    // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event.
    var checkPointerDown = function checkPointerDown(e) {
        var target = getActualTarget(e);
        if (findContainerIndex(target, e) >= 0) {
            // allow the click since it ocurred inside the trap
            return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e)) {
            // immediately deactivate the trap
            trap.deactivate({
                // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
                //  which will result in the outside click setting focus to the node
                //  that was clicked (and if not focusable, to "nothing"); by setting
                //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
                //  on activation (or the configured `setReturnFocus` node), whether the
                //  outside click was on a focusable node or not
                returnFocus: config.returnFocusOnDeactivate
            });
            return;
        }
        // This is needed for mobile devices.
        // (If we'll only let `click` events through,
        // then on mobile they will be blocked anyways if `touchstart` is blocked.)
        if (valueOrHandler(config.allowOutsideClick, e)) {
            // allow the click outside the trap to take place
            return;
        }
        // otherwise, prevent the click
        e.preventDefault();
    };
    // In case focus escapes the trap for some strange reason, pull it back in.
    // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected
    //  scrolling if the node that got focused was out of view; there's nothing we can do to
    //  prevent that from happening by the time we discover that focus escaped
    var checkFocusIn = function checkFocusIn(event) {
        var target = getActualTarget(event);
        var targetContained = findContainerIndex(target, event) >= 0;
        // In Firefox when you Tab out of an iframe the Document is briefly focused.
        if (targetContained || target instanceof Document) {
            if (targetContained) {
                state.mostRecentlyFocusedNode = target;
            }
        } else {
            // escaped! pull it back in to where it just left
            event.stopImmediatePropagation();
            // focus will escape if the MRU node had a positive tab index and user tried to nav forward;
            //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward
            //  toward a node with a positive tab index
            var nextNode; // next node to focus, if we find one
            var navAcrossContainers = true;
            if (state.mostRecentlyFocusedNode) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTabIndex"])(state.mostRecentlyFocusedNode) > 0) {
                    // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...
                    var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
                    // there MAY not be any tabbable nodes in the container if there are at least 2 containers
                    //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container
                    //  with at least one tabbable node in order to function, so this could be the other container
                    //  with nothing tabbable in it)
                    var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
                    if (tabbableNodes.length > 0) {
                        // MRU tab index MAY not be found if the MRU node is focusable but not tabbable
                        var mruTabIdx = tabbableNodes.findIndex(function(node) {
                            return node === state.mostRecentlyFocusedNode;
                        });
                        if (mruTabIdx >= 0) {
                            if (config.isKeyForward(state.recentNavEvent)) {
                                if (mruTabIdx + 1 < tabbableNodes.length) {
                                    nextNode = tabbableNodes[mruTabIdx + 1];
                                    navAcrossContainers = false;
                                }
                            // else, don't wrap within the container as focus should move to next/previous
                            //  container
                            } else {
                                if (mruTabIdx - 1 >= 0) {
                                    nextNode = tabbableNodes[mruTabIdx - 1];
                                    navAcrossContainers = false;
                                }
                            // else, don't wrap within the container as focus should move to next/previous
                            //  container
                            }
                        // else, don't find in container order without considering direction too
                        }
                    }
                // else, no tabbable nodes in that container (which means we must have at least one other
                //  container with at least one tabbable node in it, otherwise focus-trap would've thrown
                //  an error the last time updateTabbableNodes() was run): find next node among all known
                //  containers
                } else {
                    // check to see if there's at least one tabbable node with a positive tab index inside
                    //  the trap because focus seems to escape when navigating backward from a tabbable node
                    //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with
                    //  the greatest positive tab index like it should)
                    if (!state.containerGroups.some(function(g) {
                        return g.tabbableNodes.some(function(n) {
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tabbable$2f$dist$2f$index$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTabIndex"])(n) > 0;
                        });
                    })) {
                        // no containers with tabbable nodes with positive tab indexes which means the focus
                        //  escaped for some other reason and we should just execute the fallback to the
                        //  MRU node or initial focus node, if any
                        navAcrossContainers = false;
                    }
                }
            } else {
                // no MRU node means we're likely in some initial condition when the trap has just
                //  been activated and initial focus hasn't been given yet, in which case we should
                //  fall through to trying to focus the initial focus node, which is what should
                //  happen below at this point in the logic
                navAcrossContainers = false;
            }
            if (navAcrossContainers) {
                nextNode = findNextNavNode({
                    // move FROM the MRU node, not event-related node (which will be the node that is
                    //  outside the trap causing the focus escape we're trying to fix)
                    target: state.mostRecentlyFocusedNode,
                    isBackward: config.isKeyBackward(state.recentNavEvent)
                });
            }
            if (nextNode) {
                _tryFocus(nextNode);
            } else {
                _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
            }
        }
        state.recentNavEvent = undefined; // clear
    };
    // Hijack key nav events on the first and last focusable nodes of the trap,
    // in order to prevent focus from escaping. If it escapes for even a
    // moment it can end up scrolling the page and causing confusion so we
    // kind of need to capture the action at the keydown phase.
    var checkKeyNav = function checkKeyNav(event) {
        var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        state.recentNavEvent = event;
        var destinationNode = findNextNavNode({
            event: event,
            isBackward: isBackward
        });
        if (destinationNode) {
            if (isTabEvent(event)) {
                // since tab natively moves focus, we wouldn't have a destination node unless we
                //  were on the edge of a container and had to move to the next/previous edge, in
                //  which case we want to prevent default to keep the browser from moving focus
                //  to where it normally would
                event.preventDefault();
            }
            _tryFocus(destinationNode);
        }
    // else, let the browser take care of [shift+]tab and move the focus
    };
    var checkTabKey = function checkTabKey(event) {
        if (config.isKeyForward(event) || config.isKeyBackward(event)) {
            checkKeyNav(event, config.isKeyBackward(event));
        }
    };
    // we use a different event phase for the Escape key to allow canceling the event and checking for this in escapeDeactivates
    var checkEscapeKey = function checkEscapeKey(event) {
        if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
            event.preventDefault();
            trap.deactivate();
        }
    };
    var checkClick = function checkClick(e) {
        var target = getActualTarget(e);
        if (findContainerIndex(target, e) >= 0) {
            return;
        }
        if (valueOrHandler(config.clickOutsideDeactivates, e)) {
            return;
        }
        if (valueOrHandler(config.allowOutsideClick, e)) {
            return;
        }
        e.preventDefault();
        e.stopImmediatePropagation();
    };
    //
    // EVENT LISTENERS
    //
    var addListeners = function addListeners() {
        if (!state.active) {
            return;
        }
        // There can be only one listening focus trap at a time
        activeFocusTraps.activateTrap(trapStack, trap);
        // Delay ensures that the focused element doesn't capture the event
        // that caused the focus trap activation.
        state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
            _tryFocus(getInitialFocusNode());
        }) : _tryFocus(getInitialFocusNode());
        doc.addEventListener('focusin', checkFocusIn, true);
        doc.addEventListener('mousedown', checkPointerDown, {
            capture: true,
            passive: false
        });
        doc.addEventListener('touchstart', checkPointerDown, {
            capture: true,
            passive: false
        });
        doc.addEventListener('click', checkClick, {
            capture: true,
            passive: false
        });
        doc.addEventListener('keydown', checkTabKey, {
            capture: true,
            passive: false
        });
        doc.addEventListener('keydown', checkEscapeKey);
        return trap;
    };
    var removeListeners = function removeListeners() {
        if (!state.active) {
            return;
        }
        doc.removeEventListener('focusin', checkFocusIn, true);
        doc.removeEventListener('mousedown', checkPointerDown, true);
        doc.removeEventListener('touchstart', checkPointerDown, true);
        doc.removeEventListener('click', checkClick, true);
        doc.removeEventListener('keydown', checkTabKey, true);
        doc.removeEventListener('keydown', checkEscapeKey);
        return trap;
    };
    //
    // MUTATION OBSERVER
    //
    var checkDomRemoval = function checkDomRemoval(mutations) {
        var isFocusedNodeRemoved = mutations.some(function(mutation) {
            var removedNodes = Array.from(mutation.removedNodes);
            return removedNodes.some(function(node) {
                return node === state.mostRecentlyFocusedNode;
            });
        });
        // If the currently focused is removed then browsers will move focus to the
        // <body> element. If this happens, try to move focus back into the trap.
        if (isFocusedNodeRemoved) {
            _tryFocus(getInitialFocusNode());
        }
    };
    // Use MutationObserver - if supported - to detect if focused node is removed
    // from the DOM.
    var mutationObserver = "undefined" !== 'undefined' && 'MutationObserver' in window ? ("TURBOPACK unreachable", undefined) : undefined;
    var updateObservedNodes = function updateObservedNodes() {
        if (!mutationObserver) {
            return;
        }
        mutationObserver.disconnect();
        if (state.active && !state.paused) {
            state.containers.map(function(container) {
                mutationObserver.observe(container, {
                    subtree: true,
                    childList: true
                });
            });
        }
    };
    //
    // TRAP DEFINITION
    //
    trap = {
        get active () {
            return state.active;
        },
        get paused () {
            return state.paused;
        },
        activate: function activate(activateOptions) {
            if (state.active) {
                return this;
            }
            var onActivate = getOption(activateOptions, 'onActivate');
            var onPostActivate = getOption(activateOptions, 'onPostActivate');
            var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');
            if (!checkCanFocusTrap) {
                updateTabbableNodes();
            }
            state.active = true;
            state.paused = false;
            state.nodeFocusedBeforeActivation = doc.activeElement;
            onActivate === null || onActivate === void 0 || onActivate();
            var finishActivation = function finishActivation() {
                if (checkCanFocusTrap) {
                    updateTabbableNodes();
                }
                addListeners();
                updateObservedNodes();
                onPostActivate === null || onPostActivate === void 0 || onPostActivate();
            };
            if (checkCanFocusTrap) {
                checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
                return this;
            }
            finishActivation();
            return this;
        },
        deactivate: function deactivate(deactivateOptions) {
            if (!state.active) {
                return this;
            }
            var options = _objectSpread2({
                onDeactivate: config.onDeactivate,
                onPostDeactivate: config.onPostDeactivate,
                checkCanReturnFocus: config.checkCanReturnFocus
            }, deactivateOptions);
            clearTimeout(state.delayInitialFocusTimer); // noop if undefined
            state.delayInitialFocusTimer = undefined;
            removeListeners();
            state.active = false;
            state.paused = false;
            updateObservedNodes();
            activeFocusTraps.deactivateTrap(trapStack, trap);
            var onDeactivate = getOption(options, 'onDeactivate');
            var onPostDeactivate = getOption(options, 'onPostDeactivate');
            var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');
            var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');
            onDeactivate === null || onDeactivate === void 0 || onDeactivate();
            var finishDeactivation = function finishDeactivation() {
                delay(function() {
                    if (returnFocus) {
                        _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
                    }
                    onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
                });
            };
            if (returnFocus && checkCanReturnFocus) {
                checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
                return this;
            }
            finishDeactivation();
            return this;
        },
        pause: function pause(pauseOptions) {
            if (state.paused || !state.active) {
                return this;
            }
            var onPause = getOption(pauseOptions, 'onPause');
            var onPostPause = getOption(pauseOptions, 'onPostPause');
            state.paused = true;
            onPause === null || onPause === void 0 || onPause();
            removeListeners();
            updateObservedNodes();
            onPostPause === null || onPostPause === void 0 || onPostPause();
            return this;
        },
        unpause: function unpause(unpauseOptions) {
            if (!state.paused || !state.active) {
                return this;
            }
            var onUnpause = getOption(unpauseOptions, 'onUnpause');
            var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');
            state.paused = false;
            onUnpause === null || onUnpause === void 0 || onUnpause();
            updateTabbableNodes();
            addListeners();
            updateObservedNodes();
            onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
            return this;
        },
        updateContainerElements: function updateContainerElements(containerElements) {
            var elementsAsArray = [].concat(containerElements).filter(Boolean);
            state.containers = elementsAsArray.map(function(element) {
                return typeof element === 'string' ? doc.querySelector(element) : element;
            });
            if (state.active) {
                updateTabbableNodes();
            }
            updateObservedNodes();
            return this;
        }
    };
    // initialize container elements
    trap.updateContainerElements(elements);
    return trap;
};
;
 //# sourceMappingURL=focus-trap.esm.js.map
}}),
"[project]/node_modules/aria-hidden/dist/es2015/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "hideOthers": (()=>hideOthers),
    "inertOthers": (()=>inertOthers),
    "supportsInert": (()=>supportsInert),
    "suppressOthers": (()=>suppressOthers)
});
var getDefaultParent = function(originalTarget) {
    if (typeof document === 'undefined') {
        return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
};
var counterMap = new WeakMap();
var uncontrolledNodes = new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
    return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
    return targets.map(function(target) {
        if (parent.contains(target)) {
            return target;
        }
        var correctedTarget = unwrapHost(target);
        if (correctedTarget && parent.contains(correctedTarget)) {
            return correctedTarget;
        }
        console.error('aria-hidden', target, 'in not contained inside', parent, '. Doing nothing');
        return null;
    }).filter(function(x) {
        return Boolean(x);
    });
};
/**
 * Marks everything except given node(or nodes) as aria-hidden
 * @param {Element | Element[]} originalTarget - elements to keep on the page
 * @param [parentNode] - top element, defaults to document.body
 * @param {String} [markerName] - a special attribute to mark every node
 * @param {String} [controlAttribute] - html Attribute to control
 * @return {Undo} undo command
 */ var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [
        originalTarget
    ]);
    if (!markerMap[markerName]) {
        markerMap[markerName] = new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = new Set();
    var elementsToStop = new Set(targets);
    var keep = function(el) {
        if (!el || elementsToKeep.has(el)) {
            return;
        }
        elementsToKeep.add(el);
        keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function(parent) {
        if (!parent || elementsToStop.has(parent)) {
            return;
        }
        Array.prototype.forEach.call(parent.children, function(node) {
            if (elementsToKeep.has(node)) {
                deep(node);
            } else {
                try {
                    var attr = node.getAttribute(controlAttribute);
                    var alreadyHidden = attr !== null && attr !== 'false';
                    var counterValue = (counterMap.get(node) || 0) + 1;
                    var markerValue = (markerCounter.get(node) || 0) + 1;
                    counterMap.set(node, counterValue);
                    markerCounter.set(node, markerValue);
                    hiddenNodes.push(node);
                    if (counterValue === 1 && alreadyHidden) {
                        uncontrolledNodes.set(node, true);
                    }
                    if (markerValue === 1) {
                        node.setAttribute(markerName, 'true');
                    }
                    if (!alreadyHidden) {
                        node.setAttribute(controlAttribute, 'true');
                    }
                } catch (e) {
                    console.error('aria-hidden: cannot operate on ', node, e);
                }
            }
        });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function() {
        hiddenNodes.forEach(function(node) {
            var counterValue = counterMap.get(node) - 1;
            var markerValue = markerCounter.get(node) - 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            if (!counterValue) {
                if (!uncontrolledNodes.has(node)) {
                    node.removeAttribute(controlAttribute);
                }
                uncontrolledNodes.delete(node);
            }
            if (!markerValue) {
                node.removeAttribute(markerName);
            }
        });
        lockCount--;
        if (!lockCount) {
            // clear
            counterMap = new WeakMap();
            counterMap = new WeakMap();
            uncontrolledNodes = new WeakMap();
            markerMap = {};
        }
    };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
        markerName = 'data-aria-hidden';
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [
        originalTarget
    ]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
        return function() {
            return null;
        };
    }
    // we should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll('[aria-live]')));
    return applyAttributeToOthers(targets, activeParentNode, markerName, 'aria-hidden');
};
var inertOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
        markerName = 'data-inert-ed';
    }
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
        return function() {
            return null;
        };
    }
    return applyAttributeToOthers(originalTarget, activeParentNode, markerName, 'inert');
};
var supportsInert = function() {
    return typeof HTMLElement !== 'undefined' && HTMLElement.prototype.hasOwnProperty('inert');
};
var suppressOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
        markerName = 'data-suppressed';
    }
    return (supportsInert() ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);
};
}}),
"[project]/node_modules/@zag-js/aria-hidden/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ariaHidden": (()=>ariaHidden)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$aria$2d$hidden$2f$dist$2f$es2015$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/aria-hidden/dist/es2015/index.js [app-rsc] (ecmascript)");
;
// src/index.ts
var raf = (fn)=>{
    const frameId = requestAnimationFrame(()=>fn());
    return ()=>cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options = {}) {
    const { defer = true } = options;
    const func = defer ? raf : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
        const elements = targets.filter(Boolean);
        if (elements.length === 0) return;
        cleanups.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$aria$2d$hidden$2f$dist$2f$es2015$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["hideOthers"])(elements));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn?.());
    };
}
;
}}),
"[project]/node_modules/@zag-js/dialog/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dismissable/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$remove$2d$scroll$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/remove-scroll/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$focus$2d$trap$2f$dist$2f$focus$2d$trap$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/focus-trap/dist/focus-trap.esm.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$aria$2d$hidden$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/aria-hidden/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
// src/dialog.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("dialog").parts("trigger", "backdrop", "positioner", "content", "title", "description", "closeTrigger");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getPositionerId: (ctx)=>ctx.ids?.positioner ?? `dialog:${ctx.id}:positioner`,
    getBackdropId: (ctx)=>ctx.ids?.backdrop ?? `dialog:${ctx.id}:backdrop`,
    getContentId: (ctx)=>ctx.ids?.content ?? `dialog:${ctx.id}:content`,
    getTriggerId: (ctx)=>ctx.ids?.trigger ?? `dialog:${ctx.id}:trigger`,
    getTitleId: (ctx)=>ctx.ids?.title ?? `dialog:${ctx.id}:title`,
    getDescriptionId: (ctx)=>ctx.ids?.description ?? `dialog:${ctx.id}:description`,
    getCloseTriggerId: (ctx)=>ctx.ids?.closeTrigger ?? `dialog:${ctx.id}:close`,
    getContentEl: (ctx)=>dom.getById(ctx, dom.getContentId(ctx)),
    getPositionerEl: (ctx)=>dom.getById(ctx, dom.getPositionerId(ctx)),
    getBackdropEl: (ctx)=>dom.getById(ctx, dom.getBackdropId(ctx)),
    getTriggerEl: (ctx)=>dom.getById(ctx, dom.getTriggerId(ctx)),
    getTitleEl: (ctx)=>dom.getById(ctx, dom.getTitleId(ctx)),
    getDescriptionEl: (ctx)=>dom.getById(ctx, dom.getDescriptionId(ctx)),
    getCloseTriggerEl: (ctx)=>dom.getById(ctx, dom.getCloseTriggerId(ctx))
});
// src/dialog.connect.ts
function connect(state, send, normalize) {
    const ariaLabel = state.context["aria-label"];
    const open = state.matches("open");
    const rendered = state.context.renderedElements;
    return {
        open,
        setOpen (nextOpen) {
            if (nextOpen === open) return;
            send(nextOpen ? "OPEN" : "CLOSE");
        },
        getTriggerProps () {
            return normalize.button({
                ...parts.trigger.attrs,
                dir: state.context.dir,
                id: dom.getTriggerId(state.context),
                "aria-haspopup": "dialog",
                type: "button",
                "aria-expanded": open,
                "data-state": open ? "open" : "closed",
                "aria-controls": dom.getContentId(state.context),
                onClick (event) {
                    if (event.defaultPrevented) return;
                    send("TOGGLE");
                }
            });
        },
        getBackdropProps () {
            return normalize.element({
                ...parts.backdrop.attrs,
                dir: state.context.dir,
                hidden: !open,
                id: dom.getBackdropId(state.context),
                "data-state": open ? "open" : "closed"
            });
        },
        getPositionerProps () {
            return normalize.element({
                ...parts.positioner.attrs,
                dir: state.context.dir,
                id: dom.getPositionerId(state.context),
                style: {
                    pointerEvents: open ? void 0 : "none"
                }
            });
        },
        getContentProps () {
            return normalize.element({
                ...parts.content.attrs,
                dir: state.context.dir,
                role: state.context.role,
                hidden: !open,
                id: dom.getContentId(state.context),
                tabIndex: -1,
                "data-state": open ? "open" : "closed",
                "aria-modal": true,
                "aria-label": ariaLabel || void 0,
                "aria-labelledby": ariaLabel || !rendered.title ? void 0 : dom.getTitleId(state.context),
                "aria-describedby": rendered.description ? dom.getDescriptionId(state.context) : void 0
            });
        },
        getTitleProps () {
            return normalize.element({
                ...parts.title.attrs,
                dir: state.context.dir,
                id: dom.getTitleId(state.context)
            });
        },
        getDescriptionProps () {
            return normalize.element({
                ...parts.description.attrs,
                dir: state.context.dir,
                id: dom.getDescriptionId(state.context)
            });
        },
        getCloseTriggerProps () {
            return normalize.button({
                ...parts.closeTrigger.attrs,
                dir: state.context.dir,
                id: dom.getCloseTriggerId(state.context),
                type: "button",
                onClick (event) {
                    if (event.defaultPrevented) return;
                    event.stopPropagation();
                    send("CLOSE");
                }
            });
        }
    };
}
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "dialog",
        initial: ctx.open ? "open" : "closed",
        context: {
            role: "dialog",
            renderedElements: {
                title: true,
                description: true
            },
            modal: true,
            trapFocus: true,
            preventScroll: true,
            closeOnInteractOutside: true,
            closeOnEscape: true,
            restoreFocus: true,
            ...ctx
        },
        created: [
            "setAlertDialogProps"
        ],
        watch: {
            open: [
                "toggleVisibility"
            ]
        },
        states: {
            open: {
                entry: [
                    "checkRenderedElements",
                    "syncZIndex"
                ],
                activities: [
                    "trackDismissableElement",
                    "trapFocus",
                    "preventScroll",
                    "hideContentBelow"
                ],
                on: {
                    "CONTROLLED.CLOSE": {
                        target: "closed"
                    },
                    CLOSE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    TOGGLE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ]
                }
            },
            closed: {
                on: {
                    "CONTROLLED.OPEN": {
                        target: "open"
                    },
                    OPEN: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen"
                            ]
                        }
                    ],
                    TOGGLE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen"
                            ]
                        }
                    ]
                }
            }
        }
    }, {
        guards: {
            isOpenControlled: (ctx2)=>!!ctx2["open.controlled"]
        },
        activities: {
            trackDismissableElement (ctx2, _evt, { send }) {
                const getContentEl = ()=>dom.getContentEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackDismissableElement"])(getContentEl, {
                    defer: true,
                    pointerBlocking: ctx2.modal,
                    exclude: [
                        dom.getTriggerEl(ctx2)
                    ],
                    onInteractOutside (event) {
                        ctx2.onInteractOutside?.(event);
                        if (!ctx2.closeOnInteractOutside) {
                            event.preventDefault();
                        }
                    },
                    persistentElements: ctx2.persistentElements,
                    onFocusOutside: ctx2.onFocusOutside,
                    onPointerDownOutside: ctx2.onPointerDownOutside,
                    onEscapeKeyDown (event) {
                        ctx2.onEscapeKeyDown?.(event);
                        if (!ctx2.closeOnEscape) {
                            event.preventDefault();
                        }
                    },
                    onDismiss () {
                        send({
                            type: "CLOSE",
                            src: "interact-outside"
                        });
                    }
                });
            },
            preventScroll (ctx2) {
                if (!ctx2.preventScroll) return;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$remove$2d$scroll$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["preventBodyScroll"])(dom.getDoc(ctx2));
            },
            trapFocus (ctx2) {
                if (!ctx2.trapFocus || !ctx2.modal) return;
                let trap;
                const cleanup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nextTick"])(()=>{
                    const contentEl = dom.getContentEl(ctx2);
                    if (!contentEl) return;
                    trap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$focus$2d$trap$2f$dist$2f$focus$2d$trap$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createFocusTrap"])(contentEl, {
                        document: dom.getDoc(ctx2),
                        escapeDeactivates: false,
                        preventScroll: true,
                        fallbackFocus: contentEl,
                        returnFocusOnDeactivate: !!ctx2.restoreFocus,
                        allowOutsideClick: true,
                        initialFocus: ctx2.initialFocusEl?.() ?? void 0,
                        setReturnFocus (triggerEl) {
                            return ctx2.finalFocusEl?.() ?? triggerEl;
                        }
                    });
                    try {
                        trap.activate();
                    } catch  {}
                });
                return ()=>{
                    trap?.deactivate();
                    cleanup();
                };
            },
            hideContentBelow (ctx2) {
                if (!ctx2.modal) return;
                const getElements = ()=>[
                        dom.getContentEl(ctx2)
                    ];
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$aria$2d$hidden$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaHidden"])(getElements, {
                    defer: true
                });
            }
        },
        actions: {
            setAlertDialogProps (ctx2) {
                if (ctx2.role !== "alertdialog") return;
                ctx2.initialFocusEl || (ctx2.initialFocusEl = ()=>dom.getCloseTriggerEl(ctx2));
                ctx2.closeOnInteractOutside = false;
            },
            checkRenderedElements (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    ctx2.renderedElements.title = !!dom.getTitleEl(ctx2);
                    ctx2.renderedElements.description = !!dom.getDescriptionEl(ctx2);
                });
            },
            syncZIndex (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const contentEl = dom.getContentEl(ctx2);
                    if (!contentEl) return;
                    const win = dom.getWin(ctx2);
                    const styles = win.getComputedStyle(contentEl);
                    const elems = [
                        dom.getPositionerEl(ctx2),
                        dom.getBackdropEl(ctx2)
                    ];
                    elems.forEach((node)=>{
                        node?.style.setProperty("--z-index", styles.zIndex);
                    });
                });
            },
            invokeOnClose (ctx2) {
                ctx2.onOpenChange?.({
                    open: false
                });
            },
            invokeOnOpen (ctx2) {
                ctx2.onOpenChange?.({
                    open: true
                });
            },
            toggleVisibility (ctx2, evt, { send }) {
                send({
                    type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
                    previousEvent: evt
                });
            }
        }
    });
}
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "aria-label",
    "closeOnEscape",
    "closeOnInteractOutside",
    "dir",
    "finalFocusEl",
    "getRootNode",
    "getRootNode",
    "id",
    "id",
    "ids",
    "initialFocusEl",
    "modal",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "open.controlled",
    "open",
    "persistentElements",
    "preventScroll",
    "restoreFocus",
    "role",
    "trapFocus"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
;
}}),
"[project]/node_modules/@zag-js/dialog/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as dialogAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "dialogAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dialog$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dialog/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/editable/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$interact$2d$outside$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/interact-outside/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
// src/editable.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("editable").parts("root", "area", "label", "preview", "input", "editTrigger", "submitTrigger", "cancelTrigger", "control");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `editable:${ctx.id}`,
    getAreaId: (ctx)=>ctx.ids?.area ?? `editable:${ctx.id}:area`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `editable:${ctx.id}:label`,
    getPreviewId: (ctx)=>ctx.ids?.preview ?? `editable:${ctx.id}:preview`,
    getInputId: (ctx)=>ctx.ids?.input ?? `editable:${ctx.id}:input`,
    getControlId: (ctx)=>ctx.ids?.control ?? `editable:${ctx.id}:control`,
    getSubmitTriggerId: (ctx)=>ctx.ids?.submitTrigger ?? `editable:${ctx.id}:submit`,
    getCancelTriggerId: (ctx)=>ctx.ids?.cancelTrigger ?? `editable:${ctx.id}:cancel`,
    getEditTriggerId: (ctx)=>ctx.ids?.editTrigger ?? `editable:${ctx.id}:edit`,
    getInputEl: (ctx)=>dom.getById(ctx, dom.getInputId(ctx)),
    getPreviewEl: (ctx)=>dom.getById(ctx, dom.getPreviewId(ctx)),
    getSubmitTriggerEl: (ctx)=>dom.getById(ctx, dom.getSubmitTriggerId(ctx)),
    getCancelTriggerEl: (ctx)=>dom.getById(ctx, dom.getCancelTriggerId(ctx)),
    getEditTriggerEl: (ctx)=>dom.getById(ctx, dom.getEditTriggerId(ctx))
});
// src/editable.connect.ts
function connect(state, send, normalize) {
    const disabled = state.context.disabled;
    const interactive = state.context.isInteractive;
    const readOnly = state.context.readOnly;
    const invalid = state.context.invalid;
    const autoResize = state.context.autoResize;
    const translations = state.context.translations;
    const editing = state.matches("edit");
    const placeholderProp = state.context.placeholder;
    const placeholder = typeof placeholderProp === "string" ? {
        edit: placeholderProp,
        preview: placeholderProp
    } : placeholderProp;
    const value = state.context.value;
    const empty = value.trim() === "";
    const valueText = empty ? placeholder?.preview ?? "" : value;
    return {
        editing,
        empty,
        value,
        valueText,
        setValue (value2) {
            send({
                type: "VALUE.SET",
                value: value2,
                src: "setValue"
            });
        },
        clearValue () {
            send({
                type: "VALUE.SET",
                value: "",
                src: "clearValue"
            });
        },
        edit () {
            if (!interactive) return;
            send("EDIT");
        },
        cancel () {
            if (!interactive) return;
            send("CANCEL");
        },
        submit () {
            if (!interactive) return;
            send("SUBMIT");
        },
        getRootProps () {
            return normalize.element({
                ...parts.root.attrs,
                id: dom.getRootId(state.context),
                dir: state.context.dir
            });
        },
        getAreaProps () {
            return normalize.element({
                ...parts.area.attrs,
                id: dom.getAreaId(state.context),
                dir: state.context.dir,
                style: autoResize ? {
                    display: "inline-grid"
                } : void 0,
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(editing),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-placeholder-shown": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(empty)
            });
        },
        getLabelProps () {
            return normalize.label({
                ...parts.label.attrs,
                id: dom.getLabelId(state.context),
                dir: state.context.dir,
                htmlFor: dom.getInputId(state.context),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(editing),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                onClick () {
                    if (editing) return;
                    const previewEl = dom.getPreviewEl(state.context);
                    previewEl?.focus({
                        preventScroll: true
                    });
                }
            });
        },
        getInputProps () {
            return normalize.input({
                ...parts.input.attrs,
                dir: state.context.dir,
                "aria-label": translations.input,
                name: state.context.name,
                form: state.context.form,
                id: dom.getInputId(state.context),
                hidden: autoResize ? void 0 : !editing,
                placeholder: placeholder?.edit,
                maxLength: state.context.maxLength,
                required: state.context.required,
                disabled,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                readOnly,
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(readOnly),
                "aria-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaAttr"])(invalid),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-autoresize": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(autoResize),
                defaultValue: value,
                size: autoResize ? 1 : void 0,
                onChange (event) {
                    send({
                        type: "VALUE.SET",
                        src: "input.change",
                        value: event.currentTarget.value
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isComposingEvent"])(event)) return;
                    const keyMap = {
                        Escape () {
                            send("CANCEL");
                            event.preventDefault();
                        },
                        Enter (event2) {
                            if (!state.context.submitOnEnter) return;
                            const { localName } = event2.currentTarget;
                            if (localName === "textarea") {
                                const submitMod = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isApple"])() ? event2.metaKey : event2.ctrlKey;
                                if (!submitMod) return;
                                send({
                                    type: "SUBMIT",
                                    src: "keydown.enter"
                                });
                                return;
                            }
                            if (localName === "input" && !event2.shiftKey && !event2.metaKey) {
                                send({
                                    type: "SUBMIT",
                                    src: "keydown.enter"
                                });
                                event2.preventDefault();
                            }
                        }
                    };
                    const exec = keyMap[event.key];
                    if (exec) {
                        exec(event);
                    }
                },
                style: autoResize ? {
                    gridArea: "1 / 1 / auto / auto",
                    visibility: !editing ? "hidden" : void 0
                } : void 0
            });
        },
        getPreviewProps () {
            return normalize.element({
                id: dom.getPreviewId(state.context),
                ...parts.preview.attrs,
                dir: state.context.dir,
                "data-placeholder-shown": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(empty),
                "aria-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaAttr"])(readOnly),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "aria-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaAttr"])(disabled),
                "aria-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaAttr"])(invalid),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "aria-label": translations.edit,
                "data-autoresize": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(autoResize),
                children: valueText,
                hidden: autoResize ? void 0 : editing,
                tabIndex: interactive ? 0 : void 0,
                onClick () {
                    if (!interactive) return;
                    if (state.context.activationMode !== "click") return;
                    send({
                        type: "EDIT",
                        src: "click"
                    });
                },
                onFocus () {
                    if (!interactive) return;
                    if (state.context.activationMode !== "focus") return;
                    send({
                        type: "EDIT",
                        src: "focus"
                    });
                },
                onDoubleClick (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    if (state.context.activationMode !== "dblclick") return;
                    send({
                        type: "EDIT",
                        src: "dblclick"
                    });
                },
                style: autoResize ? {
                    whiteSpace: "pre",
                    userSelect: "none",
                    gridArea: "1 / 1 / auto / auto",
                    visibility: editing ? "hidden" : void 0,
                    // in event the preview overflow's the parent element
                    overflow: "hidden",
                    textOverflow: "ellipsis"
                } : void 0
            });
        },
        getEditTriggerProps () {
            return normalize.button({
                ...parts.editTrigger.attrs,
                id: dom.getEditTriggerId(state.context),
                dir: state.context.dir,
                "aria-label": translations.edit,
                hidden: editing,
                type: "button",
                disabled,
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    send({
                        type: "EDIT",
                        src: "edit.click"
                    });
                }
            });
        },
        getControlProps () {
            return normalize.element({
                id: dom.getControlId(state.context),
                ...parts.control.attrs,
                dir: state.context.dir
            });
        },
        getSubmitTriggerProps () {
            return normalize.button({
                ...parts.submitTrigger.attrs,
                dir: state.context.dir,
                id: dom.getSubmitTriggerId(state.context),
                "aria-label": translations.submit,
                hidden: !editing,
                disabled,
                type: "button",
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    send({
                        type: "SUBMIT",
                        src: "submit.click"
                    });
                }
            });
        },
        getCancelTriggerProps () {
            return normalize.button({
                ...parts.cancelTrigger.attrs,
                dir: state.context.dir,
                "aria-label": translations.cancel,
                id: dom.getCancelTriggerId(state.context),
                hidden: !editing,
                type: "button",
                disabled,
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    send({
                        type: "CANCEL",
                        src: "cancel.click"
                    });
                }
            });
        }
    };
}
var submitOnEnter = (ctx)=>[
        "both",
        "enter"
    ].includes(ctx.submitMode);
var submitOnBlur = (ctx)=>[
        "both",
        "blur"
    ].includes(ctx.submitMode);
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "editable",
        initial: ctx.edit ? "edit" : "preview",
        entry: ctx.edit ? [
            "focusInput"
        ] : void 0,
        context: {
            activationMode: "focus",
            submitMode: "both",
            value: "",
            previousValue: "",
            selectOnFocus: true,
            disabled: false,
            readOnly: false,
            ...ctx,
            translations: {
                input: "editable input",
                edit: "edit",
                submit: "submit",
                cancel: "cancel",
                ...ctx.translations
            }
        },
        watch: {
            value: [
                "syncInputValue"
            ],
            edit: [
                "toggleEditing"
            ]
        },
        computed: {
            submitOnEnter,
            submitOnBlur,
            isInteractive: (ctx2)=>!(ctx2.disabled || ctx2.readOnly)
        },
        on: {
            "VALUE.SET": {
                actions: "setValue"
            }
        },
        states: {
            preview: {
                // https://bugzilla.mozilla.org/show_bug.cgi?id=559561
                entry: [
                    "blurInputIfNeeded"
                ],
                on: {
                    "CONTROLLED.EDIT": {
                        target: "edit",
                        actions: [
                            "setPreviousValue",
                            "focusInput"
                        ]
                    },
                    EDIT: [
                        {
                            guard: "isEditControlled",
                            actions: [
                                "invokeOnEdit"
                            ]
                        },
                        {
                            target: "edit",
                            actions: [
                                "setPreviousValue",
                                "focusInput",
                                "invokeOnEdit"
                            ]
                        }
                    ]
                }
            },
            edit: {
                activities: [
                    "trackInteractOutside"
                ],
                on: {
                    "CONTROLLED.PREVIEW": [
                        {
                            guard: "isSubmitEvent",
                            target: "preview",
                            actions: [
                                "setPreviousValue",
                                "restoreFocus",
                                "invokeOnSubmit"
                            ]
                        },
                        {
                            target: "preview",
                            actions: [
                                "revertValue",
                                "restoreFocus",
                                "invokeOnCancel"
                            ]
                        }
                    ],
                    CANCEL: [
                        {
                            guard: "isEditControlled",
                            actions: [
                                "invokeOnPreview"
                            ]
                        },
                        {
                            target: "preview",
                            actions: [
                                "revertValue",
                                "restoreFocus",
                                "invokeOnCancel",
                                "invokeOnPreview"
                            ]
                        }
                    ],
                    SUBMIT: [
                        {
                            guard: "isEditControlled",
                            actions: [
                                "invokeOnPreview"
                            ]
                        },
                        {
                            target: "preview",
                            actions: [
                                "setPreviousValue",
                                "restoreFocus",
                                "invokeOnSubmit",
                                "invokeOnPreview"
                            ]
                        }
                    ]
                }
            }
        }
    }, {
        guards: {
            isEditControlled: (ctx2)=>!!ctx2["edit.controlled"],
            isSubmitEvent: (_ctx, evt)=>evt.previousEvent?.type === "SUBMIT"
        },
        activities: {
            trackInteractOutside (ctx2, _evt, { send }) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$interact$2d$outside$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackInteractOutside"])(dom.getInputEl(ctx2), {
                    exclude (target) {
                        const ignore = [
                            dom.getCancelTriggerEl(ctx2),
                            dom.getSubmitTriggerEl(ctx2)
                        ];
                        return ignore.some((el)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["contains"])(el, target));
                    },
                    onFocusOutside: ctx2.onFocusOutside,
                    onPointerDownOutside: ctx2.onPointerDownOutside,
                    onInteractOutside (event) {
                        ctx2.onInteractOutside?.(event);
                        if (event.defaultPrevented) return;
                        const { focusable } = event.detail;
                        send({
                            type: submitOnBlur(ctx2) ? "SUBMIT" : "CANCEL",
                            src: "interact-outside",
                            focusable
                        });
                    }
                });
            }
        },
        actions: {
            restoreFocus (ctx2, evt) {
                if (evt.focusable) return;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const finalEl = ctx2.finalFocusEl?.() ?? dom.getEditTriggerEl(ctx2);
                    finalEl?.focus({
                        preventScroll: true
                    });
                });
            },
            focusInput (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const inputEl = dom.getInputEl(ctx2);
                    if (!inputEl) return;
                    if (ctx2.selectOnFocus) {
                        inputEl.select();
                    } else {
                        inputEl.focus({
                            preventScroll: true
                        });
                    }
                });
            },
            invokeOnCancel (ctx2) {
                ctx2.onValueRevert?.({
                    value: ctx2.previousValue
                });
            },
            invokeOnSubmit (ctx2) {
                ctx2.onValueCommit?.({
                    value: ctx2.value
                });
            },
            invokeOnEdit (ctx2) {
                ctx2.onEditChange?.({
                    edit: true
                });
            },
            invokeOnPreview (ctx2) {
                ctx2.onEditChange?.({
                    edit: false
                });
            },
            toggleEditing (ctx2, evt, { send }) {
                send({
                    type: ctx2.edit ? "CONTROLLED.EDIT" : "CONTROLLED.PREVIEW",
                    previousEvent: evt
                });
            },
            syncInputValue (ctx2) {
                sync.value(ctx2);
            },
            setValue (ctx2, evt) {
                const value = ctx2.maxLength != null ? evt.value.slice(0, ctx2.maxLength) : evt.value;
                set.value(ctx2, value);
            },
            setPreviousValue (ctx2) {
                ctx2.previousValue = ctx2.value;
            },
            revertValue (ctx2) {
                set.value(ctx2, ctx2.previousValue);
            },
            blurInputIfNeeded (ctx2) {
                dom.getInputEl(ctx2)?.blur();
            }
        }
    });
}
var sync = {
    value: (ctx)=>{
        const inputEl = dom.getInputEl(ctx);
        dom.setValue(inputEl, ctx.value);
    }
};
var invoke = {
    change (ctx) {
        ctx.onValueChange?.({
            value: ctx.value
        });
        sync.value(ctx);
    }
};
var set = {
    value (ctx, value) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value, value)) return;
        ctx.value = value;
        invoke.change(ctx);
    }
};
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "activationMode",
    "autoResize",
    "dir",
    "disabled",
    "finalFocusEl",
    "form",
    "getRootNode",
    "id",
    "ids",
    "invalid",
    "maxLength",
    "name",
    "onEditChange",
    "onFocusOutside",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueCommit",
    "onValueRevert",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "edit",
    "edit.controlled",
    "submitMode",
    "translations",
    "value"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
;
}}),
"[project]/node_modules/@zag-js/editable/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as editableAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "editableAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$editable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$editable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/editable/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/file-utils/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/data-url-to-blob.ts
__turbopack_esm__({
    "dataURItoBlob": (()=>dataURItoBlob),
    "downloadFile": (()=>downloadFile),
    "getAcceptAttrString": (()=>getAcceptAttrString),
    "getFileDataUrl": (()=>getFileDataUrl),
    "getTotalFileSize": (()=>getTotalFileSize),
    "isFileEqual": (()=>isFileEqual),
    "isMSEdge": (()=>isMSEdge),
    "isValidFileSize": (()=>isValidFileSize),
    "isValidFileType": (()=>isValidFileType)
});
function dataURItoBlob(uri) {
    const binary = atob(uri.split(",")[1]);
    const mimeString = uri.split(",")[0].split(":")[1].split(";")[0];
    const buffer = new ArrayBuffer(binary.length);
    const intArray = new Uint8Array(buffer);
    for(let i = 0; i < binary.length; i++){
        intArray[i] = binary.charCodeAt(i);
    }
    return new Blob([
        buffer
    ], {
        type: mimeString
    });
}
// src/download-file.ts
function isMSEdge(win) {
    return Boolean(win.navigator && win.navigator.msSaveOrOpenBlob);
}
function downloadFile(options) {
    const { file, win, type, name } = options;
    const doc = win.document;
    const obj = typeof file === "string" ? new Blob([
        file
    ], {
        type
    }) : file;
    const fileName = typeof file === "string" ? name : file instanceof File ? file.name : void 0;
    if (isMSEdge(win)) {
        win.navigator.msSaveOrOpenBlob(obj, fileName || "file-download");
        return;
    }
    const url = win.URL.createObjectURL(obj);
    const anchor = doc.createElement("a");
    anchor.style.display = "none";
    anchor.href = url;
    anchor.rel = "noopener";
    anchor.download = fileName || "file-download";
    doc.documentElement.appendChild(anchor);
    anchor.click();
    setTimeout(()=>{
        win.URL.revokeObjectURL(url);
        anchor.remove();
    }, 0);
}
// src/get-accept-attr.ts
function isMIMEType(v) {
    return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
    return /^.*\.[\w]+$/.test(v);
}
var isValidMIME = (v)=>isMIMEType(v) || isExt(v);
function getAcceptAttrString(accept) {
    if (!accept) return;
    if (typeof accept === "string") {
        return accept;
    }
    if (Array.isArray(accept)) {
        return accept.filter(isValidMIME).join(",");
    }
    return Object.entries(accept).reduce((a, [mimeType, ext])=>[
            ...a,
            mimeType,
            ...ext
        ], []).filter(isValidMIME).join(",");
}
// src/get-file-data-url.ts
var getFileDataUrl = async (file)=>{
    const reader = new FileReader();
    return new Promise((resolve, reject)=>{
        reader.onerror = ()=>{
            reader.abort();
            reject(new Error("There was an error reading a file"));
        };
        reader.onloadend = ()=>{
            const { result } = reader;
            if (result instanceof ArrayBuffer) {
                reject(new Error("Expected DataURL as string from Blob/File, got ArrayBuffer"));
            } else {
                resolve(result || void 0);
            }
        };
        reader.readAsDataURL(file);
    });
};
// src/get-total-file-size.ts
var getTotalFileSize = (files)=>{
    return files.reduce((acc, file)=>acc + file.size, 0);
};
// src/is-file-equal.ts
var isFileEqual = (file1, file2)=>{
    return file1.name === file2.name && file1.size === file2.size && file1.type === file2.type;
};
// src/is-valid-file-size.ts
var isDefined = (v)=>v !== void 0 && v !== null;
function isValidFileSize(file, minSize, maxSize) {
    if (isDefined(file.size)) {
        if (isDefined(minSize) && isDefined(maxSize)) {
            if (file.size > maxSize) return [
                false,
                "FILE_TOO_LARGE"
            ];
            if (file.size < minSize) return [
                false,
                "FILE_TOO_SMALL"
            ];
        } else if (isDefined(minSize) && file.size < minSize) {
            return [
                false,
                "FILE_TOO_SMALL"
            ];
        } else if (isDefined(maxSize) && file.size > maxSize) {
            return [
                false,
                "FILE_TOO_LARGE"
            ];
        }
    }
    return [
        true,
        null
    ];
}
// src/is-valid-file-type.ts
function isFileAccepted(file, accept) {
    if (file && accept) {
        const types = Array.isArray(accept) ? accept : accept.split(",");
        const fileName = file.name || "";
        const mimeType = (file.type || "").toLowerCase();
        const baseMimeType = mimeType.replace(/\/.*$/, "");
        return types.some((type)=>{
            const validType = type.trim().toLowerCase();
            if (validType.charAt(0) === ".") {
                return fileName.toLowerCase().endsWith(validType);
            }
            if (validType.endsWith("/*")) {
                return baseMimeType === validType.replace(/\/.*$/, "");
            }
            return mimeType === validType;
        });
    }
    return true;
}
function isValidFileType(file, accept) {
    const isAcceptable = file.type === "application/x-moz-file" || isFileAccepted(file, accept);
    return [
        isAcceptable,
        isAcceptable ? null : "FILE_INVALID_TYPE"
    ];
}
;
}}),
"[project]/node_modules/@zag-js/i18n-utils/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "filter": (()=>filter),
    "formatBytes": (()=>formatBytes),
    "formatDate": (()=>formatDate),
    "formatList": (()=>formatList),
    "formatNumber": (()=>formatNumber),
    "formatRelativeTime": (()=>formatRelativeTime),
    "getDefaultLocale": (()=>getDefaultLocale),
    "getLocaleDir": (()=>getLocaleDir),
    "isRTL": (()=>isRTL),
    "trackLocale": (()=>trackLocale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
;
// src/cache.ts
function i18nCache(Ins) {
    const formatterCache = /* @__PURE__ */ new Map();
    return function create(locale, options) {
        const cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : "");
        if (formatterCache.has(cacheKey)) {
            return formatterCache.get(cacheKey);
        }
        let formatter = new Ins(locale, options);
        formatterCache.set(cacheKey, formatter);
        return formatter;
    };
}
// src/filter.ts
var collatorCache = i18nCache(Intl.Collator);
function filter(options) {
    const { locale, ...rest } = options || {};
    const collator = collatorCache(locale || "en-US", {
        usage: "search",
        ...rest
    });
    function normalize(string) {
        string = string.normalize("NFC");
        if (collator.resolvedOptions().ignorePunctuation) {
            string = string.replace(/\p{P}/gu, "");
        }
        return string;
    }
    function startsWith(string, substring) {
        if (substring.length === 0) return true;
        string = normalize(string);
        substring = normalize(substring);
        return collator.compare(string.slice(0, substring.length), substring) === 0;
    }
    function endsWith(string, substring) {
        if (substring.length === 0) return true;
        string = normalize(string);
        substring = normalize(substring);
        return collator.compare(string.slice(-substring.length), substring) === 0;
    }
    function contains(string, substring) {
        if (substring.length === 0) return true;
        string = normalize(string);
        substring = normalize(substring);
        let scan = 0;
        let sliceLen = substring.length;
        for(; scan + sliceLen <= string.length; scan++){
            let slice = string.slice(scan, scan + sliceLen);
            if (collator.compare(substring, slice) === 0) {
                return true;
            }
        }
        return false;
    }
    return {
        startsWith,
        endsWith,
        contains
    };
}
// src/format-number.ts
var getNumberFormatter = i18nCache(Intl.NumberFormat);
function formatNumber(v, locale, options = {}) {
    const formatter = getNumberFormatter(locale, options);
    return formatter.format(v);
}
// src/format-bytes.ts
var bitPrefixes = [
    "",
    "kilo",
    "mega",
    "giga",
    "tera"
];
var bytePrefixes = [
    "",
    "kilo",
    "mega",
    "giga",
    "tera",
    "peta"
];
var formatBytes = (bytes, locale = "en-US", options = {})=>{
    if (isNaN(bytes)) return "";
    if (bytes === 0) return "0 B";
    const { unit = "byte", unitDisplay = "short" } = options;
    const prefix = unit === "bit" ? bitPrefixes : bytePrefixes;
    const index = Math.max(0, Math.min(Math.floor(Math.log10(bytes) / 3), prefix.length - 1));
    const _unit = prefix[index] + unit;
    const _unitDisplay = unitDisplay || "short";
    const v = parseFloat((bytes / Math.pow(1e3, index)).toPrecision(3));
    return formatNumber(v, locale, {
        style: "unit",
        unit: _unit,
        unitDisplay: _unitDisplay
    });
};
// src/format-date.ts
var symbols = "\\s|\\.|-|/|\\\\|,|\\$|\\!|\\?|:|;";
function createRegEx(sign) {
    return new RegExp("(^|>|" + symbols + ")(" + sign + ")($|<|" + symbols + ")", "g");
}
var FORMATS = [
    "G",
    "GG",
    "GGG",
    "GGGG",
    "GGGGG",
    "y",
    "yo",
    "yy",
    "yyy",
    "yyyy",
    "Y",
    "Yo",
    "YY",
    "YYY",
    "YYYY",
    "Q",
    "Qo",
    "QQ",
    "QQQ",
    "QQQQ",
    "QQQQQ",
    "M",
    "Mo",
    "MM",
    "MMM",
    "MMMM",
    "MMMMM",
    "E",
    "EE",
    "EEE",
    "EEEE",
    "EEEEE",
    "EEEEEE",
    "a",
    "aa",
    "aaa",
    "aaaa",
    "aaaaa",
    "d",
    "do",
    "dd",
    "D",
    "Do",
    "DD",
    "DDD",
    "w",
    "wo",
    "ww",
    "s",
    "so",
    "ss",
    "m",
    "mo",
    "mm",
    "h",
    "ho",
    "hh",
    "H",
    "Ho",
    "HH",
    "z",
    "zz",
    "zzz",
    "zzzz",
    "T"
];
function ordinal(num) {
    const n = typeof num === "string" ? parseFloat(num) : num;
    let suffix = "th";
    if (n % 10 === 1 && n % 100 !== 11) {
        suffix = "st";
    } else if (n % 10 === 2 && n % 100 !== 12) {
        suffix = "nd";
    } else if (n % 10 === 3 && n % 100 !== 13) {
        suffix = "rd";
    }
    return `${n}${suffix}`;
}
function pad(num, length) {
    return String(num).padStart(length, "0");
}
function zone(str) {
    return str.split(/AM|PM/)[1].trim();
}
function getFormat(date, options) {
    const { locale, format, timeZone } = options;
    switch(format){
        // era
        case "G":
        case "GG":
        case "GGG":
            return date.toLocaleString(locale, {
                era: "short"
            });
        case "GGGG":
            return date.toLocaleString(locale, {
                era: "long"
            });
        case "GGGGG":
            return date.toLocaleString(locale, {
                era: "narrow"
            });
        // year
        case "y":
        case "Y":
            return date.getFullYear();
        case "yo":
        case "Yo":
            return ordinal(date.toLocaleString(locale, {
                year: "numeric"
            }));
        case "yy":
        case "YY":
            return date.toLocaleString(locale, {
                year: "2-digit"
            });
        case "yyy":
        case "YYY":
            return date.toLocaleString(locale, {
                year: "numeric"
            }).padStart(3, "0");
        case "yyyy":
        case "YYYY":
            return date.toLocaleString(locale, {
                year: "numeric"
            }).padStart(4, "0");
        // quarter
        case "Q":
        case "QQQQQ":
            return Math.ceil((date.getMonth() + 1) / 3);
        case "Qo":
            return ordinal(Math.ceil((date.getMonth() + 1) / 3));
        case "QQ":
            return pad(Math.ceil((date.getMonth() + 1) / 3), 2);
        case "QQQ":
            return `Q${Math.ceil((date.getMonth() + 1) / 3)}`;
        case "QQQQ":
            {
                const base = ordinal(String(Math.ceil((date.getMonth() + 1) / 3)));
                return `${base} quarter`;
            }
        // month
        case "M":
            return date.getMonth() + 1;
        case "Mo":
            return ordinal(date.getMonth() + 1);
        case "MM":
            return date.toLocaleString(locale, {
                month: "2-digit"
            });
        case "MMM":
            return date.toLocaleString(locale, {
                month: "short"
            });
        case "MMMM":
            return date.toLocaleString(locale, {
                month: "long"
            });
        case "MMMMM":
            return date.toLocaleString(locale, {
                month: "narrow"
            });
        // week
        case "w":
            return Math.ceil(date.getDate() / 7);
        case "wo":
            return ordinal(Math.ceil(date.getDate() / 7));
        case "ww":
            return pad(Math.ceil(date.getDate() / 7), 2);
        // day
        case "d":
        case "D":
            return date.getDate();
        case "do":
        case "Do":
            return ordinal(date.getDate());
        case "dd":
        case "DD":
            return date.toLocaleString(locale, {
                day: "2-digit"
            });
        case "DDD":
            return pad(date.getDate(), 3);
        // weekday
        case "E":
        case "EE":
        case "EEE":
            return date.toLocaleString(locale, {
                weekday: "short"
            });
        case "EEEE":
            return date.toLocaleString(locale, {
                weekday: "long"
            });
        case "EEEEE":
            return date.toLocaleString(locale, {
                weekday: "narrow"
            });
        case "EEEEEE":
            return date.toLocaleString(locale, {
                weekday: "short"
            }).slice(0, 2);
        // hour
        case "h":
            return date.toLocaleString(locale, {
                hour: "numeric",
                hour12: true
            });
        case "ho":
            return ordinal(date.toLocaleString(locale, {
                hour: "2-digit",
                hour12: true
            }));
        case "hh":
            return date.toLocaleString(locale, {
                hour: "2-digit",
                hour12: true
            });
        case "H":
            return date.toLocaleString(locale, {
                hour: "numeric",
                hour12: false
            });
        case "Ho":
            return ordinal(+date.toLocaleString(locale, {
                hour: "numeric",
                hour12: false
            }));
        case "HH":
            return date.toLocaleString(locale, {
                hour: "2-digit",
                hour12: false
            });
        // minute
        case "m":
            return date.toLocaleString(locale, {
                minute: "numeric"
            });
        case "mo":
            return ordinal(date.toLocaleString(locale, {
                minute: "numeric"
            }));
        case "mm":
            return date.toLocaleString(locale, {
                minute: "2-digit"
            });
        // second
        case "s":
            return date.toLocaleString(locale, {
                second: "numeric"
            });
        case "so":
            return ordinal(date.toLocaleString(locale, {
                second: "numeric"
            }));
        case "ss":
            return date.toLocaleString(locale, {
                second: "2-digit"
            });
        // timestamp
        case "T":
            return date.getTime();
        // day period
        case "a":
        case "aa":
        case "aaa":
            return date.toLocaleString(locale, {
                hour: "numeric",
                hour12: true
            }).toLocaleUpperCase();
        case "aaaa":
            return date.toLocaleString(locale, {
                hour: "numeric",
                hour12: true
            }).toLocaleLowerCase();
        case "aaaaa":
            return date.toLocaleString(locale, {
                hour: "numeric",
                hour12: true
            }).charAt(0);
        // TODO:Revise this
        case "z":
        case "zz":
        case "zzz":
            {
                return zone(date.toLocaleString(locale, {
                    timeZone,
                    timeZoneName: "shortOffset"
                }));
            }
        case "zzzz":
            return zone(date.toLocaleString(locale, {
                timeZone,
                timeZoneName: "longOffset"
            }));
        default:
            throw new Error(`Unknown format: ${format}`);
    }
}
function formatDate(date, format, locale, timeZone) {
    let result = format;
    for (const key of FORMATS){
        const res = getFormat(date, {
            locale,
            format: key,
            timeZone
        });
        result = result.replace(createRegEx(key), "$1" + res + "$3");
    }
    return result;
}
// src/format-list.ts
var getListFormatter = i18nCache(Intl.ListFormat);
function formatList(list, locale, options = {}) {
    const formatter = getListFormatter(locale, options);
    return formatter.format(list);
}
// src/format-relative-time.ts
var getRelativeTimeFormatter = i18nCache(Intl.RelativeTimeFormat);
function formatRelativeTime(value, locale, options = {}) {
    const rtf = getRelativeTimeFormatter(locale, options);
    const now = /* @__PURE__ */ new Date();
    const diff = getDistance(now, value);
    if (diff.years > 0) return rtf.format(diff.years * diff.sign, "year");
    if (diff.months > 0) return rtf.format(diff.months * diff.sign, "month");
    if (diff.weeks > 0) return rtf.format(diff.weeks * diff.sign, "week");
    if (diff.days > 0) return rtf.format(diff.days * diff.sign, "day");
    if (diff.hours > 0) return rtf.format(diff.hours * diff.sign, "hour");
    if (diff.minutes > 0) return rtf.format(diff.minutes * diff.sign, "minute");
    return rtf.format(diff.seconds * diff.sign, "second");
}
var SECOND_TO_MS = 1e3;
var MINUTE_TO_MS = 1e3 * 60;
var HOUR_TO_MS = 1e3 * 60 * 60;
var DAY_TO_MS = 1e3 * 60 * 60 * 24;
var WEEK_TO_MS = 1e3 * 60 * 60 * 24 * 7;
var MONTH_TO_MS = 1e3 * 60 * 60 * 24 * 30;
var YEAR_TO_MS = 1e3 * 60 * 60 * 24 * 365;
function getDistance(startDate, endDate) {
    const endTime = endDate.getTime();
    const startTime = startDate.getTime();
    const distance = Math.abs(endTime - startTime);
    return {
        sign: Math.sign(endTime - startTime),
        days: Math.floor(distance / DAY_TO_MS),
        hours: Math.floor(distance % DAY_TO_MS / HOUR_TO_MS),
        minutes: Math.floor(distance % HOUR_TO_MS / MINUTE_TO_MS),
        seconds: Math.floor(distance % MINUTE_TO_MS / SECOND_TO_MS),
        weeks: Math.floor(distance / WEEK_TO_MS),
        months: Math.floor(distance / MONTH_TO_MS),
        years: Math.floor(distance / YEAR_TO_MS)
    };
}
// src/is-rtl.ts
var RTL_SCRIPTS = /* @__PURE__ */ new Set([
    "Avst",
    "Arab",
    "Armi",
    "Syrc",
    "Samr",
    "Mand",
    "Thaa",
    "Mend",
    "Nkoo",
    "Adlm",
    "Rohg",
    "Hebr"
]);
var RTL_LANGS = /* @__PURE__ */ new Set([
    "ae",
    "ar",
    "arc",
    "bcc",
    "bqi",
    "ckb",
    "dv",
    "fa",
    "glk",
    "he",
    "ku",
    "mzn",
    "nqo",
    "pnb",
    "ps",
    "sd",
    "ug",
    "ur",
    "yi"
]);
function isRTL(locale) {
    if (Intl.Locale) {
        const script = new Intl.Locale(locale).maximize().script ?? "";
        return RTL_SCRIPTS.has(script);
    }
    const lang = locale.split("-")[0];
    return RTL_LANGS.has(lang);
}
function getLocaleDir(locale) {
    return isRTL(locale) ? "rtl" : "ltr";
}
// src/locale.ts
function getDefaultLocale() {
    let locale = typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
    return {
        locale,
        dir: isRTL(locale) ? "rtl" : "ltr"
    };
}
function trackLocale(options = {}) {
    const { getRootNode, onLocaleChange } = options;
    onLocaleChange?.(getDefaultLocale());
    const handleLocaleChange = ()=>{
        onLocaleChange?.(getDefaultLocale());
    };
    const win = getRootNode ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(getRootNode()) : window;
    win.addEventListener("languagechange", handleLocaleChange);
    return ()=>{
        win.removeEventListener("languagechange", handleLocaleChange);
    };
}
;
}}),
"[project]/node_modules/@zag-js/file-upload/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "itemProps": (()=>itemProps),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitItemProps": (()=>splitItemProps),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/store/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$file$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/file-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$i18n$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/i18n-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
;
;
;
;
;
;
;
// src/file-upload.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("file-upload").parts("root", "dropzone", "item", "itemDeleteTrigger", "itemGroup", "itemName", "itemPreview", "itemPreviewImage", "itemSizeText", "label", "trigger", "clearTrigger");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `file:${ctx.id}`,
    getDropzoneId: (ctx)=>ctx.ids?.dropzone ?? `file:${ctx.id}:dropzone`,
    getHiddenInputId: (ctx)=>ctx.ids?.hiddenInput ?? `file:${ctx.id}:input`,
    getTriggerId: (ctx)=>ctx.ids?.trigger ?? `file:${ctx.id}:trigger`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `file:${ctx.id}:label`,
    getItemId: (ctx, id)=>ctx.ids?.item?.(id) ?? `file:${ctx.id}:item:${id}`,
    getItemNameId: (ctx, id)=>ctx.ids?.itemName?.(id) ?? `file:${ctx.id}:item-name:${id}`,
    getItemSizeTextId: (ctx, id)=>ctx.ids?.itemSizeText?.(id) ?? `file:${ctx.id}:item-size:${id}`,
    getItemPreviewId: (ctx, id)=>ctx.ids?.itemPreview?.(id) ?? `file:${ctx.id}:item-preview:${id}`,
    getHiddenInputEl: (ctx)=>dom.getById(ctx, dom.getHiddenInputId(ctx)),
    getDropzoneEl: (ctx)=>dom.getById(ctx, dom.getDropzoneId(ctx))
});
function isEventWithFiles(event) {
    const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
    if (!event.dataTransfer) return !!target && "files" in target;
    return event.dataTransfer.types.some((type)=>{
        return type === "Files" || type === "application/x-moz-file";
    });
}
function isFilesWithinRange(ctx, incomingCount) {
    if (!ctx.multiple && incomingCount > 1) return false;
    if (!ctx.multiple && incomingCount + ctx.acceptedFiles.length === 2) return true;
    if (incomingCount + ctx.acceptedFiles.length > ctx.maxFiles) return false;
    return true;
}
function getFilesFromEvent(ctx, files) {
    const acceptedFiles = [];
    const rejectedFiles = [];
    files.forEach((file)=>{
        const [accepted, acceptError] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$file$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isValidFileType"])(file, ctx.acceptAttr);
        const [sizeMatch, sizeError] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$file$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isValidFileSize"])(file, ctx.minFileSize, ctx.maxFileSize);
        const validateErrors = ctx.validate?.(file);
        const valid = validateErrors ? validateErrors.length === 0 : true;
        if (accepted && sizeMatch && valid) {
            acceptedFiles.push(file);
        } else {
            const errors = [
                acceptError,
                sizeError
            ];
            if (!valid) errors.push(...validateErrors ?? []);
            rejectedFiles.push({
                file,
                errors: errors.filter(Boolean)
            });
        }
    });
    if (!isFilesWithinRange(ctx, acceptedFiles.length)) {
        acceptedFiles.forEach((file)=>{
            rejectedFiles.push({
                file,
                errors: [
                    "TOO_MANY_FILES"
                ]
            });
        });
        acceptedFiles.splice(0);
    }
    return {
        acceptedFiles,
        rejectedFiles
    };
}
// src/file-upload.connect.ts
function connect(state, send, normalize) {
    const disabled = state.context.disabled;
    const allowDrop = state.context.allowDrop;
    const translations = state.context.translations;
    const dragging = state.matches("dragging");
    const focused = state.matches("focused") && !disabled;
    return {
        dragging,
        focused,
        openFilePicker () {
            send("OPEN");
        },
        deleteFile (file) {
            send({
                type: "FILE.DELETE",
                file
            });
        },
        acceptedFiles: state.context.acceptedFiles,
        rejectedFiles: state.context.rejectedFiles,
        setFiles (files) {
            const count = files.length;
            send({
                type: "FILES.SET",
                files,
                count
            });
        },
        clearRejectedFiles () {
            send({
                type: "REJECTED_FILES.CLEAR"
            });
        },
        clearFiles () {
            send({
                type: "FILES.CLEAR"
            });
        },
        getFileSize (file) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$i18n$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["formatBytes"])(file.size, state.context.locale);
        },
        createFileUrl (file, cb) {
            const win = dom.getWin(state.context);
            const url = win.URL.createObjectURL(file);
            cb(url);
            return ()=>win.URL.revokeObjectURL(url);
        },
        getRootProps () {
            return normalize.element({
                ...parts.root.attrs,
                dir: state.context.dir,
                id: dom.getRootId(state.context),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-dragging": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(dragging)
            });
        },
        getDropzoneProps () {
            return normalize.element({
                ...parts.dropzone.attrs,
                dir: state.context.dir,
                id: dom.getDropzoneId(state.context),
                tabIndex: disabled ? void 0 : 0,
                role: "button",
                "aria-label": translations.dropzone,
                "aria-disabled": disabled,
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.invalid),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-dragging": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(dragging),
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isSelfTarget"])(event)) return;
                    if (event.key !== "Enter" && event.key !== " ") return;
                    send({
                        type: "DROPZONE.CLICK",
                        src: "keydown"
                    });
                },
                onClick (event) {
                    const isLabel = event.currentTarget.localName === "label";
                    if (isLabel) event.preventDefault();
                    send("DROPZONE.CLICK");
                },
                onDragOver (event) {
                    if (!allowDrop) return;
                    event.preventDefault();
                    event.stopPropagation();
                    try {
                        event.dataTransfer.dropEffect = "copy";
                    } catch  {}
                    const hasFiles = isEventWithFiles(event);
                    if (!hasFiles) return;
                    const count = event.dataTransfer.items.length;
                    send({
                        type: "DROPZONE.DRAG_OVER",
                        count
                    });
                },
                onDragLeave (event) {
                    if (!allowDrop || disabled) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["contains"])(event.currentTarget, event.relatedTarget)) return;
                    send({
                        type: "DROPZONE.DRAG_LEAVE"
                    });
                },
                onDrop (event) {
                    if (allowDrop) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    const hasFiles = isEventWithFiles(event);
                    if (disabled || !hasFiles) return;
                    send({
                        type: "DROPZONE.DROP",
                        files: Array.from(event.dataTransfer.files)
                    });
                },
                onFocus () {
                    send("DROPZONE.FOCUS");
                },
                onBlur () {
                    send("DROPZONE.BLUR");
                }
            });
        },
        getTriggerProps () {
            return normalize.button({
                ...parts.trigger.attrs,
                dir: state.context.dir,
                id: dom.getTriggerId(state.context),
                disabled,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.invalid),
                type: "button",
                onClick (event) {
                    if (disabled) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["contains"])(dom.getDropzoneEl(state.context), event.currentTarget)) {
                        event.stopPropagation();
                    }
                    send("OPEN");
                }
            });
        },
        getHiddenInputProps () {
            return normalize.input({
                id: dom.getHiddenInputId(state.context),
                tabIndex: -1,
                disabled,
                type: "file",
                required: state.context.required,
                capture: state.context.capture,
                name: state.context.name,
                accept: state.context.acceptAttr,
                webkitdirectory: state.context.directory ? "" : void 0,
                multiple: state.context.multiple || state.context.maxFiles > 1,
                onClick (event) {
                    event.stopPropagation();
                    event.currentTarget.value = "";
                },
                onChange (event) {
                    if (disabled) return;
                    const { files } = event.currentTarget;
                    send({
                        type: "FILES.SET",
                        files: files ? Array.from(files) : []
                    });
                },
                style: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["visuallyHiddenStyle"]
            });
        },
        getItemGroupProps () {
            return normalize.element({
                ...parts.itemGroup.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled)
            });
        },
        getItemProps (props2) {
            const { file } = props2;
            return normalize.element({
                ...parts.item.attrs,
                dir: state.context.dir,
                id: dom.getItemId(state.context, file.name),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled)
            });
        },
        getItemNameProps (props2) {
            const { file } = props2;
            return normalize.element({
                ...parts.itemName.attrs,
                dir: state.context.dir,
                id: dom.getItemNameId(state.context, file.name),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled)
            });
        },
        getItemSizeTextProps (props2) {
            const { file } = props2;
            return normalize.element({
                ...parts.itemSizeText.attrs,
                dir: state.context.dir,
                id: dom.getItemSizeTextId(state.context, file.name),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled)
            });
        },
        getItemPreviewProps (props2) {
            const { file } = props2;
            return normalize.element({
                ...parts.itemPreview.attrs,
                dir: state.context.dir,
                id: dom.getItemPreviewId(state.context, file.name),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled)
            });
        },
        getItemPreviewImageProps (props2) {
            const { file, url } = props2;
            const isImage = file.type.startsWith("image/");
            if (!isImage) {
                throw new Error("Preview Image is only supported for image files");
            }
            return normalize.img({
                ...parts.itemPreviewImage.attrs,
                alt: translations.itemPreview?.(file),
                src: url,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled)
            });
        },
        getItemDeleteTriggerProps (props2) {
            const { file } = props2;
            return normalize.button({
                ...parts.itemDeleteTrigger.attrs,
                dir: state.context.dir,
                type: "button",
                disabled,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "aria-label": translations.deleteFile?.(file),
                onClick () {
                    if (disabled) return;
                    send({
                        type: "FILE.DELETE",
                        file
                    });
                }
            });
        },
        getLabelProps () {
            return normalize.label({
                ...parts.label.attrs,
                dir: state.context.dir,
                id: dom.getLabelId(state.context),
                htmlFor: dom.getHiddenInputId(state.context),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled)
            });
        },
        getClearTriggerProps () {
            return normalize.button({
                ...parts.clearTrigger.attrs,
                dir: state.context.dir,
                type: "button",
                disabled,
                hidden: state.context.acceptedFiles.length === 0,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (disabled) return;
                    send({
                        type: "FILES.CLEAR"
                    });
                }
            });
        }
    };
}
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "fileupload",
        initial: "idle",
        context: {
            minFileSize: 0,
            maxFileSize: Infinity,
            maxFiles: 1,
            allowDrop: true,
            ...ctx,
            acceptedFiles: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])([]),
            rejectedFiles: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])([]),
            translations: {
                dropzone: "dropzone",
                itemPreview: (file)=>`preview of ${file.name}`,
                deleteFile: (file)=>`delete file ${file.name}`,
                ...ctx.translations
            }
        },
        computed: {
            acceptAttr: (ctx2)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$file$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAcceptAttrString"])(ctx2.accept),
            multiple: (ctx2)=>ctx2.maxFiles > 1
        },
        on: {
            "FILES.SET": {
                actions: [
                    "setFilesFromEvent"
                ]
            },
            "FILE.DELETE": {
                actions: [
                    "removeFile"
                ]
            },
            "FILES.CLEAR": {
                actions: [
                    "clearFiles"
                ]
            },
            "REJECTED_FILES.CLEAR": {
                actions: [
                    "clearRejectedFiles"
                ]
            }
        },
        states: {
            idle: {
                on: {
                    OPEN: {
                        actions: [
                            "openFilePicker"
                        ]
                    },
                    "DROPZONE.CLICK": {
                        actions: [
                            "openFilePicker"
                        ]
                    },
                    "DROPZONE.FOCUS": "focused",
                    "DROPZONE.DRAG_OVER": {
                        target: "dragging"
                    }
                }
            },
            focused: {
                on: {
                    "DROPZONE.BLUR": "idle",
                    OPEN: {
                        actions: [
                            "openFilePicker"
                        ]
                    },
                    "DROPZONE.CLICK": {
                        actions: [
                            "openFilePicker"
                        ]
                    },
                    "DROPZONE.DRAG_OVER": {
                        target: "dragging"
                    }
                }
            },
            dragging: {
                on: {
                    "DROPZONE.DROP": {
                        target: "idle",
                        actions: [
                            "setFilesFromEvent",
                            "syncInputElement"
                        ]
                    },
                    "DROPZONE.DRAG_LEAVE": {
                        target: "idle"
                    }
                }
            }
        }
    }, {
        actions: {
            syncInputElement (ctx2) {
                const inputEl = dom.getHiddenInputEl(ctx2);
                if (!inputEl) return;
                const win = dom.getWin(ctx2);
                const dataTransfer = new win.DataTransfer();
                ctx2.acceptedFiles.forEach((v)=>{
                    dataTransfer.items.add(v);
                });
                inputEl.files = dataTransfer.files;
            },
            openFilePicker (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    dom.getHiddenInputEl(ctx2)?.click();
                });
            },
            setFilesFromEvent (ctx2, evt) {
                const result = getFilesFromEvent(ctx2, evt.files);
                const { acceptedFiles, rejectedFiles } = result;
                if (ctx2.multiple) {
                    const files = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])([
                        ...ctx2.acceptedFiles,
                        ...acceptedFiles
                    ]);
                    set.files(ctx2, files, rejectedFiles);
                    return;
                }
                if (acceptedFiles.length) {
                    const files = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])([
                        acceptedFiles[0]
                    ]);
                    set.files(ctx2, files, rejectedFiles);
                } else if (rejectedFiles.length) {
                    set.files(ctx2, ctx2.acceptedFiles, rejectedFiles);
                }
            },
            removeFile (ctx2, evt) {
                const nextFiles = ctx2.acceptedFiles.filter((file)=>file !== evt.file);
                ctx2.acceptedFiles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(nextFiles);
                invoke.change(ctx2);
            },
            clearRejectedFiles (ctx2) {
                ctx2.rejectedFiles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])([]);
                invoke.change(ctx2);
            },
            clearFiles (ctx2) {
                ctx2.acceptedFiles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])([]);
                ctx2.rejectedFiles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])([]);
                invoke.change(ctx2);
            }
        },
        compareFns: {
            acceptedFiles: (a, b)=>a.length === b.length && a.every((file, i)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$file$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFileEqual"])(file, b[i]))
        }
    });
}
var invoke = {
    change: (ctx)=>{
        ctx.onFileChange?.({
            acceptedFiles: ctx.acceptedFiles,
            rejectedFiles: ctx.rejectedFiles
        });
    },
    accept: (ctx)=>{
        ctx.onFileAccept?.({
            files: ctx.acceptedFiles
        });
    },
    reject: (ctx)=>{
        ctx.onFileReject?.({
            files: ctx.rejectedFiles
        });
    }
};
var set = {
    files: (ctx, acceptedFiles, rejectedFiles)=>{
        ctx.acceptedFiles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(acceptedFiles);
        invoke.accept(ctx);
        if (rejectedFiles) {
            ctx.rejectedFiles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(rejectedFiles);
            invoke.reject(ctx);
        }
        invoke.change(ctx);
    }
};
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "accept",
    "allowDrop",
    "capture",
    "dir",
    "directory",
    "disabled",
    "getRootNode",
    "id",
    "ids",
    "locale",
    "maxFiles",
    "maxFileSize",
    "minFileSize",
    "name",
    "invalid",
    "onFileAccept",
    "onFileReject",
    "onFileChange",
    "required",
    "translations",
    "validate"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
var itemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "file"
]);
var splitItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(itemProps);
;
}}),
"[project]/node_modules/@zag-js/file-upload/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as fileUploadAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "fileUploadAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$file$2d$upload$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$file$2d$upload$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/file-upload/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */ __turbopack_esm__({
    "alignments": (()=>alignments),
    "clamp": (()=>clamp),
    "createCoords": (()=>createCoords),
    "evaluate": (()=>evaluate),
    "expandPaddingObject": (()=>expandPaddingObject),
    "floor": (()=>floor),
    "getAlignment": (()=>getAlignment),
    "getAlignmentAxis": (()=>getAlignmentAxis),
    "getAlignmentSides": (()=>getAlignmentSides),
    "getAxisLength": (()=>getAxisLength),
    "getExpandedPlacements": (()=>getExpandedPlacements),
    "getOppositeAlignmentPlacement": (()=>getOppositeAlignmentPlacement),
    "getOppositeAxis": (()=>getOppositeAxis),
    "getOppositeAxisPlacements": (()=>getOppositeAxisPlacements),
    "getOppositePlacement": (()=>getOppositePlacement),
    "getPaddingObject": (()=>getPaddingObject),
    "getSide": (()=>getSide),
    "getSideAxis": (()=>getSideAxis),
    "max": (()=>max),
    "min": (()=>min),
    "placements": (()=>placements),
    "rectToClientRect": (()=>rectToClientRect),
    "round": (()=>round),
    "sides": (()=>sides)
});
const sides = [
    'top',
    'right',
    'bottom',
    'left'
];
const alignments = [
    'start',
    'end'
];
const placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v)=>({
        x: v,
        y: v
    });
const oppositeSideMap = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
};
const oppositeAlignmentMap = {
    start: 'end',
    end: 'start'
};
function clamp(start, value, end) {
    return max(start, min(value, end));
}
function evaluate(value, param) {
    return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
    return placement.split('-')[0];
}
function getAlignment(placement) {
    return placement.split('-')[1];
}
function getOppositeAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
    return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
    return [
        'top',
        'bottom'
    ].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
        rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
    if (rects.reference[length] > rects.floating[length]) {
        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [
        mainAlignmentSide,
        getOppositePlacement(mainAlignmentSide)
    ];
}
function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [
        getOppositeAlignmentPlacement(placement),
        oppositePlacement,
        getOppositeAlignmentPlacement(oppositePlacement)
    ];
}
function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
    const lr = [
        'left',
        'right'
    ];
    const rl = [
        'right',
        'left'
    ];
    const tb = [
        'top',
        'bottom'
    ];
    const bt = [
        'bottom',
        'top'
    ];
    switch(side){
        case 'top':
        case 'bottom':
            if (rtl) return isStart ? rl : lr;
            return isStart ? lr : rl;
        case 'left':
        case 'right':
            return isStart ? tb : bt;
        default:
            return [];
    }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === 'start', rtl);
    if (alignment) {
        list = list.map((side)=>side + "-" + alignment);
        if (flipAlignment) {
            list = list.concat(list.map(getOppositeAlignmentPlacement));
        }
    }
    return list;
}
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding
    };
}
function getPaddingObject(padding) {
    return typeof padding !== 'number' ? expandPaddingObject(padding) : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding
    };
}
function rectToClientRect(rect) {
    const { x, y, width, height } = rect;
    return {
        width,
        height,
        top: y,
        left: x,
        right: x + width,
        bottom: y + height,
        x,
        y
    };
}
;
}}),
"[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getComputedStyle": (()=>getComputedStyle),
    "getContainingBlock": (()=>getContainingBlock),
    "getDocumentElement": (()=>getDocumentElement),
    "getFrameElement": (()=>getFrameElement),
    "getNearestOverflowAncestor": (()=>getNearestOverflowAncestor),
    "getNodeName": (()=>getNodeName),
    "getNodeScroll": (()=>getNodeScroll),
    "getOverflowAncestors": (()=>getOverflowAncestors),
    "getParentNode": (()=>getParentNode),
    "getWindow": (()=>getWindow),
    "isContainingBlock": (()=>isContainingBlock),
    "isElement": (()=>isElement),
    "isHTMLElement": (()=>isHTMLElement),
    "isLastTraversableNode": (()=>isLastTraversableNode),
    "isNode": (()=>isNode),
    "isOverflowElement": (()=>isOverflowElement),
    "isShadowRoot": (()=>isShadowRoot),
    "isTableElement": (()=>isTableElement),
    "isTopLayer": (()=>isTopLayer),
    "isWebKit": (()=>isWebKit)
});
function hasWindow() {
    return "undefined" !== 'undefined';
}
function getNodeName(node) {
    if (isNode(node)) {
        return (node.nodeName || '').toLowerCase();
    }
    // Mocked nodes in testing environments may not be instances of Node. By
    // returning `#document` an infinite loop won't occur.
    // https://github.com/floating-ui/floating-ui/issues/2317
    return '#document';
}
function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
    if (!hasWindow()) {
        return false;
    }
    "TURBOPACK unreachable";
}
function isElement(value) {
    if (!hasWindow()) {
        return false;
    }
    "TURBOPACK unreachable";
}
function isHTMLElement(value) {
    if (!hasWindow()) {
        return false;
    }
    "TURBOPACK unreachable";
}
function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === 'undefined') {
        return false;
    }
    "TURBOPACK unreachable";
}
function isOverflowElement(element) {
    const { overflow, overflowX, overflowY, display } = getComputedStyle(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![
        'inline',
        'contents'
    ].includes(display);
}
function isTableElement(element) {
    return [
        'table',
        'td',
        'th'
    ].includes(getNodeName(element));
}
function isTopLayer(element) {
    return [
        ':popover-open',
        ':modal'
    ].some((selector)=>{
        try {
            return element.matches(selector);
        } catch (e) {
            return false;
        }
    });
}
function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || [
        'transform',
        'perspective',
        'filter'
    ].some((value)=>(css.willChange || '').includes(value)) || [
        'paint',
        'layout',
        'strict',
        'content'
    ].some((value)=>(css.contain || '').includes(value));
}
function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){
        if (isContainingBlock(currentNode)) {
            return currentNode;
        } else if (isTopLayer(currentNode)) {
            return null;
        }
        currentNode = getParentNode(currentNode);
    }
    return null;
}
function isWebKit() {
    if (typeof CSS === 'undefined' || !CSS.supports) return false;
    return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
    return [
        'html',
        'body',
        '#document'
    ].includes(getNodeName(node));
}
function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
    if (isElement(element)) {
        return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
        };
    }
    return {
        scrollLeft: element.scrollX,
        scrollTop: element.scrollY
    };
}
function getParentNode(node) {
    if (getNodeName(node) === 'html') {
        return node;
    }
    const result = // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
        return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
        return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
        list = [];
    }
    if (traverseIframes === void 0) {
        traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
        const frameElement = getFrameElement(win);
        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
;
}}),
"[project]/node_modules/@floating-ui/core/dist/floating-ui.core.mjs [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "arrow": (()=>arrow),
    "autoPlacement": (()=>autoPlacement),
    "computePosition": (()=>computePosition),
    "detectOverflow": (()=>detectOverflow),
    "flip": (()=>flip),
    "hide": (()=>hide),
    "inline": (()=>inline),
    "limitShift": (()=>limitShift),
    "offset": (()=>offset),
    "shift": (()=>shift),
    "size": (()=>size)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs [app-rsc] (ecmascript)");
;
;
function computeCoordsFromPlacement(_ref, placement, rtl) {
    let { reference, floating } = _ref;
    const sideAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSideAxis"])(placement);
    const alignmentAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignmentAxis"])(placement);
    const alignLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAxisLength"])(alignmentAxis);
    const side = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(placement);
    const isVertical = sideAxis === 'y';
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch(side){
        case 'top':
            coords = {
                x: commonX,
                y: reference.y - floating.height
            };
            break;
        case 'bottom':
            coords = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case 'right':
            coords = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case 'left':
            coords = {
                x: reference.x - floating.width,
                y: commonY
            };
            break;
        default:
            coords = {
                x: reference.x,
                y: reference.y
            };
    }
    switch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignment"])(placement)){
        case 'start':
            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
            break;
        case 'end':
            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
            break;
    }
    return coords;
}
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */ const computePosition = async (reference, floating, config)=>{
    const { placement = 'bottom', strategy = 'absolute', middleware = [], platform } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
    let rects = await platform.getElementRects({
        reference,
        floating,
        strategy
    });
    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for(let i = 0; i < validMiddleware.length; i++){
        const { name, fn } = validMiddleware[i];
        const { x: nextX, y: nextY, data, reset } = await fn({
            x,
            y,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform,
            elements: {
                reference,
                floating
            }
        });
        x = nextX != null ? nextX : x;
        y = nextY != null ? nextY : y;
        middlewareData = {
            ...middlewareData,
            [name]: {
                ...middlewareData[name],
                ...data
            }
        };
        if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === 'object') {
                if (reset.placement) {
                    statefulPlacement = reset.placement;
                }
                if (reset.rects) {
                    rects = reset.rects === true ? await platform.getElementRects({
                        reference,
                        floating,
                        strategy
                    }) : reset.rects;
                }
                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
            }
            i = -1;
        }
    }
    return {
        x,
        y,
        placement: statefulPlacement,
        strategy,
        middlewareData
    };
};
/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */ async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
        options = {};
    }
    const { x, y, platform, rects, elements, strategy } = state;
    const { boundary = 'clippingAncestors', rootBoundary = 'viewport', elementContext = 'floating', altBoundary = false, padding = 0 } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
    const paddingObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPaddingObject"])(padding);
    const altContext = elementContext === 'floating' ? 'reference' : 'floating';
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["rectToClientRect"])(await platform.getClippingRect({
        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),
        boundary,
        rootBoundary,
        strategy
    }));
    const rect = elementContext === 'floating' ? {
        x,
        y,
        width: rects.floating.width,
        height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    };
    const elementClientRect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["rectToClientRect"])(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements,
        rect,
        offsetParent,
        strategy
    }) : rect);
    return {
        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
}
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ const arrow = (options)=>({
        name: 'arrow',
        options,
        async fn (state) {
            const { x, y, placement, rects, platform, elements, middlewareData } = state;
            // Since `element` is required, we don't Partial<> the type.
            const { element, padding = 0 } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(options, state) || {};
            if (element == null) {
                return {};
            }
            const paddingObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPaddingObject"])(padding);
            const coords = {
                x,
                y
            };
            const axis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignmentAxis"])(placement);
            const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAxisLength"])(axis);
            const arrowDimensions = await platform.getDimensions(element);
            const isYAxis = axis === 'y';
            const minProp = isYAxis ? 'top' : 'left';
            const maxProp = isYAxis ? 'bottom' : 'right';
            const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
            const startDiff = coords[axis] - rects.reference[axis];
            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
            // DOM platform can return `window` as the `offsetParent`.
            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {
                clientSize = elements.floating[clientProp] || rects.floating[length];
            }
            const centerToReference = endDiff / 2 - startDiff / 2;
            // If the padding is large enough that it causes the arrow to no longer be
            // centered, modify the padding so that it is centered.
            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
            const minPadding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["min"])(paddingObject[minProp], largestPossiblePadding);
            const maxPadding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["min"])(paddingObject[maxProp], largestPossiblePadding);
            // Make sure the arrow doesn't overflow the floating element if the center
            // point is outside the floating element's bounds.
            const min$1 = minPadding;
            const max = clientSize - arrowDimensions[length] - maxPadding;
            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
            const offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clamp"])(min$1, center, max);
            // If the reference is small enough that the arrow's padding causes it to
            // to point to nothing for an aligned placement, adjust the offset of the
            // floating element itself. To ensure `shift()` continues to take action,
            // a single reset is performed when this is true.
            const shouldAddOffset = !middlewareData.arrow && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignment"])(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
            return {
                [axis]: coords[axis] + alignmentOffset,
                data: {
                    [axis]: offset,
                    centerOffset: center - offset - alignmentOffset,
                    ...shouldAddOffset && {
                        alignmentOffset
                    }
                },
                reset: shouldAddOffset
            };
        }
    });
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
    const allowedPlacementsSortedByAlignment = alignment ? [
        ...allowedPlacements.filter((placement)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignment"])(placement) === alignment),
        ...allowedPlacements.filter((placement)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignment"])(placement) !== alignment)
    ] : allowedPlacements.filter((placement)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(placement) === placement);
    return allowedPlacementsSortedByAlignment.filter((placement)=>{
        if (alignment) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignment"])(placement) === alignment || (autoAlignment ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getOppositeAlignmentPlacement"])(placement) !== placement : false);
        }
        return true;
    });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */ const autoPlacement = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'autoPlacement',
        options,
        async fn (state) {
            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
            const { rects, middlewareData, placement, platform, elements } = state;
            const { crossAxis = false, alignment, allowedPlacements = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["placements"], autoAlignment = true, ...detectOverflowOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            const placements$1 = alignment !== undefined || allowedPlacements === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["placements"] ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
            const currentPlacement = placements$1[currentIndex];
            if (currentPlacement == null) {
                return {};
            }
            const alignmentSides = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignmentSides"])(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
            // Make `computeCoords` start from the right place.
            if (placement !== currentPlacement) {
                return {
                    reset: {
                        placement: placements$1[0]
                    }
                };
            }
            const currentOverflows = [
                overflow[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(currentPlacement)],
                overflow[alignmentSides[0]],
                overflow[alignmentSides[1]]
            ];
            const allOverflows = [
                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],
                {
                    placement: currentPlacement,
                    overflows: currentOverflows
                }
            ];
            const nextPlacement = placements$1[currentIndex + 1];
            // There are more placements to check.
            if (nextPlacement) {
                return {
                    data: {
                        index: currentIndex + 1,
                        overflows: allOverflows
                    },
                    reset: {
                        placement: nextPlacement
                    }
                };
            }
            const placementsSortedByMostSpace = allOverflows.map((d)=>{
                const alignment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignment"])(d.placement);
                return [
                    d.placement,
                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.
                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.
                    d.overflows[0],
                    d.overflows
                ];
            }).sort((a, b)=>a[1] - b[1]);
            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis
                // side.
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignment"])(d[0]) ? 2 : 3).every((v)=>v <= 0));
            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
            if (resetPlacement !== placement) {
                return {
                    data: {
                        index: currentIndex + 1,
                        overflows: allOverflows
                    },
                    reset: {
                        placement: resetPlacement
                    }
                };
            }
            return {};
        }
    };
};
/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */ const flip = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'flip',
        options,
        async fn (state) {
            var _middlewareData$arrow, _middlewareData$flip;
            const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;
            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = 'bestFit', fallbackAxisSideDirection = 'none', flipAlignment = true, ...detectOverflowOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            // If a reset by the arrow was caused due to an alignment offset being
            // added, we should skip any logic now since `flip()` has already done its
            // work.
            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
                return {};
            }
            const side = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(placement);
            const initialSideAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSideAxis"])(initialPlacement);
            const isBasePlacement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(initialPlacement) === initialPlacement;
            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getOppositePlacement"])(initialPlacement)
            ] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getExpandedPlacements"])(initialPlacement));
            const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
            if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
                fallbackPlacements.push(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getOppositeAxisPlacements"])(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
            }
            const placements = [
                initialPlacement,
                ...fallbackPlacements
            ];
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const overflows = [];
            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
            if (checkMainAxis) {
                overflows.push(overflow[side]);
            }
            if (checkCrossAxis) {
                const sides = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignmentSides"])(placement, rects, rtl);
                overflows.push(overflow[sides[0]], overflow[sides[1]]);
            }
            overflowsData = [
                ...overflowsData,
                {
                    placement,
                    overflows
                }
            ];
            // One or more sides is overflowing.
            if (!overflows.every((side)=>side <= 0)) {
                var _middlewareData$flip2, _overflowsData$filter;
                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
                const nextPlacement = placements[nextIndex];
                if (nextPlacement) {
                    // Try next placement and re-run the lifecycle.
                    return {
                        data: {
                            index: nextIndex,
                            overflows: overflowsData
                        },
                        reset: {
                            placement: nextPlacement
                        }
                    };
                }
                // First, find the candidates that fit on the mainAxis side of overflow,
                // then find the placement that fits the best on the main crossAxis side.
                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
                // Otherwise fallback.
                if (!resetPlacement) {
                    switch(fallbackStrategy){
                        case 'bestFit':
                            {
                                var _overflowsData$filter2;
                                const placement = (_overflowsData$filter2 = overflowsData.filter((d)=>{
                                    if (hasFallbackAxisSideDirection) {
                                        const currentSideAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSideAxis"])(d.placement);
                                        return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                                        // reading directions favoring greater width.
                                        currentSideAxis === 'y';
                                    }
                                    return true;
                                }).map((d)=>[
                                        d.placement,
                                        d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)
                                    ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                                if (placement) {
                                    resetPlacement = placement;
                                }
                                break;
                            }
                        case 'initialPlacement':
                            resetPlacement = initialPlacement;
                            break;
                    }
                }
                if (placement !== resetPlacement) {
                    return {
                        reset: {
                            placement: resetPlacement
                        }
                    };
                }
            }
            return {};
        }
    };
};
function getSideOffsets(overflow, rect) {
    return {
        top: overflow.top - rect.height,
        right: overflow.right - rect.width,
        bottom: overflow.bottom - rect.height,
        left: overflow.left - rect.width
    };
}
function isAnySideFullyClipped(overflow) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sides"].some((side)=>overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ const hide = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'hide',
        options,
        async fn (state) {
            const { rects } = state;
            const { strategy = 'referenceHidden', ...detectOverflowOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            switch(strategy){
                case 'referenceHidden':
                    {
                        const overflow = await detectOverflow(state, {
                            ...detectOverflowOptions,
                            elementContext: 'reference'
                        });
                        const offsets = getSideOffsets(overflow, rects.reference);
                        return {
                            data: {
                                referenceHiddenOffsets: offsets,
                                referenceHidden: isAnySideFullyClipped(offsets)
                            }
                        };
                    }
                case 'escaped':
                    {
                        const overflow = await detectOverflow(state, {
                            ...detectOverflowOptions,
                            altBoundary: true
                        });
                        const offsets = getSideOffsets(overflow, rects.floating);
                        return {
                            data: {
                                escapedOffsets: offsets,
                                escaped: isAnySideFullyClipped(offsets)
                            }
                        };
                    }
                default:
                    {
                        return {};
                    }
            }
        }
    };
};
function getBoundingRect(rects) {
    const minX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["min"])(...rects.map((rect)=>rect.left));
    const minY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["min"])(...rects.map((rect)=>rect.top));
    const maxX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(...rects.map((rect)=>rect.right));
    const maxY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(...rects.map((rect)=>rect.bottom));
    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
}
function getRectsByLine(rects) {
    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);
    const groups = [];
    let prevRect = null;
    for(let i = 0; i < sortedRects.length; i++){
        const rect = sortedRects[i];
        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
            groups.push([
                rect
            ]);
        } else {
            groups[groups.length - 1].push(rect);
        }
        prevRect = rect;
    }
    return groups.map((rect)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["rectToClientRect"])(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ const inline = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'inline',
        options,
        async fn (state) {
            const { placement, elements, rects, platform, strategy } = state;
            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
            // ClientRect's bounds, despite the event listener being triggered. A
            // padding of 2 seems to handle this issue.
            const { padding = 2, x, y } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);
            const clientRects = getRectsByLine(nativeClientRects);
            const fallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["rectToClientRect"])(getBoundingRect(nativeClientRects));
            const paddingObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPaddingObject"])(padding);
            function getBoundingClientRect() {
                // There are two rects and they are disjoined.
                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
                    // Find the first rect in which the point is fully inside.
                    return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
                }
                // There are 2 or more connected rects.
                if (clientRects.length >= 2) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSideAxis"])(placement) === 'y') {
                        const firstRect = clientRects[0];
                        const lastRect = clientRects[clientRects.length - 1];
                        const isTop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(placement) === 'top';
                        const top = firstRect.top;
                        const bottom = lastRect.bottom;
                        const left = isTop ? firstRect.left : lastRect.left;
                        const right = isTop ? firstRect.right : lastRect.right;
                        const width = right - left;
                        const height = bottom - top;
                        return {
                            top,
                            bottom,
                            left,
                            right,
                            width,
                            height,
                            x: left,
                            y: top
                        };
                    }
                    const isLeftSide = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(placement) === 'left';
                    const maxRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(...clientRects.map((rect)=>rect.right));
                    const minLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["min"])(...clientRects.map((rect)=>rect.left));
                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);
                    const top = measureRects[0].top;
                    const bottom = measureRects[measureRects.length - 1].bottom;
                    const left = minLeft;
                    const right = maxRight;
                    const width = right - left;
                    const height = bottom - top;
                    return {
                        top,
                        bottom,
                        left,
                        right,
                        width,
                        height,
                        x: left,
                        y: top
                    };
                }
                return fallback;
            }
            const resetRects = await platform.getElementRects({
                reference: {
                    getBoundingClientRect
                },
                floating: elements.floating,
                strategy
            });
            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
                return {
                    reset: {
                        rects: resetRects
                    }
                };
            }
            return {};
        }
    };
};
// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.
async function convertValueToCoords(state, options) {
    const { placement, platform, elements } = state;
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
    const side = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(placement);
    const alignment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignment"])(placement);
    const isVertical = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSideAxis"])(placement) === 'y';
    const mainAxisMulti = [
        'left',
        'top'
    ].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
    // eslint-disable-next-line prefer-const
    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === 'number' ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: rawValue.mainAxis || 0,
        crossAxis: rawValue.crossAxis || 0,
        alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === 'number') {
        crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
    } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
    };
}
/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */ const offset = function(options) {
    if (options === void 0) {
        options = 0;
    }
    return {
        name: 'offset',
        options,
        async fn (state) {
            var _middlewareData$offse, _middlewareData$arrow;
            const { x, y, placement, middlewareData } = state;
            const diffCoords = await convertValueToCoords(state, options);
            // If the placement is the same and the arrow caused an alignment offset
            // then we don't need to change the positioning coordinates.
            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
                return {};
            }
            return {
                x: x + diffCoords.x,
                y: y + diffCoords.y,
                data: {
                    ...diffCoords,
                    placement
                }
            };
        }
    };
};
/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ const shift = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'shift',
        options,
        async fn (state) {
            const { x, y, placement } = state;
            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {
                fn: (_ref)=>{
                    let { x, y } = _ref;
                    return {
                        x,
                        y
                    };
                }
            }, ...detectOverflowOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            const coords = {
                x,
                y
            };
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const crossAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSideAxis"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(placement));
            const mainAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getOppositeAxis"])(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            if (checkMainAxis) {
                const minSide = mainAxis === 'y' ? 'top' : 'left';
                const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
                const min = mainAxisCoord + overflow[minSide];
                const max = mainAxisCoord - overflow[maxSide];
                mainAxisCoord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clamp"])(min, mainAxisCoord, max);
            }
            if (checkCrossAxis) {
                const minSide = crossAxis === 'y' ? 'top' : 'left';
                const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
                const min = crossAxisCoord + overflow[minSide];
                const max = crossAxisCoord - overflow[maxSide];
                crossAxisCoord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clamp"])(min, crossAxisCoord, max);
            }
            const limitedCoords = limiter.fn({
                ...state,
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
            });
            return {
                ...limitedCoords,
                data: {
                    x: limitedCoords.x - x,
                    y: limitedCoords.y - y,
                    enabled: {
                        [mainAxis]: checkMainAxis,
                        [crossAxis]: checkCrossAxis
                    }
                }
            };
        }
    };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ const limitShift = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        options,
        fn (state) {
            const { x, y, placement, rects, middlewareData } = state;
            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            const coords = {
                x,
                y
            };
            const crossAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSideAxis"])(placement);
            const mainAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getOppositeAxis"])(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            const rawOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(offset, state);
            const computedOffset = typeof rawOffset === 'number' ? {
                mainAxis: rawOffset,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...rawOffset
            };
            if (checkMainAxis) {
                const len = mainAxis === 'y' ? 'height' : 'width';
                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
                if (mainAxisCoord < limitMin) {
                    mainAxisCoord = limitMin;
                } else if (mainAxisCoord > limitMax) {
                    mainAxisCoord = limitMax;
                }
            }
            if (checkCrossAxis) {
                var _middlewareData$offse, _middlewareData$offse2;
                const len = mainAxis === 'y' ? 'width' : 'height';
                const isOriginSide = [
                    'top',
                    'left'
                ].includes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(placement));
                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
                if (crossAxisCoord < limitMin) {
                    crossAxisCoord = limitMin;
                } else if (crossAxisCoord > limitMax) {
                    crossAxisCoord = limitMax;
                }
            }
            return {
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
            };
        }
    };
};
/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */ const size = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'size',
        options,
        async fn (state) {
            var _state$middlewareData, _state$middlewareData2;
            const { placement, rects, platform, elements } = state;
            const { apply = ()=>{}, ...detectOverflowOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const side = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSide"])(placement);
            const alignment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getAlignment"])(placement);
            const isYAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSideAxis"])(placement) === 'y';
            const { width, height } = rects.floating;
            let heightSide;
            let widthSide;
            if (side === 'top' || side === 'bottom') {
                heightSide = side;
                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? 'start' : 'end') ? 'left' : 'right';
            } else {
                widthSide = side;
                heightSide = alignment === 'end' ? 'top' : 'bottom';
            }
            const maximumClippingHeight = height - overflow.top - overflow.bottom;
            const maximumClippingWidth = width - overflow.left - overflow.right;
            const overflowAvailableHeight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["min"])(height - overflow[heightSide], maximumClippingHeight);
            const overflowAvailableWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["min"])(width - overflow[widthSide], maximumClippingWidth);
            const noShift = !state.middlewareData.shift;
            let availableHeight = overflowAvailableHeight;
            let availableWidth = overflowAvailableWidth;
            if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
                availableWidth = maximumClippingWidth;
            }
            if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
                availableHeight = maximumClippingHeight;
            }
            if (noShift && !alignment) {
                const xMin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(overflow.left, 0);
                const xMax = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(overflow.right, 0);
                const yMin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(overflow.top, 0);
                const yMax = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(overflow.bottom, 0);
                if (isYAxis) {
                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(overflow.left, overflow.right));
                } else {
                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(overflow.top, overflow.bottom));
                }
            }
            await apply({
                ...state,
                availableWidth,
                availableHeight
            });
            const nextDimensions = await platform.getDimensions(elements.floating);
            if (width !== nextDimensions.width || height !== nextDimensions.height) {
                return {
                    reset: {
                        rects: true
                    }
                };
            }
            return {};
        }
    };
};
;
}}),
"[project]/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "arrow": (()=>arrow),
    "autoPlacement": (()=>autoPlacement),
    "autoUpdate": (()=>autoUpdate),
    "computePosition": (()=>computePosition),
    "detectOverflow": (()=>detectOverflow),
    "flip": (()=>flip),
    "hide": (()=>hide),
    "inline": (()=>inline),
    "limitShift": (()=>limitShift),
    "offset": (()=>offset),
    "platform": (()=>platform),
    "shift": (()=>shift),
    "size": (()=>size)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@floating-ui/core/dist/floating-ui.core.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs [app-rsc] (ecmascript)");
;
;
;
;
function getCssDimensions(element) {
    const css = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComputedStyle"])(element);
    // In testing environments, the `width` and `height` properties are empty
    // strings for SVG elements, returning NaN. Fallback to `0` in this case.
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["round"])(width) !== offsetWidth || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["round"])(height) !== offsetHeight;
    if (shouldFallback) {
        width = offsetWidth;
        height = offsetHeight;
    }
    return {
        width,
        height,
        $: shouldFallback
    };
}
function unwrapElement(element) {
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isElement"])(element) ? element.contextElement : element;
}
function getScale(element) {
    const domElement = unwrapElement(element);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(domElement)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCoords"])(1);
    }
    const rect = domElement.getBoundingClientRect();
    const { width, height, $ } = getCssDimensions(domElement);
    let x = ($ ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["round"])(rect.width) : rect.width) / width;
    let y = ($ ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["round"])(rect.height) : rect.height) / height;
    // 0, NaN, or Infinity should always fallback to 1.
    if (!x || !Number.isFinite(x)) {
        x = 1;
    }
    if (!y || !Number.isFinite(y)) {
        y = 1;
    }
    return {
        x,
        y
    };
}
const noOffsets = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCoords"])(0);
function getVisualOffsets(element) {
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(element);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isWebKit"])() || !win.visualViewport) {
        return noOffsets;
    }
    return {
        x: win.visualViewport.offsetLeft,
        y: win.visualViewport.offsetTop
    };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
        isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(element)) {
        return false;
    }
    return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
        includeScale = false;
    }
    if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCoords"])(1);
    if (includeScale) {
        if (offsetParent) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isElement"])(offsetParent)) {
                scale = getScale(offsetParent);
            }
        } else {
            scale = getScale(element);
        }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCoords"])(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
        const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(domElement);
        const offsetWin = offsetParent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isElement"])(offsetParent) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(offsetParent) : offsetParent;
        let currentWin = win;
        let currentIFrame = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getFrameElement"])(currentWin);
        while(currentIFrame && offsetParent && offsetWin !== currentWin){
            const iframeScale = getScale(currentIFrame);
            const iframeRect = currentIFrame.getBoundingClientRect();
            const css = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComputedStyle"])(currentIFrame);
            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
            x *= iframeScale.x;
            y *= iframeScale.y;
            width *= iframeScale.x;
            height *= iframeScale.y;
            x += left;
            y += top;
            currentWin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(currentIFrame);
            currentIFrame = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getFrameElement"])(currentWin);
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["rectToClientRect"])({
        width,
        height,
        x,
        y
    });
}
// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
function getWindowScrollBarX(element, rect) {
    const leftScroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNodeScroll"])(element).scrollLeft;
    if (!rect) {
        return getBoundingClientRect((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocumentElement"])(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
        ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect));
    const y = htmlRect.top + scroll.scrollTop;
    return {
        x,
        y
    };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let { elements, rect, offsetParent, strategy } = _ref;
    const isFixed = strategy === 'fixed';
    const documentElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocumentElement"])(offsetParent);
    const topLayer = elements ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isTopLayer"])(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
        return rect;
    }
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    let scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCoords"])(1);
    const offsets = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCoords"])(0);
    const isOffsetParentAnElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNodeName"])(offsetParent) !== 'body' || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isOverflowElement"])(documentElement)) {
            scroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNodeScroll"])(offsetParent);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent);
            scale = getScale(offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCoords"])(0);
    return {
        width: rect.width * scale.x,
        height: rect.height * scale.y,
        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
}
function getClientRects(element) {
    return Array.from(element.getClientRects());
}
// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
    const html = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocumentElement"])(element);
    const scroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNodeScroll"])(element);
    const body = element.ownerDocument.body;
    const width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComputedStyle"])(body).direction === 'rtl') {
        x += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(html.clientWidth, body.clientWidth) - width;
    }
    return {
        width,
        height,
        x,
        y
    };
}
function getViewportRect(element, strategy) {
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(element);
    const html = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocumentElement"])(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        const visualViewportBased = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isWebKit"])();
        if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width,
        height,
        x,
        y
    };
}
// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(element) ? getScale(element) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCoords"])(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
        width,
        height,
        x,
        y
    };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === 'viewport') {
        rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === 'document') {
        rect = getDocumentRect((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocumentElement"])(element));
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isElement"])(clippingAncestor)) {
        rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
        const visualOffsets = getVisualOffsets(element);
        rect = {
            x: clippingAncestor.x - visualOffsets.x,
            y: clippingAncestor.y - visualOffsets.y,
            width: clippingAncestor.width,
            height: clippingAncestor.height
        };
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["rectToClientRect"])(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getParentNode"])(element);
    if (parentNode === stopNode || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isElement"])(parentNode) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(parentNode)) {
        return false;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComputedStyle"])(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}
// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
        return cachedResult;
    }
    let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getOverflowAncestors"])(element, [], false).filter((el)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isElement"])(el) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNodeName"])(el) !== 'body');
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).position === 'fixed';
    let currentNode = elementIsFixed ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getParentNode"])(element) : element;
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isElement"])(currentNode) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(currentNode)){
        const computedStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComputedStyle"])(currentNode);
        const currentNodeIsContaining = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isContainingBlock"])(currentNode);
        if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
            currentContainingBlockComputedStyle = null;
        }
        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && [
            'absolute',
            'fixed'
        ].includes(currentContainingBlockComputedStyle.position) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isOverflowElement"])(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
        if (shouldDropCurrentNode) {
            // Drop non-containing blocks.
            result = result.filter((ancestor)=>ancestor !== currentNode);
        } else {
            // Record last containing block for next iteration.
            currentContainingBlockComputedStyle = computedStyle;
        }
        currentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getParentNode"])(currentNode);
    }
    cache.set(element, result);
    return result;
}
// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
    let { element, boundary, rootBoundary, strategy } = _ref;
    const elementClippingAncestors = boundary === 'clippingAncestors' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isTopLayer"])(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [
        ...elementClippingAncestors,
        rootBoundary
    ];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{
        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(rect.top, accRect.top);
        accRect.right = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["min"])(rect.right, accRect.right);
        accRect.bottom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["min"])(rect.bottom, accRect.bottom);
        accRect.left = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
    };
}
function getDimensions(element) {
    const { width, height } = getCssDimensions(element);
    return {
        width,
        height
    };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(offsetParent);
    const documentElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocumentElement"])(offsetParent);
    const isFixed = strategy === 'fixed';
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const offsets = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCoords"])(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNodeName"])(offsetParent) !== 'body' || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isOverflowElement"])(documentElement)) {
            scroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNodeScroll"])(offsetParent);
        }
        if (isOffsetParentAnElement) {
            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
            // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
            // Firefox with layout.scrollbar.side = 3 in about:config to test this.
            offsets.x = getWindowScrollBarX(documentElement);
        }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCoords"])(0);
    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
        x,
        y,
        width: rect.width,
        height: rect.height
    };
}
function isStaticPositioned(element) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).position === 'static';
}
function getTrueOffsetParent(element, polyfill) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(element) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).position === 'fixed') {
        return null;
    }
    if (polyfill) {
        return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    // Firefox returns the <html> element as the offsetParent if it's non-static,
    // while Chrome and Safari return the <body> element. The <body> element must
    // be used to perform the correct calculations even if the <html> element is
    // non-static.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocumentElement"])(element) === rawOffsetParent) {
        rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
}
// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(element);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isTopLayer"])(element)) {
        return win;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(element)) {
        let svgOffsetParent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getParentNode"])(element);
        while(svgOffsetParent && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(svgOffsetParent)){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isElement"])(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
                return svgOffsetParent;
            }
            svgOffsetParent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getParentNode"])(svgOffsetParent);
        }
        return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while(offsetParent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isTableElement"])(offsetParent) && isStaticPositioned(offsetParent)){
        offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(offsetParent) && isStaticPositioned(offsetParent) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isContainingBlock"])(offsetParent)) {
        return win;
    }
    return offsetParent || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getContainingBlock"])(element) || win;
}
const getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
        floating: {
            x: 0,
            y: 0,
            width: floatingDimensions.width,
            height: floatingDimensions.height
        }
    };
};
function isRTL(element) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).direction === 'rtl';
}
const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocumentElement"],
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isElement"],
    isRTL
};
// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocumentElement"])(element);
    function cleanup() {
        var _io;
        clearTimeout(timeoutId);
        (_io = io) == null || _io.disconnect();
        io = null;
    }
    function refresh(skip, threshold) {
        if (skip === void 0) {
            skip = false;
        }
        if (threshold === void 0) {
            threshold = 1;
        }
        cleanup();
        const { left, top, width, height } = element.getBoundingClientRect();
        if (!skip) {
            onMove();
        }
        if (!width || !height) {
            return;
        }
        const insetTop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["floor"])(top);
        const insetRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["floor"])(root.clientWidth - (left + width));
        const insetBottom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["floor"])(root.clientHeight - (top + height));
        const insetLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["floor"])(left);
        const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
        const options = {
            rootMargin,
            threshold: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["max"])(0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["min"])(1, threshold)) || 1
        };
        let isFirstUpdate = true;
        function handleObserve(entries) {
            const ratio = entries[0].intersectionRatio;
            if (ratio !== threshold) {
                if (!isFirstUpdate) {
                    return refresh();
                }
                if (!ratio) {
                    // If the reference is clipped, the ratio is 0. Throttle the refresh
                    // to prevent an infinite loop of updates.
                    timeoutId = setTimeout(()=>{
                        refresh(false, 1e-7);
                    }, 1000);
                } else {
                    refresh(false, ratio);
                }
            }
            isFirstUpdate = false;
        }
        // Older browsers don't support a `document` as the root and will throw an
        // error.
        try {
            io = new IntersectionObserver(handleObserve, {
                ...options,
                // Handle <iframe>s
                root: root.ownerDocument
            });
        } catch (e) {
            io = new IntersectionObserver(handleObserve, options);
        }
        io.observe(element);
    }
    refresh(true);
    return cleanup;
}
/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */ function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
        options = {};
    }
    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === 'function', layoutShift = typeof IntersectionObserver === 'function', animationFrame = false } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [
        ...referenceEl ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getOverflowAncestors"])(referenceEl) : [],
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getOverflowAncestors"])(floating)
    ] : [];
    ancestors.forEach((ancestor)=>{
        ancestorScroll && ancestor.addEventListener('scroll', update, {
            passive: true
        });
        ancestorResize && ancestor.addEventListener('resize', update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
        resizeObserver = new ResizeObserver((_ref)=>{
            let [firstEntry] = _ref;
            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
                // Prevent update loops when using the `size` middleware.
                // https://github.com/floating-ui/floating-ui/issues/1740
                resizeObserver.unobserve(floating);
                cancelAnimationFrame(reobserveFrame);
                reobserveFrame = requestAnimationFrame(()=>{
                    var _resizeObserver;
                    (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
                });
            }
            update();
        });
        if (referenceEl && !animationFrame) {
            resizeObserver.observe(referenceEl);
        }
        resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
        frameLoop();
    }
    function frameLoop() {
        const nextRefRect = getBoundingClientRect(reference);
        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
            update();
        }
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return ()=>{
        var _resizeObserver2;
        ancestors.forEach((ancestor)=>{
            ancestorScroll && ancestor.removeEventListener('scroll', update);
            ancestorResize && ancestor.removeEventListener('resize', update);
        });
        cleanupIo == null || cleanupIo();
        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
        resizeObserver = null;
        if (animationFrame) {
            cancelAnimationFrame(frameId);
        }
    };
}
/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */ const detectOverflow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["detectOverflow"];
/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */ const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["offset"];
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */ const autoPlacement = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["autoPlacement"];
/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ const shift = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["shift"];
/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */ const flip = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["flip"];
/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */ const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["size"];
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ const hide = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hide"];
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ const arrow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["arrow"];
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ const inline = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["inline"];
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ const limitShift = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["limitShift"];
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */ const computePosition = (reference, floating, options)=>{
    // This caches the expensive `getClippingElementAncestors` function so that
    // multiple lifecycle resets re-use the same result. It only lives for a
    // single call. If other functions become expensive, we can add them as well.
    const cache = new Map();
    const mergedOptions = {
        platform,
        ...options
    };
    const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["computePosition"])(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
    });
};
;
}}),
"[project]/node_modules/@zag-js/popper/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getPlacement": (()=>getPlacement),
    "getPlacementSide": (()=>getPlacementSide),
    "getPlacementStyles": (()=>getPlacementStyles),
    "isValidPlacement": (()=>isValidPlacement)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs [app-rsc] (ecmascript) <locals>");
;
;
;
// src/get-placement.ts
function createDOMRect(x = 0, y = 0, width = 0, height = 0) {
    if (typeof DOMRect === "function") {
        return new DOMRect(x, y, width, height);
    }
    const rect = {
        x,
        y,
        width,
        height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x
    };
    return {
        ...rect,
        toJSON: ()=>rect
    };
}
function getDOMRect(anchorRect) {
    if (!anchorRect) return createDOMRect();
    const { x, y, width, height } = anchorRect;
    return createDOMRect(x, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
    return {
        contextElement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(anchorElement) ? anchorElement : void 0,
        getBoundingClientRect: ()=>{
            const anchor = anchorElement;
            const anchorRect = getAnchorRect?.(anchor);
            if (anchorRect || !anchor) {
                return getDOMRect(anchorRect);
            }
            return anchor.getBoundingClientRect();
        }
    };
}
// src/middleware.ts
var toVar = (value)=>({
        variable: value,
        reference: `var(${value})`
    });
var cssVars = {
    arrowSize: toVar("--arrow-size"),
    arrowSizeHalf: toVar("--arrow-size-half"),
    arrowBg: toVar("--arrow-background"),
    transformOrigin: toVar("--transform-origin"),
    arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow2)=>({
        top: "bottom center",
        "top-start": arrow2 ? `${arrow2.x}px bottom` : "left bottom",
        "top-end": arrow2 ? `${arrow2.x}px bottom` : "right bottom",
        bottom: "top center",
        "bottom-start": arrow2 ? `${arrow2.x}px top` : "top left",
        "bottom-end": arrow2 ? `${arrow2.x}px top` : "top right",
        left: "right center",
        "left-start": arrow2 ? `right ${arrow2.y}px` : "right top",
        "left-end": arrow2 ? `right ${arrow2.y}px` : "right bottom",
        right: "left center",
        "right-start": arrow2 ? `left ${arrow2.y}px` : "left top",
        "right-end": arrow2 ? `left ${arrow2.y}px` : "left bottom"
    });
var transformOriginMiddleware = {
    name: "transformOrigin",
    fn ({ placement, elements, middlewareData }) {
        const { arrow: arrow2 } = middlewareData;
        const transformOrigin = getTransformOrigin(arrow2)[placement];
        const { floating } = elements;
        floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
        return {
            data: {
                transformOrigin
            }
        };
    }
};
var rectMiddleware = {
    name: "rects",
    fn ({ rects }) {
        return {
            data: rects
        };
    }
};
var shiftArrowMiddleware = (arrowEl)=>{
    if (!arrowEl) return;
    return {
        name: "shiftArrow",
        fn ({ placement, middlewareData }) {
            if (!middlewareData.arrow) return {};
            const { x, y } = middlewareData.arrow;
            const dir = placement.split("-")[0];
            Object.assign(arrowEl.style, {
                left: x != null ? `${x}px` : "",
                top: y != null ? `${y}px` : "",
                [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
            });
            return {};
        }
    };
};
// src/placement.ts
function isValidPlacement(v) {
    return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(v);
}
function getPlacementDetails(placement) {
    const [side, align] = placement.split("-");
    return {
        side,
        align,
        hasAlign: align != null
    };
}
function getPlacementSide(placement) {
    return placement.split("-")[0];
}
// src/get-placement.ts
var defaultOptions = {
    strategy: "absolute",
    placement: "bottom",
    listeners: true,
    gutter: 8,
    flip: true,
    slide: true,
    overlap: false,
    sameWidth: false,
    fitViewport: false,
    overflowPadding: 8,
    arrowPadding: 4
};
function roundByDpr(win, value) {
    const dpr = win.devicePixelRatio || 1;
    return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["runIfFn"])(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
    if (!arrowElement) return;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["arrow"])({
        element: arrowElement,
        padding: opts.arrowPadding
    });
}
function getOffsetMiddleware(arrowElement, opts) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isNull"])(opts.offset ?? opts.gutter)) return;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["offset"])(({ placement })=>{
        const arrowOffset = (arrowElement?.clientHeight || 0) / 2;
        const gutter = opts.offset?.mainAxis ?? opts.gutter;
        const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
        const { hasAlign } = getPlacementDetails(placement);
        const shift2 = !hasAlign ? opts.shift : void 0;
        const crossAxis = opts.offset?.crossAxis ?? shift2;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])({
            crossAxis,
            mainAxis,
            alignmentAxis: opts.shift
        });
    });
}
function getFlipMiddleware(opts) {
    if (!opts.flip) return;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["flip"])({
        boundary: getBoundaryMiddleware(opts),
        padding: opts.overflowPadding,
        fallbackPlacements: opts.flip === true ? void 0 : opts.flip
    });
}
function getShiftMiddleware(opts) {
    if (!opts.slide && !opts.overlap) return;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["shift"])({
        boundary: getBoundaryMiddleware(opts),
        mainAxis: opts.slide,
        crossAxis: opts.overlap,
        padding: opts.overflowPadding,
        limiter: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["limitShift"])()
    });
}
function getSizeMiddleware(opts) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["size"])({
        padding: opts.overflowPadding,
        apply ({ elements, rects, availableHeight, availableWidth }) {
            const floating = elements.floating;
            const referenceWidth = Math.round(rects.reference.width);
            availableWidth = Math.floor(availableWidth);
            availableHeight = Math.floor(availableHeight);
            floating.style.setProperty("--reference-width", `${referenceWidth}px`);
            floating.style.setProperty("--available-width", `${availableWidth}px`);
            floating.style.setProperty("--available-height", `${availableHeight}px`);
        }
    });
}
function hideWhenDetachedMiddleware(opts) {
    if (!opts.hideWhenDetached) return;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hide"])({
        strategy: "referenceHidden",
        boundary: opts.boundary?.() ?? "clippingAncestors"
    });
}
function getAutoUpdateOptions(opts) {
    if (!opts) return {};
    if (opts === true) {
        return {
            ancestorResize: true,
            ancestorScroll: true,
            elementResize: true,
            layoutShift: true
        };
    }
    return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
    const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
    if (!floating || !reference) return;
    const options = Object.assign({}, defaultOptions, opts);
    const arrowEl = floating.querySelector("[data-part=arrow]");
    const middleware = [
        getOffsetMiddleware(arrowEl, options),
        getFlipMiddleware(options),
        getShiftMiddleware(options),
        getArrowMiddleware(arrowEl, options),
        shiftArrowMiddleware(arrowEl),
        transformOriginMiddleware,
        getSizeMiddleware(options),
        hideWhenDetachedMiddleware(options),
        rectMiddleware
    ];
    const { placement, strategy, onComplete, onPositioned } = options;
    const updatePosition = async ()=>{
        if (!reference || !floating) return;
        const pos = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["computePosition"])(reference, floating, {
            placement,
            middleware,
            strategy
        });
        onComplete?.(pos);
        onPositioned?.({
            placed: true
        });
        const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(floating);
        const x = roundByDpr(win, pos.x);
        const y = roundByDpr(win, pos.y);
        floating.style.setProperty("--x", `${x}px`);
        floating.style.setProperty("--y", `${y}px`);
        if (options.hideWhenDetached && pos.middlewareData.hide?.referenceHidden) {
            floating.style.setProperty("visibility", "hidden");
        }
        const contentEl = floating.firstElementChild;
        if (contentEl) {
            const zIndex = win.getComputedStyle(contentEl).zIndex;
            floating.style.setProperty("--z-index", zIndex);
        }
    };
    const update = async ()=>{
        if (opts.updatePosition) {
            await opts.updatePosition({
                updatePosition
            });
            onPositioned?.({
                placed: true
            });
        } else {
            await updatePosition();
        }
    };
    const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
    const cancelAutoUpdate = options.listeners ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["autoUpdate"])(reference, floating, update, autoUpdateOptions) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["noop"];
    update();
    return ()=>{
        cancelAutoUpdate?.();
        onPositioned?.({
            placed: false
        });
    };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
    const { defer, ...options } = opts;
    const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
        const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
        cleanups.push(getPlacementImpl(reference, floating, options));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn?.());
    };
}
// src/get-styles.ts
var ARROW_FLOATING_STYLE = {
    bottom: "rotate(45deg)",
    left: "rotate(135deg)",
    top: "rotate(225deg)",
    right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
    const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
    return {
        arrow: {
            position: "absolute",
            width: cssVars.arrowSize.reference,
            height: cssVars.arrowSize.reference,
            [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
            [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
        },
        arrowTip: {
            // @ts-expect-error - Fix this
            transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
            background: cssVars.arrowBg.reference,
            top: "0",
            left: "0",
            width: "100%",
            height: "100%",
            position: "absolute",
            zIndex: "inherit"
        },
        floating: {
            position: strategy,
            isolation: "isolate",
            minWidth: sameWidth ? void 0 : "max-content",
            width: sameWidth ? "var(--reference-width)" : void 0,
            maxWidth: fitViewport ? "var(--available-width)" : void 0,
            maxHeight: fitViewport ? "var(--available-height)" : void 0,
            top: "0px",
            left: "0px",
            // move off-screen if placement is not defined
            transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
            zIndex: "var(--z-index)"
        }
    };
}
;
}}),
"[project]/node_modules/@zag-js/rect-utils/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "AffineTransform": (()=>AffineTransform),
    "addPoints": (()=>addPoints),
    "alignRect": (()=>alignRect),
    "clampPoint": (()=>clampPoint),
    "clampSize": (()=>clampSize),
    "closest": (()=>closest),
    "closestSideToPoint": (()=>closestSideToPoint),
    "closestSideToRect": (()=>closestSideToRect),
    "collisions": (()=>collisions),
    "constrainRect": (()=>constrainRect),
    "contains": (()=>contains),
    "containsPoint": (()=>containsPoint),
    "containsRect": (()=>containsRect),
    "createPoint": (()=>createPoint),
    "createRect": (()=>createRect),
    "debugPolygon": (()=>debugPolygon),
    "distance": (()=>distance),
    "distanceBtwEdges": (()=>distanceBtwEdges),
    "distanceFromPoint": (()=>distanceFromPoint),
    "distanceFromRect": (()=>distanceFromRect),
    "expand": (()=>expand),
    "fromRange": (()=>fromRange),
    "getElementPolygon": (()=>getElementPolygon),
    "getElementRect": (()=>getElementRect),
    "getRectCenters": (()=>getRectCenters),
    "getRectCorners": (()=>getRectCorners),
    "getRectEdges": (()=>getRectEdges),
    "getRectFromPoints": (()=>getRectFromPoints),
    "getRotationRect": (()=>getRotationRect),
    "getViewportRect": (()=>getViewportRect),
    "getWindowRect": (()=>getWindowRect),
    "inset": (()=>inset),
    "intersection": (()=>intersection),
    "intersects": (()=>intersects),
    "isPoint": (()=>isPoint),
    "isPointEqual": (()=>isPointEqual),
    "isPointInPolygon": (()=>isPointInPolygon),
    "isRect": (()=>isRect),
    "isRectEqual": (()=>isRectEqual),
    "isSizeEqual": (()=>isSizeEqual),
    "isSymmetric": (()=>isSymmetric),
    "resizeRect": (()=>resizeRect),
    "rotate": (()=>rotate),
    "shift": (()=>shift),
    "shrink": (()=>shrink),
    "subtractPoints": (()=>subtractPoints),
    "toRad": (()=>toRad),
    "union": (()=>union)
});
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
// src/affine-transform.ts
var AffineTransform = class _AffineTransform {
    constructor([m00, m01, m02, m10, m11, m12] = [
        0,
        0,
        0,
        0,
        0,
        0
    ]){
        __publicField(this, "m00");
        __publicField(this, "m01");
        __publicField(this, "m02");
        __publicField(this, "m10");
        __publicField(this, "m11");
        __publicField(this, "m12");
        __publicField(this, "rotate", (...args)=>{
            return this.prepend(_AffineTransform.rotate(...args));
        });
        __publicField(this, "scale", (...args)=>{
            return this.prepend(_AffineTransform.scale(...args));
        });
        __publicField(this, "translate", (...args)=>{
            return this.prepend(_AffineTransform.translate(...args));
        });
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m10 = m10;
        this.m11 = m11;
        this.m12 = m12;
    }
    applyTo(point) {
        const { x, y } = point;
        const { m00, m01, m02, m10, m11, m12 } = this;
        return {
            x: m00 * x + m01 * y + m02,
            y: m10 * x + m11 * y + m12
        };
    }
    prepend(other) {
        return new _AffineTransform([
            this.m00 * other.m00 + this.m01 * other.m10,
            // m00
            this.m00 * other.m01 + this.m01 * other.m11,
            // m01
            this.m00 * other.m02 + this.m01 * other.m12 + this.m02,
            // m02
            this.m10 * other.m00 + this.m11 * other.m10,
            // m10
            this.m10 * other.m01 + this.m11 * other.m11,
            // m11
            this.m10 * other.m02 + this.m11 * other.m12 + this.m12
        ]);
    }
    append(other) {
        return new _AffineTransform([
            other.m00 * this.m00 + other.m01 * this.m10,
            // m00
            other.m00 * this.m01 + other.m01 * this.m11,
            // m01
            other.m00 * this.m02 + other.m01 * this.m12 + other.m02,
            // m02
            other.m10 * this.m00 + other.m11 * this.m10,
            // m10
            other.m10 * this.m01 + other.m11 * this.m11,
            // m11
            other.m10 * this.m02 + other.m11 * this.m12 + other.m12
        ]);
    }
    get determinant() {
        return this.m00 * this.m11 - this.m01 * this.m10;
    }
    get isInvertible() {
        const det = this.determinant;
        return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0;
    }
    invert() {
        const det = this.determinant;
        return new _AffineTransform([
            this.m11 / det,
            // m00
            -this.m01 / det,
            // m01
            (this.m01 * this.m12 - this.m11 * this.m02) / det,
            // m02
            -this.m10 / det,
            // m10
            this.m00 / det,
            // m11
            (this.m10 * this.m02 - this.m00 * this.m12) / det
        ]);
    }
    get array() {
        return [
            this.m00,
            this.m01,
            this.m02,
            this.m10,
            this.m11,
            this.m12,
            0,
            0,
            1
        ];
    }
    get float32Array() {
        return new Float32Array(this.array);
    }
    // Static
    static get identity() {
        return new _AffineTransform([
            1,
            0,
            0,
            0,
            1,
            0
        ]);
    }
    static rotate(theta, origin) {
        const rotation = new _AffineTransform([
            Math.cos(theta),
            -Math.sin(theta),
            0,
            Math.sin(theta),
            Math.cos(theta),
            0
        ]);
        if (origin && (origin.x !== 0 || origin.y !== 0)) {
            return _AffineTransform.multiply(_AffineTransform.translate(origin.x, origin.y), rotation, _AffineTransform.translate(-origin.x, -origin.y));
        }
        return rotation;
    }
    static scale(sx, sy = sx, origin = {
        x: 0,
        y: 0
    }) {
        const scale = new _AffineTransform([
            sx,
            0,
            0,
            0,
            sy,
            0
        ]);
        if (origin.x !== 0 || origin.y !== 0) {
            return _AffineTransform.multiply(_AffineTransform.translate(origin.x, origin.y), scale, _AffineTransform.translate(-origin.x, -origin.y));
        }
        return scale;
    }
    static translate(tx, ty) {
        return new _AffineTransform([
            1,
            0,
            tx,
            0,
            1,
            ty
        ]);
    }
    static multiply(...[first, ...rest]) {
        if (!first) return _AffineTransform.identity;
        return rest.reduce((result, item)=>result.prepend(item), first);
    }
    get a() {
        return this.m00;
    }
    get b() {
        return this.m10;
    }
    get c() {
        return this.m01;
    }
    get d() {
        return this.m11;
    }
    get tx() {
        return this.m02;
    }
    get ty() {
        return this.m12;
    }
    get scaleComponents() {
        return {
            x: this.a,
            y: this.d
        };
    }
    get translationComponents() {
        return {
            x: this.tx,
            y: this.ty
        };
    }
    get skewComponents() {
        return {
            x: this.c,
            y: this.b
        };
    }
    toString() {
        return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;
    }
};
// src/align.ts
function hAlign(a, ref, h) {
    let x = ref.minX;
    if (h === "left-inside") x = ref.minX;
    if (h === "left-outside") x = ref.minX - ref.width;
    if (h === "right-inside") x = ref.maxX - ref.width;
    if (h === "right-outside") x = ref.maxX;
    if (h === "center") x = ref.midX - ref.width / 2;
    return {
        ...a,
        x
    };
}
function vAlign(a, ref, v) {
    let y = ref.minY;
    if (v === "top-inside") y = ref.minY;
    if (v === "top-outside") y = ref.minY - a.height;
    if (v === "bottom-inside") y = ref.maxY - a.height;
    if (v === "bottom-outside") y = ref.maxY;
    if (v === "center") y = ref.midY - a.height / 2;
    return {
        ...a,
        y
    };
}
function alignRect(a, ref, options) {
    const { h, v } = options;
    return vAlign(hAlign(a, ref, h), ref, v);
}
// src/clamp.ts
var clamp = (value, min3, max2)=>Math.min(Math.max(value, min3), max2);
var clampPoint = (position, size, boundaryRect)=>{
    const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width);
    const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height);
    return {
        x,
        y
    };
};
var defaultMinSize = {
    width: 0,
    height: 0
};
var defaultMaxSize = {
    width: Infinity,
    height: Infinity
};
var clampSize = (size, minSize = defaultMinSize, maxSize = defaultMaxSize)=>{
    return {
        width: Math.min(Math.max(size.width, minSize.width), maxSize.width),
        height: Math.min(Math.max(size.height, minSize.height), maxSize.height)
    };
};
// src/rect.ts
var createPoint = (x, y)=>({
        x,
        y
    });
var subtractPoints = (a, b)=>createPoint(a.x - b.x, a.y - b.y);
var addPoints = (a, b)=>createPoint(a.x + b.x, a.y + b.y);
function isPoint(v) {
    return Reflect.has(v, "x") && Reflect.has(v, "y");
}
function createRect(r) {
    const { x, y, width, height } = r;
    const midX = x + width / 2;
    const midY = y + height / 2;
    return {
        x,
        y,
        width,
        height,
        minX: x,
        minY: y,
        maxX: x + width,
        maxY: y + height,
        midX,
        midY,
        center: createPoint(midX, midY)
    };
}
function isRect(v) {
    return Reflect.has(v, "x") && Reflect.has(v, "y") && Reflect.has(v, "width") && Reflect.has(v, "height");
}
function getRectCenters(v) {
    const top = createPoint(v.midX, v.minY);
    const right = createPoint(v.maxX, v.midY);
    const bottom = createPoint(v.midX, v.maxY);
    const left = createPoint(v.minX, v.midY);
    return {
        top,
        right,
        bottom,
        left
    };
}
function getRectCorners(v) {
    const top = createPoint(v.minX, v.minY);
    const right = createPoint(v.maxX, v.minY);
    const bottom = createPoint(v.maxX, v.maxY);
    const left = createPoint(v.minX, v.maxY);
    return {
        top,
        right,
        bottom,
        left
    };
}
function getRectEdges(v) {
    const c = getRectCorners(v);
    const top = [
        c.top,
        c.right
    ];
    const right = [
        c.right,
        c.bottom
    ];
    const bottom = [
        c.left,
        c.bottom
    ];
    const left = [
        c.top,
        c.left
    ];
    return {
        top,
        right,
        bottom,
        left
    };
}
// src/intersection.ts
function intersects(a, b) {
    return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y;
}
function intersection(a, b) {
    const x = Math.max(a.x, b.x);
    const y = Math.max(a.y, b.y);
    const x2 = Math.min(a.x + a.width, b.x + b.width);
    const y2 = Math.min(a.y + a.height, b.y + b.height);
    return createRect({
        x,
        y,
        width: x2 - x,
        height: y2 - y
    });
}
function collisions(a, b) {
    return {
        top: a.minY <= b.minY,
        right: a.maxX >= b.maxX,
        bottom: a.maxY >= b.maxY,
        left: a.minX <= b.minX
    };
}
// src/distance.ts
function distance(a, b = {
    x: 0,
    y: 0
}) {
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
function distanceFromPoint(r, p) {
    let x = 0;
    let y = 0;
    if (p.x < r.x) x = r.x - p.x;
    else if (p.x > r.maxX) x = p.x - r.maxX;
    if (p.y < r.y) y = r.y - p.y;
    else if (p.y > r.maxY) y = p.y - r.maxY;
    return {
        x,
        y,
        value: distance({
            x,
            y
        })
    };
}
function distanceFromRect(a, b) {
    if (intersects(a, b)) return {
        x: 0,
        y: 0,
        value: 0
    };
    const left = a.x < b.x ? a : b;
    const right = b.x < a.x ? a : b;
    const upper = a.y < b.y ? a : b;
    const lower = b.y < a.y ? a : b;
    let x = left.x === right.x ? 0 : right.x - left.maxX;
    x = Math.max(0, x);
    let y = upper.y === lower.y ? 0 : lower.y - upper.maxY;
    y = Math.max(0, y);
    return {
        x,
        y,
        value: distance({
            x,
            y
        })
    };
}
function distanceBtwEdges(a, b) {
    return {
        left: b.x - a.x,
        top: b.y - a.y,
        right: a.maxX - b.maxX,
        bottom: a.maxY - b.maxY
    };
}
// src/closest.ts
function closest(...pts) {
    return (a)=>{
        const ds = pts.map((b)=>distance(b, a));
        const c = Math.min.apply(Math, ds);
        return pts[ds.indexOf(c)];
    };
}
function closestSideToRect(ref, r) {
    if (r.maxX <= ref.minX) return "left";
    if (r.minX >= ref.maxX) return "right";
    if (r.maxY <= ref.minY) return "top";
    if (r.minY >= ref.maxY) return "bottom";
    return "left";
}
function closestSideToPoint(ref, p) {
    const { x, y } = p;
    const dl = x - ref.minX;
    const dr = ref.maxX - x;
    const dt = y - ref.minY;
    const db = ref.maxY - y;
    let closest2 = dl;
    let side = "left";
    if (dr < closest2) {
        closest2 = dr;
        side = "right";
    }
    if (dt < closest2) {
        closest2 = dt;
        side = "top";
    }
    if (db < closest2) {
        side = "bottom";
    }
    return side;
}
// src/constrain.ts
var constrainRect = (rect, boundary)=>{
    const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width));
    const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height));
    return {
        x: left,
        y: top,
        width: Math.min(rect.width, boundary.width),
        height: Math.min(rect.height, boundary.height)
    };
};
// src/contains.ts
function containsPoint(r, p) {
    return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY;
}
function containsRect(a, b) {
    return Object.values(getRectCorners(b)).every((c)=>containsPoint(a, c));
}
function contains(r, v) {
    return isRect(v) ? containsRect(r, v) : containsPoint(r, v);
}
// src/equality.ts
var isSizeEqual = (a, b)=>{
    return a.width === b.width && a.height === b.height;
};
var isPointEqual = (a, b)=>{
    return a.x === b.x && a.y === b.y;
};
var isRectEqual = (a, b)=>{
    return isPointEqual(a, b) && isSizeEqual(a, b);
};
// src/from-element.ts
var styleCache = /* @__PURE__ */ new WeakMap();
function getCacheComputedStyle(el) {
    if (!styleCache.has(el)) {
        const win = el.ownerDocument.defaultView || window;
        styleCache.set(el, win.getComputedStyle(el));
    }
    return styleCache.get(el);
}
function getElementRect(el, opts = {}) {
    return createRect(getClientRect(el, opts));
}
function getClientRect(el, opts = {}) {
    const { excludeScrollbar = false, excludeBorders = false } = opts;
    const { x, y, width, height } = el.getBoundingClientRect();
    const r = {
        x,
        y,
        width,
        height
    };
    const style = getCacheComputedStyle(el);
    const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style;
    const borderXWidth = sum(borderLeftWidth, borderRightWidth);
    const borderYWidth = sum(borderTopWidth, borderBottomWidth);
    if (excludeBorders) {
        r.width -= borderXWidth;
        r.height -= borderYWidth;
        r.x += px(borderLeftWidth);
        r.y += px(borderTopWidth);
    }
    if (excludeScrollbar) {
        const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;
        const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;
        r.width -= scrollbarWidth;
        r.height -= scrollbarHeight;
    }
    return r;
}
var px = (v)=>parseFloat(v.replace("px", ""));
var sum = (...vals)=>vals.reduce((sum2, v)=>sum2 + (v ? px(v) : 0), 0);
// src/from-points.ts
function getRectFromPoints(...pts) {
    const xs = pts.map((p)=>p.x);
    const ys = pts.map((p)=>p.y);
    const x = Math.min(...xs);
    const y = Math.min(...ys);
    const width = Math.max(...xs) - x;
    const height = Math.max(...ys) - y;
    return createRect({
        x,
        y,
        width,
        height
    });
}
// src/union.ts
var { min, max } = Math;
function union(...rs) {
    const pMin = {
        x: min(...rs.map((r)=>r.minX)),
        y: min(...rs.map((r)=>r.minY))
    };
    const pMax = {
        x: max(...rs.map((r)=>r.maxX)),
        y: max(...rs.map((r)=>r.maxY))
    };
    return getRectFromPoints(pMin, pMax);
}
// src/from-range.ts
function fromRange(range) {
    let rs = [];
    const rects = Array.from(range.getClientRects());
    if (rects.length) {
        rs = rs.concat(rects.map(createRect));
        return union.apply(void 0, rs);
    }
    let start = range.startContainer;
    if (start.nodeType === Node.TEXT_NODE) {
        start = start.parentNode;
    }
    if (start instanceof HTMLElement) {
        const r = getElementRect(start);
        rs.push({
            ...r,
            x: r.maxX,
            width: 0
        });
    }
    return union.apply(void 0, rs);
}
// src/from-rotation.ts
function toRad(d) {
    return d % 360 * Math.PI / 180;
}
function rotate(a, d, c) {
    const r = toRad(d);
    const sin = Math.sin(r);
    const cos = Math.cos(r);
    const x = a.x - c.x;
    const y = a.y - c.y;
    return {
        x: c.x + x * cos - y * sin,
        y: c.y + x * sin + y * cos
    };
}
function getRotationRect(r, deg) {
    const rr = Object.values(getRectCorners(r)).map((p)=>rotate(p, deg, r.center));
    const xs = rr.map((p)=>p.x);
    const ys = rr.map((p)=>p.y);
    const minX = Math.min(...xs);
    const minY = Math.min(...ys);
    const maxX = Math.max(...xs);
    const maxY = Math.max(...ys);
    return createRect({
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    });
}
// src/from-window.ts
function getWindowRect(win, opts = {}) {
    return createRect(getViewportRect(win, opts));
}
function getViewportRect(win, opts) {
    const { excludeScrollbar = false } = opts;
    const { innerWidth, innerHeight, document: doc, visualViewport } = win;
    const width = visualViewport?.width || innerWidth;
    const height = visualViewport?.height || innerHeight;
    const rect = {
        x: 0,
        y: 0,
        width,
        height
    };
    if (excludeScrollbar) {
        const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;
        const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;
        rect.width -= scrollbarWidth;
        rect.height -= scrollbarHeight;
    }
    return rect;
}
// src/operations.ts
var isSymmetric = (v)=>"dx" in v || "dy" in v;
function inset(r, i) {
    const v = isSymmetric(i) ? {
        left: i.dx,
        right: i.dx,
        top: i.dy,
        bottom: i.dy
    } : i;
    const { top = 0, right = 0, bottom = 0, left = 0 } = v;
    return createRect({
        x: r.x + left,
        y: r.y + top,
        width: r.width - left - right,
        height: r.height - top - bottom
    });
}
function expand(r, v) {
    const value = typeof v === "number" ? {
        dx: -v,
        dy: -v
    } : v;
    return inset(r, value);
}
function shrink(r, v) {
    const value = typeof v === "number" ? {
        dx: -v,
        dy: -v
    } : v;
    return inset(r, value);
}
function shift(r, o) {
    const { x = 0, y = 0 } = o;
    return createRect({
        x: r.x + x,
        y: r.y + y,
        width: r.width,
        height: r.height
    });
}
// src/polygon.ts
function getElementPolygon(rectValue, placement) {
    const rect = createRect(rectValue);
    const { top, right, left, bottom } = getRectCorners(rect);
    const [base] = placement.split("-");
    return ({
        top: [
            left,
            top,
            right,
            bottom
        ],
        right: [
            top,
            right,
            bottom,
            left
        ],
        bottom: [
            top,
            left,
            bottom,
            right
        ],
        left: [
            right,
            top,
            left,
            bottom
        ]
    })[base];
}
function isPointInPolygon(polygon, point) {
    const { x, y } = point;
    let c = false;
    for(let i = 0, j = polygon.length - 1; i < polygon.length; j = i++){
        const xi = polygon[i].x;
        const yi = polygon[i].y;
        const xj = polygon[j].x;
        const yj = polygon[j].y;
        if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
            c = !c;
        }
    }
    return c;
}
function createPolygonElement() {
    const id = "debug-polygon";
    const existingPolygon = document.getElementById(id);
    if (existingPolygon) {
        return existingPolygon;
    }
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    Object.assign(svg.style, {
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        opacity: "0.15",
        position: "fixed",
        pointerEvents: "none",
        fill: "red"
    });
    const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    polygon.setAttribute("id", id);
    polygon.setAttribute("points", "0,0 0,0");
    svg.appendChild(polygon);
    document.body.appendChild(svg);
    return polygon;
}
function debugPolygon(polygon) {
    const el = createPolygonElement();
    const points = polygon.map((point)=>`${point.x},${point.y}`).join(" ");
    el.setAttribute("points", points);
    return ()=>{
        el.remove();
    };
}
// src/compass.ts
var compassDirectionMap = {
    n: {
        x: 0.5,
        y: 0
    },
    ne: {
        x: 1,
        y: 0
    },
    e: {
        x: 1,
        y: 0.5
    },
    se: {
        x: 1,
        y: 1
    },
    s: {
        x: 0.5,
        y: 1
    },
    sw: {
        x: 0,
        y: 1
    },
    w: {
        x: 0,
        y: 0.5
    },
    nw: {
        x: 0,
        y: 0
    }
};
var oppositeDirectionMap = {
    n: "s",
    ne: "sw",
    e: "w",
    se: "nw",
    s: "n",
    sw: "ne",
    w: "e",
    nw: "se"
};
// src/resize.ts
var { sign, abs, min: min2 } = Math;
function getRectExtentPoint(rect, direction) {
    const { minX, minY, maxX, maxY, midX, midY } = rect;
    const x = direction.includes("w") ? minX : direction.includes("e") ? maxX : midX;
    const y = direction.includes("n") ? minY : direction.includes("s") ? maxY : midY;
    return {
        x,
        y
    };
}
function getOppositeDirection(direction) {
    return oppositeDirectionMap[direction];
}
function resizeRect(rect, offset, direction, opts) {
    const { scalingOriginMode, lockAspectRatio } = opts;
    const extent = getRectExtentPoint(rect, direction);
    const oppositeDirection = getOppositeDirection(direction);
    const oppositeExtent = getRectExtentPoint(rect, oppositeDirection);
    if (scalingOriginMode === "center") {
        offset = {
            x: offset.x * 2,
            y: offset.y * 2
        };
    }
    const newExtent = {
        x: extent.x + offset.x,
        y: extent.y + offset.y
    };
    const multiplier = {
        x: compassDirectionMap[direction].x * 2 - 1,
        y: compassDirectionMap[direction].y * 2 - 1
    };
    const newSize = {
        width: newExtent.x - oppositeExtent.x,
        height: newExtent.y - oppositeExtent.y
    };
    const scaleX = multiplier.x * newSize.width / rect.width;
    const scaleY = multiplier.y * newSize.height / rect.height;
    const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY;
    const scale = lockAspectRatio ? {
        x: largestMagnitude,
        y: largestMagnitude
    } : {
        x: extent.x === oppositeExtent.x ? 1 : scaleX,
        y: extent.y === oppositeExtent.y ? 1 : scaleY
    };
    if (extent.y === oppositeExtent.y) {
        scale.y = abs(scale.y);
    } else if (sign(scale.y) !== sign(scaleY)) {
        scale.y *= -1;
    }
    if (extent.x === oppositeExtent.x) {
        scale.x = abs(scale.x);
    } else if (sign(scale.x) !== sign(scaleX)) {
        scale.x *= -1;
    }
    switch(scalingOriginMode){
        case "extent":
            return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false);
        case "center":
            return transformRect(rect, AffineTransform.scale(scale.x, scale.y, {
                x: rect.midX,
                y: rect.midY
            }), false);
    }
}
function createRectFromPoints(initialPoint, finalPoint, normalized = true) {
    if (normalized) {
        return {
            x: min2(finalPoint.x, initialPoint.x),
            y: min2(finalPoint.y, initialPoint.y),
            width: abs(finalPoint.x - initialPoint.x),
            height: abs(finalPoint.y - initialPoint.y)
        };
    }
    return {
        x: initialPoint.x,
        y: initialPoint.y,
        width: finalPoint.x - initialPoint.x,
        height: finalPoint.y - initialPoint.y
    };
}
function transformRect(rect, transform, normalized = true) {
    const p1 = transform.applyTo({
        x: rect.minX,
        y: rect.minY
    });
    const p2 = transform.applyTo({
        x: rect.maxX,
        y: rect.maxY
    });
    return createRectFromPoints(p1, p2, normalized);
}
;
}}),
"[project]/node_modules/@zag-js/menu/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "itemGroupLabelProps": (()=>itemGroupLabelProps),
    "itemGroupProps": (()=>itemGroupProps),
    "itemProps": (()=>itemProps),
    "machine": (()=>machine),
    "optionItemProps": (()=>optionItemProps),
    "props": (()=>props),
    "splitItemGroupLabelProps": (()=>splitItemGroupLabelProps),
    "splitItemGroupProps": (()=>splitItemGroupProps),
    "splitItemProps": (()=>splitItemProps),
    "splitOptionItemProps": (()=>splitOptionItemProps),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/popper/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/store/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$rect$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/rect-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dismissable/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
// src/menu.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("menu").parts("arrow", "arrowTip", "content", "contextTrigger", "indicator", "item", "itemGroup", "itemGroupLabel", "itemIndicator", "itemText", "positioner", "separator", "trigger", "triggerItem");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getTriggerId: (ctx)=>ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`,
    getContextTriggerId: (ctx)=>ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`,
    getContentId: (ctx)=>ctx.ids?.content ?? `menu:${ctx.id}:content`,
    getArrowId: (ctx)=>ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`,
    getPositionerId: (ctx)=>ctx.ids?.positioner ?? `menu:${ctx.id}:popper`,
    getGroupId: (ctx, id)=>ctx.ids?.group?.(id) ?? `menu:${ctx.id}:group:${id}`,
    getGroupLabelId: (ctx, id)=>ctx.ids?.groupLabel?.(id) ?? `menu:${ctx.id}:group-label:${id}`,
    getContentEl: (ctx)=>dom.getById(ctx, dom.getContentId(ctx)),
    getPositionerEl: (ctx)=>dom.getById(ctx, dom.getPositionerId(ctx)),
    getTriggerEl: (ctx)=>dom.getById(ctx, dom.getTriggerId(ctx)),
    getHighlightedItemEl: (ctx)=>ctx.highlightedValue ? dom.getById(ctx, ctx.highlightedValue) : null,
    getArrowEl: (ctx)=>dom.getById(ctx, dom.getArrowId(ctx)),
    getElements: (ctx)=>{
        const ownerId = CSS.escape(dom.getContentId(ctx));
        const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["queryAll"])(dom.getContentEl(ctx), selector);
    },
    getFirstEl: (ctx)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["first"])(dom.getElements(ctx)),
    getLastEl: (ctx)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["last"])(dom.getElements(ctx)),
    getNextEl: (ctx, loop)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nextById"])(dom.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
    getPrevEl: (ctx, loop)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["prevById"])(dom.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
    getElemByKey: (ctx, key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getByTypeahead"])(dom.getElements(ctx), {
            state: ctx.typeaheadState,
            key,
            activeId: ctx.highlightedValue
        }),
    isTargetDisabled: (v)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
    },
    isTriggerItem: (el)=>{
        return !!el?.getAttribute("role")?.startsWith("menuitem") && !!el?.hasAttribute("aria-controls");
    },
    getOptionFromItemEl (el) {
        return {
            id: el.id,
            name: el.dataset.name,
            value: el.dataset.value,
            valueText: el.dataset.valueText,
            type: el.dataset.type
        };
    }
});
// src/menu.connect.ts
function connect(state, send, normalize) {
    const isSubmenu = state.context.isSubmenu;
    const isTypingAhead = state.context.isTypingAhead;
    const composite = state.context.composite;
    const open = state.hasTag("open");
    const popperStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacementStyles"])({
        ...state.context.positioning,
        placement: state.context.anchorPoint ? "bottom" : state.context.currentPlacement
    });
    function getItemState(props2) {
        return {
            disabled: !!props2.disabled,
            highlighted: state.context.highlightedValue === props2.value
        };
    }
    function getOptionItemProps(props2) {
        const valueText = props2.valueText ?? props2.value;
        return {
            ...props2,
            id: props2.value,
            valueText
        };
    }
    function getOptionItemState(props2) {
        const itemState = getItemState(getOptionItemProps(props2));
        return {
            ...itemState,
            checked: !!props2.checked
        };
    }
    function getItemProps(props2) {
        const { value: id, closeOnSelect, valueText } = props2;
        const itemState = getItemState(props2);
        return normalize.element({
            ...parts.item.attrs,
            id,
            role: "menuitem",
            "aria-disabled": itemState.disabled,
            "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
            "data-ownedby": dom.getContentId(state.context),
            "data-highlighted": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.highlighted),
            "data-valuetext": valueText,
            onDragStart (event) {
                const isLink = event.currentTarget.matches("a[href]");
                if (isLink) event.preventDefault();
            },
            onPointerMove (event) {
                if (itemState.disabled) return;
                if (event.pointerType !== "mouse") return;
                const target = event.currentTarget;
                if (itemState.highlighted) return;
                send({
                    type: "ITEM_POINTERMOVE",
                    id,
                    target,
                    closeOnSelect
                });
            },
            onPointerLeave (event) {
                if (itemState.disabled) return;
                if (event.pointerType !== "mouse") return;
                const pointerMoved = state.previousEvent.type.includes("POINTER");
                if (!pointerMoved) return;
                const target = event.currentTarget;
                send({
                    type: "ITEM_POINTERLEAVE",
                    id,
                    target,
                    closeOnSelect
                });
            },
            onPointerDown (event) {
                if (itemState.disabled) return;
                const target = event.currentTarget;
                send({
                    type: "ITEM_POINTERDOWN",
                    target,
                    id,
                    closeOnSelect
                });
            },
            onClick (event) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isDownloadingEvent"])(event)) return;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isOpeningInNewTab"])(event)) return;
                if (itemState.disabled) return;
                const target = event.currentTarget;
                send({
                    type: "ITEM_CLICK",
                    target,
                    id,
                    closeOnSelect
                });
            }
        });
    }
    return {
        highlightedValue: state.context.highlightedValue,
        open,
        setOpen (nextOpen) {
            if (nextOpen === open) return;
            send(nextOpen ? "OPEN" : "CLOSE");
        },
        setHighlightedValue (value) {
            send({
                type: "HIGHLIGHTED.SET",
                id: value
            });
        },
        setParent (parent) {
            send({
                type: "PARENT.SET",
                value: parent,
                id: parent.state.context.id
            });
        },
        setChild (child) {
            send({
                type: "CHILD.SET",
                value: child,
                id: child.state.context.id
            });
        },
        reposition (options = {}) {
            send({
                type: "POSITIONING.SET",
                options
            });
        },
        getContextTriggerProps () {
            return normalize.element({
                ...parts.contextTrigger.attrs,
                dir: state.context.dir,
                id: dom.getContextTriggerId(state.context),
                onPointerDown (event) {
                    if (event.pointerType === "mouse") return;
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    send({
                        type: "CONTEXT_MENU_START",
                        point
                    });
                },
                onPointerCancel (event) {
                    if (event.pointerType === "mouse") return;
                    send("CONTEXT_MENU_CANCEL");
                },
                onPointerMove (event) {
                    if (event.pointerType === "mouse") return;
                    send("CONTEXT_MENU_CANCEL");
                },
                onPointerUp (event) {
                    if (event.pointerType === "mouse") return;
                    send("CONTEXT_MENU_CANCEL");
                },
                onContextMenu (event) {
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    send({
                        type: "CONTEXT_MENU",
                        point
                    });
                    event.preventDefault();
                },
                style: {
                    WebkitTouchCallout: "none",
                    WebkitUserSelect: "none",
                    userSelect: "none"
                }
            });
        },
        getTriggerItemProps (childApi) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["mergeProps"])(getItemProps({
                value: childApi.getTriggerProps().id
            }), childApi.getTriggerProps());
        },
        getTriggerProps () {
            return normalize.button({
                ...isSubmenu ? parts.triggerItem.attrs : parts.trigger.attrs,
                "data-placement": state.context.currentPlacement,
                type: "button",
                dir: state.context.dir,
                id: dom.getTriggerId(state.context),
                "data-uid": state.context.id,
                "aria-haspopup": composite ? "menu" : "dialog",
                "aria-controls": dom.getContentId(state.context),
                "aria-expanded": open || void 0,
                "data-state": open ? "open" : "closed",
                onPointerMove (event) {
                    if (event.pointerType !== "mouse") return;
                    const disabled = dom.isTargetDisabled(event.currentTarget);
                    if (disabled || !isSubmenu) return;
                    send({
                        type: "TRIGGER_POINTERMOVE",
                        target: event.currentTarget
                    });
                },
                onPointerLeave (event) {
                    if (dom.isTargetDisabled(event.currentTarget)) return;
                    if (event.pointerType !== "mouse") return;
                    if (!isSubmenu) return;
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    send({
                        type: "TRIGGER_POINTERLEAVE",
                        target: event.currentTarget,
                        point
                    });
                },
                onPointerDown (event) {
                    if (dom.isTargetDisabled(event.currentTarget)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isContextMenuEvent"])(event)) return;
                    event.preventDefault();
                },
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (dom.isTargetDisabled(event.currentTarget)) return;
                    send({
                        type: "TRIGGER_CLICK",
                        target: event.currentTarget
                    });
                },
                onBlur () {
                    send("TRIGGER_BLUR");
                },
                onFocus () {
                    send("TRIGGER_FOCUS");
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    const keyMap = {
                        ArrowDown () {
                            send("ARROW_DOWN");
                        },
                        ArrowUp () {
                            send("ARROW_UP");
                        },
                        Enter () {
                            send({
                                type: "ARROW_DOWN",
                                src: "enter"
                            });
                        },
                        Space () {
                            send({
                                type: "ARROW_DOWN",
                                src: "space"
                            });
                        }
                    };
                    const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventKey"])(event, state.context);
                    const exec = keyMap[key];
                    if (exec) {
                        event.preventDefault();
                        exec(event);
                    }
                }
            });
        },
        getIndicatorProps () {
            return normalize.element({
                ...parts.indicator.attrs,
                dir: state.context.dir,
                "data-state": open ? "open" : "closed"
            });
        },
        getPositionerProps () {
            return normalize.element({
                ...parts.positioner.attrs,
                dir: state.context.dir,
                id: dom.getPositionerId(state.context),
                style: popperStyles.floating
            });
        },
        getArrowProps () {
            return normalize.element({
                id: dom.getArrowId(state.context),
                ...parts.arrow.attrs,
                dir: state.context.dir,
                style: popperStyles.arrow
            });
        },
        getArrowTipProps () {
            return normalize.element({
                ...parts.arrowTip.attrs,
                dir: state.context.dir,
                style: popperStyles.arrowTip
            });
        },
        getContentProps () {
            return normalize.element({
                ...parts.content.attrs,
                id: dom.getContentId(state.context),
                "aria-label": state.context["aria-label"],
                hidden: !open,
                "data-state": open ? "open" : "closed",
                role: composite ? "menu" : "dialog",
                tabIndex: 0,
                dir: state.context.dir,
                "aria-activedescendant": state.context.highlightedValue ?? void 0,
                "aria-labelledby": dom.getTriggerId(state.context),
                "data-placement": state.context.currentPlacement,
                onPointerEnter (event) {
                    if (event.pointerType !== "mouse") return;
                    send("MENU_POINTERENTER");
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isSelfTarget"])(event)) return;
                    const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
                    const sameMenu = target?.closest("[role=menu]") === event.currentTarget || target === event.currentTarget;
                    if (!sameMenu) return;
                    if (event.key === "Tab") {
                        const valid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isValidTabEvent"])(event);
                        if (!valid) {
                            event.preventDefault();
                            return;
                        }
                    }
                    const item = dom.getHighlightedItemEl(state.context);
                    const keyMap = {
                        ArrowDown () {
                            send("ARROW_DOWN");
                        },
                        ArrowUp () {
                            send("ARROW_UP");
                        },
                        ArrowLeft () {
                            send("ARROW_LEFT");
                        },
                        ArrowRight () {
                            send("ARROW_RIGHT");
                        },
                        Enter () {
                            send("ENTER");
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clickIfLink"])(item);
                        },
                        Space (event2) {
                            if (isTypingAhead) {
                                send({
                                    type: "TYPEAHEAD",
                                    key: event2.key
                                });
                            } else {
                                keyMap.Enter?.(event2);
                            }
                        },
                        Home () {
                            send("HOME");
                        },
                        End () {
                            send("END");
                        }
                    };
                    const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventKey"])(event, {
                        dir: state.context.dir
                    });
                    const exec = keyMap[key];
                    if (exec) {
                        exec(event);
                        event.stopPropagation();
                        event.preventDefault();
                        return;
                    }
                    if (!state.context.typeahead) return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isPrintableKey"])(event)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isModifierKey"])(event)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEditableElement"])(target)) return;
                    send({
                        type: "TYPEAHEAD",
                        key: event.key
                    });
                    event.preventDefault();
                }
            });
        },
        getSeparatorProps () {
            return normalize.element({
                ...parts.separator.attrs,
                role: "separator",
                dir: state.context.dir,
                "aria-orientation": "horizontal"
            });
        },
        getItemState,
        getItemProps,
        getOptionItemState,
        getOptionItemProps (props2) {
            const { type, disabled, onCheckedChange, closeOnSelect } = props2;
            const option = getOptionItemProps(props2);
            const itemState = getOptionItemState(props2);
            return {
                ...getItemProps(option),
                ...normalize.element({
                    "data-type": type,
                    ...parts.item.attrs,
                    dir: state.context.dir,
                    "data-value": option.value,
                    role: `menuitem${type}`,
                    "aria-checked": !!itemState.checked,
                    "data-state": itemState.checked ? "checked" : "unchecked",
                    onClick (event) {
                        if (disabled) return;
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isDownloadingEvent"])(event)) return;
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isOpeningInNewTab"])(event)) return;
                        const target = event.currentTarget;
                        send({
                            type: "ITEM_CLICK",
                            target,
                            option,
                            closeOnSelect
                        });
                        onCheckedChange?.(!itemState.checked);
                    }
                })
            };
        },
        getItemIndicatorProps (props2) {
            const itemState = getOptionItemState(props2);
            return normalize.element({
                ...parts.itemIndicator.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
                "data-highlighted": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.highlighted),
                "data-state": itemState.checked ? "checked" : "unchecked",
                hidden: !itemState.checked
            });
        },
        getItemTextProps (props2) {
            const itemState = getOptionItemState(props2);
            return normalize.element({
                ...parts.itemText.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
                "data-highlighted": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.highlighted),
                "data-state": itemState.checked ? "checked" : "unchecked"
            });
        },
        getItemGroupLabelProps (props2) {
            return normalize.element({
                id: dom.getGroupLabelId(state.context, props2.htmlFor),
                dir: state.context.dir,
                ...parts.itemGroupLabel.attrs
            });
        },
        getItemGroupProps (props2) {
            return normalize.element({
                id: dom.getGroupId(state.context, props2.id),
                ...parts.itemGroup.attrs,
                dir: state.context.dir,
                "aria-labelledby": dom.getGroupLabelId(state.context, props2.id),
                role: "group"
            });
        }
    };
}
var { not, and, or } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guards"];
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "menu",
        initial: ctx.open ? "open" : "idle",
        context: {
            highlightedValue: null,
            loopFocus: false,
            anchorPoint: null,
            closeOnSelect: true,
            typeahead: true,
            composite: true,
            ...ctx,
            positioning: {
                placement: "bottom-start",
                gutter: 8,
                ...ctx.positioning
            },
            intentPolygon: null,
            parent: null,
            lastHighlightedValue: null,
            children: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["cast"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])({})),
            suspendPointer: false,
            restoreFocus: true,
            typeaheadState: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getByTypeahead"].defaultOptions
        },
        computed: {
            isSubmenu: (ctx2)=>ctx2.parent !== null,
            isRtl: (ctx2)=>ctx2.dir === "rtl",
            isTypingAhead: (ctx2)=>ctx2.typeaheadState.keysSoFar !== ""
        },
        watch: {
            isSubmenu: "setSubmenuPlacement",
            anchorPoint: "reposition",
            open: "toggleVisibility"
        },
        on: {
            "PARENT.SET": {
                actions: "setParentMenu"
            },
            "CHILD.SET": {
                actions: "setChildMenu"
            },
            OPEN: [
                {
                    guard: "isOpenControlled",
                    actions: "invokeOnOpen"
                },
                {
                    target: "open",
                    actions: "invokeOnOpen"
                }
            ],
            OPEN_AUTOFOCUS: [
                {
                    guard: "isOpenControlled",
                    actions: [
                        "invokeOnOpen"
                    ]
                },
                {
                    internal: true,
                    target: "open",
                    actions: [
                        "highlightFirstItem",
                        "invokeOnOpen"
                    ]
                }
            ],
            CLOSE: [
                {
                    guard: "isOpenControlled",
                    actions: "invokeOnClose"
                },
                {
                    target: "closed",
                    actions: "invokeOnClose"
                }
            ],
            "HIGHLIGHTED.RESTORE": {
                actions: "restoreHighlightedItem"
            },
            "HIGHLIGHTED.SET": {
                actions: "setHighlightedItem"
            }
        },
        states: {
            idle: {
                tags: [
                    "closed"
                ],
                on: {
                    "CONTROLLED.OPEN": "open",
                    "CONTROLLED.CLOSE": "closed",
                    CONTEXT_MENU_START: {
                        target: "opening:contextmenu",
                        actions: "setAnchorPoint"
                    },
                    CONTEXT_MENU: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "setAnchorPoint",
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setAnchorPoint",
                                "invokeOnOpen"
                            ]
                        }
                    ],
                    TRIGGER_CLICK: [
                        {
                            guard: "isOpenControlled",
                            actions: "invokeOnOpen"
                        },
                        {
                            target: "open",
                            actions: "invokeOnOpen"
                        }
                    ],
                    TRIGGER_FOCUS: {
                        guard: not("isSubmenu"),
                        target: "closed"
                    },
                    TRIGGER_POINTERMOVE: {
                        guard: "isSubmenu",
                        target: "opening"
                    }
                }
            },
            "opening:contextmenu": {
                tags: [
                    "closed"
                ],
                after: {
                    LONG_PRESS_DELAY: [
                        {
                            guard: "isOpenControlled",
                            actions: "invokeOnOpen"
                        },
                        {
                            target: "open",
                            actions: "invokeOnOpen"
                        }
                    ]
                },
                on: {
                    "CONTROLLED.OPEN": "open",
                    "CONTROLLED.CLOSE": "closed",
                    CONTEXT_MENU_CANCEL: [
                        {
                            guard: "isOpenControlled",
                            actions: "invokeOnClose"
                        },
                        {
                            target: "closed",
                            actions: "invokeOnClose"
                        }
                    ]
                }
            },
            opening: {
                tags: [
                    "closed"
                ],
                after: {
                    SUBMENU_OPEN_DELAY: [
                        {
                            guard: "isOpenControlled",
                            actions: "invokeOnOpen"
                        },
                        {
                            target: "open",
                            actions: "invokeOnOpen"
                        }
                    ]
                },
                on: {
                    "CONTROLLED.OPEN": "open",
                    "CONTROLLED.CLOSE": "closed",
                    BLUR: [
                        {
                            guard: "isOpenControlled",
                            actions: "invokeOnClose"
                        },
                        {
                            target: "closed",
                            actions: "invokeOnClose"
                        }
                    ],
                    TRIGGER_POINTERLEAVE: [
                        {
                            guard: "isOpenControlled",
                            actions: "invokeOnClose"
                        },
                        {
                            target: "closed",
                            actions: "invokeOnClose"
                        }
                    ]
                }
            },
            closing: {
                tags: [
                    "open"
                ],
                activities: [
                    "trackPointerMove",
                    "trackInteractOutside"
                ],
                after: {
                    SUBMENU_CLOSE_DELAY: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "focusParentMenu",
                                "restoreParentHiglightedItem",
                                "invokeOnClose"
                            ]
                        }
                    ]
                },
                on: {
                    "CONTROLLED.OPEN": "open",
                    "CONTROLLED.CLOSE": {
                        target: "closed",
                        actions: [
                            "focusParentMenu",
                            "restoreParentHiglightedItem"
                        ]
                    },
                    // don't invoke on open here since the menu is still open (we're only keeping it open)
                    MENU_POINTERENTER: {
                        target: "open",
                        actions: "clearIntentPolygon"
                    },
                    POINTER_MOVED_AWAY_FROM_SUBMENU: [
                        {
                            guard: "isOpenControlled",
                            actions: "invokeOnClose"
                        },
                        {
                            target: "closed",
                            actions: [
                                "focusParentMenu",
                                "restoreParentHiglightedItem"
                            ]
                        }
                    ]
                }
            },
            closed: {
                tags: [
                    "closed"
                ],
                entry: [
                    "clearHighlightedItem",
                    "focusTrigger",
                    "resumePointer"
                ],
                on: {
                    "CONTROLLED.OPEN": [
                        {
                            guard: or("isOpenAutoFocusEvent", "isArrowDownEvent"),
                            target: "open",
                            actions: "highlightFirstItem"
                        },
                        {
                            guard: "isArrowUpEvent",
                            target: "open",
                            actions: "highlightLastItem"
                        },
                        {
                            target: "open"
                        }
                    ],
                    CONTEXT_MENU_START: {
                        target: "opening:contextmenu",
                        actions: "setAnchorPoint"
                    },
                    CONTEXT_MENU: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "setAnchorPoint",
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setAnchorPoint",
                                "invokeOnOpen"
                            ]
                        }
                    ],
                    TRIGGER_CLICK: [
                        {
                            guard: "isOpenControlled",
                            actions: "invokeOnOpen"
                        },
                        {
                            target: "open",
                            actions: "invokeOnOpen"
                        }
                    ],
                    TRIGGER_POINTERMOVE: {
                        guard: "isTriggerItem",
                        target: "opening"
                    },
                    TRIGGER_BLUR: "idle",
                    ARROW_DOWN: [
                        {
                            guard: "isOpenControlled",
                            actions: "invokeOnOpen"
                        },
                        {
                            target: "open",
                            actions: [
                                "highlightFirstItem",
                                "invokeOnOpen"
                            ]
                        }
                    ],
                    ARROW_UP: [
                        {
                            guard: "isOpenControlled",
                            actions: "invokeOnOpen"
                        },
                        {
                            target: "open",
                            actions: [
                                "highlightLastItem",
                                "invokeOnOpen"
                            ]
                        }
                    ]
                }
            },
            open: {
                tags: [
                    "open"
                ],
                activities: [
                    "trackInteractOutside",
                    "trackPositioning",
                    "scrollToHighlightedItem"
                ],
                entry: [
                    "focusMenu",
                    "resumePointer"
                ],
                on: {
                    "CONTROLLED.CLOSE": [
                        {
                            target: "closed",
                            guard: "isArrowLeftEvent",
                            actions: [
                                "focusParentMenu"
                            ]
                        },
                        {
                            target: "closed"
                        }
                    ],
                    TRIGGER_CLICK: [
                        {
                            guard: and(not("isTriggerItem"), "isOpenControlled"),
                            actions: "invokeOnClose"
                        },
                        {
                            guard: not("isTriggerItem"),
                            target: "closed",
                            actions: "invokeOnClose"
                        }
                    ],
                    ARROW_UP: {
                        actions: [
                            "highlightPrevItem",
                            "focusMenu"
                        ]
                    },
                    ARROW_DOWN: {
                        actions: [
                            "highlightNextItem",
                            "focusMenu"
                        ]
                    },
                    ARROW_LEFT: [
                        {
                            guard: and("isSubmenu", "isOpenControlled"),
                            actions: "invokeOnClose"
                        },
                        {
                            guard: "isSubmenu",
                            target: "closed",
                            actions: [
                                "focusParentMenu",
                                "invokeOnClose"
                            ]
                        }
                    ],
                    HOME: {
                        actions: [
                            "highlightFirstItem",
                            "focusMenu"
                        ]
                    },
                    END: {
                        actions: [
                            "highlightLastItem",
                            "focusMenu"
                        ]
                    },
                    ARROW_RIGHT: {
                        guard: "isTriggerItemHighlighted",
                        actions: "openSubmenu"
                    },
                    ENTER: [
                        {
                            guard: "isTriggerItemHighlighted",
                            actions: "openSubmenu"
                        },
                        {
                            actions: "clickHighlightedItem"
                        }
                    ],
                    ITEM_POINTERMOVE: [
                        {
                            guard: not("suspendPointer"),
                            actions: [
                                "setHighlightedItem",
                                "focusMenu"
                            ]
                        },
                        {
                            actions: "setLastHighlightedItem"
                        }
                    ],
                    ITEM_POINTERLEAVE: {
                        guard: and(not("suspendPointer"), not("isTriggerItem")),
                        actions: "clearHighlightedItem"
                    },
                    ITEM_CLICK: [
                        // == grouped ==
                        {
                            guard: and(not("isTriggerItemHighlighted"), not("isHighlightedItemEditable"), "closeOnSelect", "isOpenControlled"),
                            actions: [
                                "invokeOnSelect",
                                "setOptionState",
                                "closeRootMenu",
                                "invokeOnClose"
                            ]
                        },
                        {
                            guard: and(not("isTriggerItemHighlighted"), not("isHighlightedItemEditable"), "closeOnSelect"),
                            target: "closed",
                            actions: [
                                "invokeOnSelect",
                                "setOptionState",
                                "closeRootMenu",
                                "invokeOnClose"
                            ]
                        },
                        //
                        {
                            guard: and(not("isTriggerItemHighlighted"), not("isHighlightedItemEditable")),
                            actions: [
                                "invokeOnSelect",
                                "setOptionState"
                            ]
                        },
                        {
                            actions: "setHighlightedItem"
                        }
                    ],
                    TRIGGER_POINTERLEAVE: {
                        target: "closing",
                        actions: "setIntentPolygon"
                    },
                    ITEM_POINTERDOWN: {
                        actions: "setHighlightedItem"
                    },
                    TYPEAHEAD: {
                        actions: "highlightMatchedItem"
                    },
                    FOCUS_MENU: {
                        actions: "focusMenu"
                    },
                    "POSITIONING.SET": {
                        actions: "reposition"
                    }
                }
            }
        }
    }, {
        delays: {
            LONG_PRESS_DELAY: 700,
            SUBMENU_OPEN_DELAY: 100,
            SUBMENU_CLOSE_DELAY: 100
        },
        guards: {
            closeOnSelect: (ctx2, evt)=>!!(evt?.closeOnSelect ?? ctx2.closeOnSelect),
            // whether the trigger is also a menu item
            isTriggerItem: (_ctx, evt)=>dom.isTriggerItem(evt.target),
            // whether the trigger item is the active item
            isTriggerItemHighlighted: (ctx2, evt)=>{
                const target = evt.target ?? dom.getHighlightedItemEl(ctx2);
                return !!target?.hasAttribute("aria-controls");
            },
            isSubmenu: (ctx2)=>ctx2.isSubmenu,
            suspendPointer: (ctx2)=>ctx2.suspendPointer,
            isHighlightedItemEditable: (ctx2)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEditableElement"])(dom.getHighlightedItemEl(ctx2)),
            isWithinPolygon: (ctx2, evt)=>{
                if (!ctx2.intentPolygon) return false;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$rect$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isPointInPolygon"])(ctx2.intentPolygon, evt.point);
            },
            // guard assertions (for controlled mode)
            isOpenControlled: (ctx2)=>!!ctx2["open.controlled"],
            isArrowLeftEvent: (_ctx, evt)=>evt.previousEvent?.type === "ARROW_LEFT",
            isArrowUpEvent: (_ctx, evt)=>evt.previousEvent?.type === "ARROW_UP",
            isArrowDownEvent: (_ctx, evt)=>evt.previousEvent?.type === "ARROW_DOWN",
            isOpenAutoFocusEvent: (_ctx, evt)=>evt.previousEvent?.type === "OPEN_AUTOFOCUS"
        },
        activities: {
            trackPositioning (ctx2) {
                if (ctx2.anchorPoint) return;
                ctx2.currentPlacement = ctx2.positioning.placement;
                const getPositionerEl = ()=>dom.getPositionerEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(dom.getTriggerEl(ctx2), getPositionerEl, {
                    ...ctx2.positioning,
                    defer: true,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            trackInteractOutside (ctx2, _evt, { send }) {
                const getContentEl = ()=>dom.getContentEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackDismissableElement"])(getContentEl, {
                    defer: true,
                    exclude: [
                        dom.getTriggerEl(ctx2)
                    ],
                    onInteractOutside: ctx2.onInteractOutside,
                    onFocusOutside: ctx2.onFocusOutside,
                    onEscapeKeyDown (event) {
                        ctx2.onEscapeKeyDown?.(event);
                        if (ctx2.isSubmenu) event.preventDefault();
                        closeRootMenu(ctx2);
                    },
                    onPointerDownOutside (event) {
                        ctx2.restoreFocus = !event.detail.focusable;
                        ctx2.onPointerDownOutside?.(event);
                    },
                    onDismiss () {
                        send({
                            type: "CLOSE",
                            src: "interact-outside"
                        });
                    }
                });
            },
            trackPointerMove (ctx2, _evt, { guards: guards2, send }) {
                const { isWithinPolygon } = guards2;
                ctx2.parent.state.context.suspendPointer = true;
                const doc = dom.getDoc(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])(doc, "pointermove", (e)=>{
                    const point = {
                        x: e.clientX,
                        y: e.clientY
                    };
                    const isMovingToSubmenu = isWithinPolygon(ctx2, {
                        point
                    });
                    if (!isMovingToSubmenu) {
                        send("POINTER_MOVED_AWAY_FROM_SUBMENU");
                        ctx2.parent.state.context.suspendPointer = false;
                    }
                });
            },
            scrollToHighlightedItem (ctx2, _evt, { getState }) {
                const exec = ()=>{
                    const state = getState();
                    if (state.event.type.startsWith("ITEM_POINTER")) return;
                    const itemEl = dom.getHighlightedItemEl(ctx2);
                    const contentEl2 = dom.getContentEl(ctx2);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scrollIntoView"])(itemEl, {
                        rootEl: contentEl2,
                        block: "nearest"
                    });
                };
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>exec());
                const contentEl = ()=>dom.getContentEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["observeAttributes"])(contentEl, {
                    defer: true,
                    attributes: [
                        "aria-activedescendant"
                    ],
                    callback: exec
                });
            }
        },
        actions: {
            setAnchorPoint (ctx2, evt) {
                ctx2.anchorPoint = evt.point;
            },
            setSubmenuPlacement (ctx2) {
                if (!ctx2.isSubmenu) return;
                ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
                ctx2.positioning.gutter = 0;
            },
            reposition (ctx2, evt) {
                const getPositionerEl = ()=>dom.getPositionerEl(ctx2);
                const getAnchorRect = ctx2.anchorPoint ? ()=>({
                        width: 0,
                        height: 0,
                        ...ctx2.anchorPoint
                    }) : void 0;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(dom.getTriggerEl(ctx2), getPositionerEl, {
                    ...ctx2.positioning,
                    defer: true,
                    getAnchorRect,
                    ...evt.options ?? {},
                    listeners: false,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            setOptionState (_ctx, evt) {
                if (!evt.option) return;
                const { checked, onCheckedChange, type } = evt.option;
                if (type === "radio") {
                    onCheckedChange?.(true);
                } else if (type === "checkbox") {
                    onCheckedChange?.(!checked);
                }
            },
            clickHighlightedItem (ctx2, _evt) {
                const itemEl = dom.getHighlightedItemEl(ctx2);
                if (!itemEl || itemEl.dataset.disabled) return;
                queueMicrotask(()=>itemEl.click());
            },
            setIntentPolygon (ctx2, evt) {
                const menu = dom.getContentEl(ctx2);
                const placement = ctx2.currentPlacement;
                if (!menu || !placement) return;
                const rect = menu.getBoundingClientRect();
                const polygon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$rect$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getElementPolygon"])(rect, placement);
                if (!polygon) return;
                const rightSide = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacementSide"])(placement) === "right";
                const bleed = rightSide ? -5 : 5;
                ctx2.intentPolygon = [
                    {
                        ...evt.point,
                        x: evt.point.x + bleed
                    },
                    ...polygon
                ];
            },
            clearIntentPolygon (ctx2) {
                ctx2.intentPolygon = null;
            },
            resumePointer (ctx2) {
                if (!ctx2.parent) return;
                ctx2.parent.state.context.suspendPointer = false;
            },
            setHighlightedItem (ctx2, evt) {
                set.highlighted(ctx2, evt.id);
            },
            clearHighlightedItem (ctx2) {
                set.highlighted(ctx2, null);
            },
            focusMenu (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const contentEl = dom.getContentEl(ctx2);
                    const initialFocusEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getInitialFocus"])({
                        root: contentEl,
                        enabled: !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["contains"])(contentEl, dom.getActiveElement(ctx2)),
                        filter (node) {
                            return !node.role?.startsWith("menuitem");
                        }
                    });
                    initialFocusEl?.focus({
                        preventScroll: true
                    });
                });
            },
            highlightFirstItem (ctx2) {
                const fn = !!dom.getContentEl(ctx2) ? queueMicrotask : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"];
                fn(()=>{
                    const first2 = dom.getFirstEl(ctx2);
                    if (!first2) return;
                    set.highlighted(ctx2, first2.id);
                });
            },
            highlightLastItem (ctx2) {
                const fn = !!dom.getContentEl(ctx2) ? queueMicrotask : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"];
                fn(()=>{
                    const last2 = dom.getLastEl(ctx2);
                    if (!last2) return;
                    set.highlighted(ctx2, last2.id);
                });
            },
            highlightNextItem (ctx2, evt) {
                const next = dom.getNextEl(ctx2, evt.loop);
                set.highlighted(ctx2, next?.id ?? null);
            },
            highlightPrevItem (ctx2, evt) {
                const prev = dom.getPrevEl(ctx2, evt.loop);
                set.highlighted(ctx2, prev?.id ?? null);
            },
            invokeOnSelect (ctx2) {
                if (!ctx2.highlightedValue) return;
                ctx2.onSelect?.({
                    value: ctx2.highlightedValue
                });
            },
            focusTrigger (ctx2) {
                if (ctx2.isSubmenu || ctx2.anchorPoint || !ctx2.restoreFocus) return;
                queueMicrotask(()=>dom.getTriggerEl(ctx2)?.focus({
                        preventScroll: true
                    }));
            },
            highlightMatchedItem (ctx2, evt) {
                const node = dom.getElemByKey(ctx2, evt.key);
                if (!node) return;
                set.highlighted(ctx2, node.id);
            },
            setParentMenu (ctx2, evt) {
                ctx2.parent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(evt.value);
            },
            setChildMenu (ctx2, evt) {
                ctx2.children[evt.id] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(evt.value);
            },
            closeRootMenu (ctx2) {
                closeRootMenu(ctx2);
            },
            openSubmenu (ctx2) {
                const item = dom.getHighlightedItemEl(ctx2);
                const id = item?.getAttribute("data-uid");
                const child = id ? ctx2.children[id] : null;
                child?.send("OPEN_AUTOFOCUS");
            },
            focusParentMenu (ctx2) {
                ctx2.parent?.send("FOCUS_MENU");
            },
            setLastHighlightedItem (ctx2, evt) {
                ctx2.lastHighlightedValue = evt.id;
            },
            restoreHighlightedItem (ctx2) {
                if (!ctx2.lastHighlightedValue) return;
                set.highlighted(ctx2, ctx2.lastHighlightedValue);
                ctx2.lastHighlightedValue = null;
            },
            restoreParentHiglightedItem (ctx2) {
                ctx2.parent?.send("HIGHLIGHTED.RESTORE");
            },
            invokeOnOpen (ctx2) {
                ctx2.onOpenChange?.({
                    open: true
                });
            },
            invokeOnClose (ctx2) {
                ctx2.onOpenChange?.({
                    open: false
                });
            },
            toggleVisibility (ctx2, evt, { send }) {
                send({
                    type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
                    previousEvent: evt
                });
            }
        }
    });
}
function closeRootMenu(ctx) {
    let parent = ctx.parent;
    while(parent && parent.state.context.isSubmenu){
        parent = parent.state.context.parent;
    }
    parent?.send("CLOSE");
}
var set = {
    highlighted (ctx, value) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.highlightedValue, value)) return;
        ctx.highlightedValue = value;
        ctx.onHighlightChange?.({
            highlightedValue: value
        });
    }
};
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "anchorPoint",
    "aria-label",
    "closeOnSelect",
    "dir",
    "getRootNode",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "onFocusOutside",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onEscapeKeyDown",
    "onSelect",
    "onHighlightChange",
    "open",
    "open.controlled",
    "positioning",
    "typeahead",
    "composite"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
var itemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
]);
var splitItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(itemProps);
var itemGroupLabelProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "htmlFor"
]);
var splitItemGroupLabelProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(itemGroupLabelProps);
var itemGroupProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "id"
]);
var splitItemGroupProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(itemGroupProps);
var optionItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "disabled",
    "valueText",
    "closeOnSelect",
    "type",
    "value",
    "checked",
    "onCheckedChange"
]);
var splitOptionItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(optionItemProps);
;
}}),
"[project]/node_modules/@zag-js/menu/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as menuAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "menuAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$menu$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$menu$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/menu/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/popover/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/popper/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dismissable/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$aria$2d$hidden$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/aria-hidden/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$remove$2d$scroll$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/remove-scroll/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$focus$2d$trap$2f$dist$2f$focus$2d$trap$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/focus-trap/dist/focus-trap.esm.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
// src/popover.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("popover").parts("arrow", "arrowTip", "anchor", "trigger", "indicator", "positioner", "content", "title", "description", "closeTrigger");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getAnchorId: (ctx)=>ctx.ids?.anchor ?? `popover:${ctx.id}:anchor`,
    getTriggerId: (ctx)=>ctx.ids?.trigger ?? `popover:${ctx.id}:trigger`,
    getContentId: (ctx)=>ctx.ids?.content ?? `popover:${ctx.id}:content`,
    getPositionerId: (ctx)=>ctx.ids?.positioner ?? `popover:${ctx.id}:popper`,
    getArrowId: (ctx)=>ctx.ids?.arrow ?? `popover:${ctx.id}:arrow`,
    getTitleId: (ctx)=>ctx.ids?.title ?? `popover:${ctx.id}:title`,
    getDescriptionId: (ctx)=>ctx.ids?.description ?? `popover:${ctx.id}:desc`,
    getCloseTriggerId: (ctx)=>ctx.ids?.closeTrigger ?? `popover:${ctx.id}:close`,
    getAnchorEl: (ctx)=>dom.getById(ctx, dom.getAnchorId(ctx)),
    getTriggerEl: (ctx)=>dom.getById(ctx, dom.getTriggerId(ctx)),
    getContentEl: (ctx)=>dom.getById(ctx, dom.getContentId(ctx)),
    getPositionerEl: (ctx)=>dom.getById(ctx, dom.getPositionerId(ctx)),
    getTitleEl: (ctx)=>dom.getById(ctx, dom.getTitleId(ctx)),
    getDescriptionEl: (ctx)=>dom.getById(ctx, dom.getDescriptionId(ctx)),
    getFocusableEls: (ctx)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getFocusables"])(dom.getContentEl(ctx)),
    getFirstFocusableEl: (ctx)=>dom.getFocusableEls(ctx)[0]
});
// src/popover.connect.ts
function connect(state, send, normalize) {
    const open = state.matches("open");
    const currentPlacement = state.context.currentPlacement;
    const portalled = state.context.currentPortalled;
    const rendered = state.context.renderedElements;
    const popperStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacementStyles"])({
        ...state.context.positioning,
        placement: currentPlacement
    });
    return {
        portalled,
        open,
        setOpen (nextOpen) {
            if (nextOpen === open) return;
            send(nextOpen ? "OPEN" : "CLOSE");
        },
        reposition (options = {}) {
            send({
                type: "POSITIONING.SET",
                options
            });
        },
        getArrowProps () {
            return normalize.element({
                id: dom.getArrowId(state.context),
                ...parts.arrow.attrs,
                dir: state.context.dir,
                style: popperStyles.arrow
            });
        },
        getArrowTipProps () {
            return normalize.element({
                ...parts.arrowTip.attrs,
                dir: state.context.dir,
                style: popperStyles.arrowTip
            });
        },
        getAnchorProps () {
            return normalize.element({
                ...parts.anchor.attrs,
                dir: state.context.dir,
                id: dom.getAnchorId(state.context)
            });
        },
        getTriggerProps () {
            return normalize.button({
                ...parts.trigger.attrs,
                dir: state.context.dir,
                type: "button",
                "data-placement": currentPlacement,
                id: dom.getTriggerId(state.context),
                "aria-haspopup": "dialog",
                "aria-expanded": open,
                "data-state": open ? "open" : "closed",
                "aria-controls": dom.getContentId(state.context),
                onPointerDown (event) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isSafari"])()) {
                        event.currentTarget.focus();
                    }
                },
                onClick (event) {
                    if (event.defaultPrevented) return;
                    send("TOGGLE");
                },
                onBlur (event) {
                    send({
                        type: "TRIGGER_BLUR",
                        target: event.relatedTarget
                    });
                }
            });
        },
        getIndicatorProps () {
            return normalize.element({
                ...parts.indicator.attrs,
                dir: state.context.dir,
                "data-state": open ? "open" : "closed"
            });
        },
        getPositionerProps () {
            return normalize.element({
                id: dom.getPositionerId(state.context),
                ...parts.positioner.attrs,
                dir: state.context.dir,
                style: popperStyles.floating
            });
        },
        getContentProps () {
            return normalize.element({
                ...parts.content.attrs,
                dir: state.context.dir,
                id: dom.getContentId(state.context),
                tabIndex: -1,
                role: "dialog",
                hidden: !open,
                "data-state": open ? "open" : "closed",
                "data-expanded": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(open),
                "aria-labelledby": rendered.title ? dom.getTitleId(state.context) : void 0,
                "aria-describedby": rendered.description ? dom.getDescriptionId(state.context) : void 0,
                "data-placement": currentPlacement
            });
        },
        getTitleProps () {
            return normalize.element({
                ...parts.title.attrs,
                id: dom.getTitleId(state.context),
                dir: state.context.dir
            });
        },
        getDescriptionProps () {
            return normalize.element({
                ...parts.description.attrs,
                id: dom.getDescriptionId(state.context),
                dir: state.context.dir
            });
        },
        getCloseTriggerProps () {
            return normalize.button({
                ...parts.closeTrigger.attrs,
                dir: state.context.dir,
                id: dom.getCloseTriggerId(state.context),
                type: "button",
                "aria-label": "close",
                onClick (event) {
                    if (event.defaultPrevented) return;
                    send("CLOSE");
                }
            });
        }
    };
}
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "popover",
        initial: ctx.open ? "open" : "closed",
        context: {
            closeOnInteractOutside: true,
            closeOnEscape: true,
            autoFocus: true,
            modal: false,
            portalled: true,
            positioning: {
                placement: "bottom",
                ...ctx.positioning
            },
            currentPlacement: void 0,
            ...ctx,
            renderedElements: {
                title: true,
                description: true
            }
        },
        computed: {
            currentPortalled: (ctx2)=>!!ctx2.modal || !!ctx2.portalled
        },
        watch: {
            open: [
                "toggleVisibility"
            ]
        },
        entry: [
            "checkRenderedElements"
        ],
        states: {
            closed: {
                on: {
                    "CONTROLLED.OPEN": {
                        target: "open",
                        actions: [
                            "setInitialFocus"
                        ]
                    },
                    TOGGLE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen",
                                "setInitialFocus"
                            ]
                        }
                    ],
                    OPEN: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen",
                                "setInitialFocus"
                            ]
                        }
                    ]
                }
            },
            open: {
                activities: [
                    "trapFocus",
                    "preventScroll",
                    "hideContentBelow",
                    "trackPositioning",
                    "trackDismissableElement",
                    "proxyTabFocus"
                ],
                on: {
                    "CONTROLLED.CLOSE": {
                        target: "closed",
                        actions: [
                            "setFinalFocus"
                        ]
                    },
                    CLOSE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "invokeOnClose",
                                "setFinalFocus"
                            ]
                        }
                    ],
                    TOGGLE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    "POSITIONING.SET": {
                        actions: "reposition"
                    }
                }
            }
        }
    }, {
        guards: {
            isOpenControlled: (ctx2)=>!!ctx2["open.controlled"]
        },
        activities: {
            trackPositioning (ctx2) {
                ctx2.currentPlacement = ctx2.positioning.placement;
                const anchorEl = dom.getAnchorEl(ctx2) ?? dom.getTriggerEl(ctx2);
                const getPositionerEl = ()=>dom.getPositionerEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(anchorEl, getPositionerEl, {
                    ...ctx2.positioning,
                    defer: true,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            trackDismissableElement (ctx2, _evt, { send }) {
                const getContentEl = ()=>dom.getContentEl(ctx2);
                let restoreFocus = true;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackDismissableElement"])(getContentEl, {
                    pointerBlocking: ctx2.modal,
                    exclude: dom.getTriggerEl(ctx2),
                    defer: true,
                    onEscapeKeyDown (event) {
                        ctx2.onEscapeKeyDown?.(event);
                        if (ctx2.closeOnEscape) return;
                        event.preventDefault();
                    },
                    onInteractOutside (event) {
                        ctx2.onInteractOutside?.(event);
                        if (event.defaultPrevented) return;
                        restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
                        if (!ctx2.closeOnInteractOutside) {
                            event.preventDefault();
                        }
                    },
                    onPointerDownOutside: ctx2.onPointerDownOutside,
                    onFocusOutside: ctx2.onFocusOutside,
                    persistentElements: ctx2.persistentElements,
                    onDismiss () {
                        send({
                            type: "CLOSE",
                            src: "interact-outside",
                            restoreFocus
                        });
                    }
                });
            },
            proxyTabFocus (ctx2) {
                if (ctx2.modal || !ctx2.portalled) return;
                const getContentEl = ()=>dom.getContentEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["proxyTabFocus"])(getContentEl, {
                    triggerElement: dom.getTriggerEl(ctx2),
                    defer: true,
                    onFocus (el) {
                        el.focus({
                            preventScroll: true
                        });
                    }
                });
            },
            hideContentBelow (ctx2) {
                if (!ctx2.modal) return;
                const getElements = ()=>[
                        dom.getContentEl(ctx2),
                        dom.getTriggerEl(ctx2)
                    ];
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$aria$2d$hidden$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaHidden"])(getElements, {
                    defer: true
                });
            },
            preventScroll (ctx2) {
                if (!ctx2.modal) return;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$remove$2d$scroll$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["preventBodyScroll"])(dom.getDoc(ctx2));
            },
            trapFocus (ctx2) {
                if (!ctx2.modal) return;
                let trap;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nextTick"])(()=>{
                    const contentEl = dom.getContentEl(ctx2);
                    if (!contentEl) return;
                    trap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$focus$2d$trap$2f$dist$2f$focus$2d$trap$2e$esm$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createFocusTrap"])(contentEl, {
                        escapeDeactivates: false,
                        allowOutsideClick: true,
                        preventScroll: true,
                        returnFocusOnDeactivate: true,
                        document: dom.getDoc(ctx2),
                        fallbackFocus: contentEl,
                        initialFocus: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getInitialFocus"])({
                            root: dom.getContentEl(ctx2),
                            getInitialEl: ctx2.initialFocusEl,
                            enabled: ctx2.autoFocus
                        })
                    });
                    try {
                        trap.activate();
                    } catch  {}
                });
                return ()=>trap?.deactivate();
            }
        },
        actions: {
            reposition (ctx2, evt) {
                const anchorEl = dom.getAnchorEl(ctx2) ?? dom.getTriggerEl(ctx2);
                const getPositionerEl = ()=>dom.getPositionerEl(ctx2);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(anchorEl, getPositionerEl, {
                    ...ctx2.positioning,
                    ...evt.options,
                    defer: true,
                    listeners: false,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            checkRenderedElements (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    Object.assign(ctx2.renderedElements, {
                        title: !!dom.getTitleEl(ctx2),
                        description: !!dom.getDescriptionEl(ctx2)
                    });
                });
            },
            setInitialFocus (ctx2) {
                if (ctx2.modal) return;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getInitialFocus"])({
                        root: dom.getContentEl(ctx2),
                        getInitialEl: ctx2.initialFocusEl,
                        enabled: ctx2.autoFocus
                    });
                    element?.focus({
                        preventScroll: true
                    });
                });
            },
            setFinalFocus (ctx2, evt) {
                const restoreFocus = evt.restoreFocus ?? evt.previousEvent?.restoreFocus;
                if (restoreFocus != null && !restoreFocus) return;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const element = dom.getTriggerEl(ctx2);
                    element?.focus({
                        preventScroll: true
                    });
                });
            },
            invokeOnOpen (ctx2) {
                ctx2.onOpenChange?.({
                    open: true
                });
            },
            invokeOnClose (ctx2) {
                ctx2.onOpenChange?.({
                    open: false
                });
            },
            toggleVisibility (ctx2, evt, { send }) {
                send({
                    type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
                    previousEvent: evt
                });
            }
        }
    });
}
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "autoFocus",
    "closeOnEscape",
    "closeOnInteractOutside",
    "dir",
    "getRootNode",
    "id",
    "ids",
    "initialFocusEl",
    "modal",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "open.controlled",
    "open",
    "persistentElements",
    "portalled",
    "positioning"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
;
}}),
"[project]/node_modules/@zag-js/popover/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as popoverAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "popoverAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popover$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popover$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/popover/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/focus-visible/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getInteractionModality": (()=>getInteractionModality),
    "isFocusVisible": (()=>isFocusVisible),
    "listenerMap": (()=>listenerMap),
    "setInteractionModality": (()=>setInteractionModality),
    "trackFocusVisible": (()=>trackFocusVisible),
    "trackInteractionModality": (()=>trackInteractionModality)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
;
// src/index.ts
function isVirtualClick(event) {
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    return event.detail === 0 && !event.pointerType;
}
function isValidKey(e) {
    return !(e.metaKey || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isMac"])() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function isKeyboardFocusEvent(isTextInput, modality, e) {
    const target = e ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(e) : null;
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(target);
    isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target?.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
    return !(isTextInput && modality === "keyboard" && e instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function triggerChangeHandlers(modality, e) {
    for (let handler of changeHandlers){
        handler(modality, e);
    }
}
function handleKeyboardEvent(e) {
    hasEventBeforeFocus = true;
    if (isValidKey(e)) {
        currentModality = "keyboard";
        triggerChangeHandlers("keyboard", e);
    }
}
function handlePointerEvent(e) {
    currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        hasEventBeforeFocus = true;
        triggerChangeHandlers("pointer", e);
    }
}
function handleClickEvent(e) {
    if (isVirtualClick(e)) {
        hasEventBeforeFocus = true;
        currentModality = "virtual";
    }
}
function handleFocusEvent(e) {
    const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(e);
    if (target === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(target) || target === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocument"])(target)) {
        return;
    }
    if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
        currentModality = "virtual";
        triggerChangeHandlers("virtual", e);
    }
    hasEventBeforeFocus = false;
    hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
    hasEventBeforeFocus = false;
    hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root) {
    if ("undefined" === "undefined" || listenerMap.get((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(root))) {
        return;
    }
    "TURBOPACK unreachable";
    const win = undefined;
    const doc = undefined;
    let focus;
}
var tearDownWindowFocusTracking = (root, loadListener)=>{
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWindow"])(root);
    const doc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDocument"])(root);
    if (!listenerMap.has(win)) {
        return;
    }
    win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
    doc.removeEventListener("keydown", handleKeyboardEvent, true);
    doc.removeEventListener("keyup", handleKeyboardEvent, true);
    doc.removeEventListener("click", handleClickEvent, true);
    win.removeEventListener("focus", handleFocusEvent, true);
    win.removeEventListener("blur", handleWindowBlur, false);
    if (typeof win.PointerEvent !== "undefined") {
        doc.removeEventListener("pointerdown", handlePointerEvent, true);
        doc.removeEventListener("pointermove", handlePointerEvent, true);
        doc.removeEventListener("pointerup", handlePointerEvent, true);
    } else {
        doc.removeEventListener("mousedown", handlePointerEvent, true);
        doc.removeEventListener("mousemove", handlePointerEvent, true);
        doc.removeEventListener("mouseup", handlePointerEvent, true);
    }
    listenerMap.delete(win);
};
function getInteractionModality() {
    return currentModality;
}
function setInteractionModality(modality) {
    currentModality = modality;
    triggerChangeHandlers(modality, null);
}
function trackInteractionModality(props) {
    const { onChange, root } = props;
    setupGlobalFocusEvents(root);
    onChange({
        modality: currentModality
    });
    const handler = ()=>onChange({
            modality: currentModality
        });
    changeHandlers.add(handler);
    return ()=>{
        changeHandlers.delete(handler);
    };
}
function isFocusVisible() {
    return currentModality === "keyboard";
}
function trackFocusVisible(props = {}) {
    const { isTextInput, autoFocus, onChange, root } = props;
    setupGlobalFocusEvents(root);
    onChange?.({
        isFocusVisible: autoFocus || isFocusVisible(),
        modality: currentModality
    });
    const handler = (modality, e)=>{
        if (!isKeyboardFocusEvent(!!isTextInput, modality, e)) return;
        onChange?.({
            isFocusVisible: isFocusVisible(),
            modality
        });
    };
    changeHandlers.add(handler);
    return ()=>{
        changeHandlers.delete(handler);
    };
}
;
}}),
"[project]/node_modules/@zag-js/form-utils/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/input-event.ts
__turbopack_esm__({
    "dispatchInputCheckedEvent": (()=>dispatchInputCheckedEvent),
    "dispatchInputValueEvent": (()=>dispatchInputValueEvent),
    "getClosestForm": (()=>getClosestForm),
    "isNativeDisabled": (()=>isNativeDisabled),
    "setElementChecked": (()=>setElementChecked),
    "setElementValue": (()=>setElementValue),
    "trackFormControl": (()=>trackFormControl)
});
var getWindow = (el)=>el.ownerDocument.defaultView || window;
function getDescriptor(el, options) {
    const { type = "HTMLInputElement", property = "value" } = options;
    const proto = getWindow(el)[type].prototype;
    return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function setElementValue(el, value, option = {}) {
    const descriptor = getDescriptor(el, option);
    descriptor.set?.call(el, value);
    el.setAttribute("value", value);
}
function setElementChecked(el, checked) {
    const descriptor = getDescriptor(el, {
        type: "HTMLInputElement",
        property: "checked"
    });
    descriptor.set?.call(el, checked);
    if (checked) el.setAttribute("checked", "");
    else el.removeAttribute("checked");
}
function dispatchInputValueEvent(el, options) {
    const { value, bubbles = true } = options;
    if (!el) return;
    const win = getWindow(el);
    if (!(el instanceof win.HTMLInputElement)) return;
    setElementValue(el, `${value}`);
    el.dispatchEvent(new win.Event("input", {
        bubbles
    }));
}
function dispatchInputCheckedEvent(el, options) {
    const { checked, bubbles = true } = options;
    if (!el) return;
    const win = getWindow(el);
    if (!(el instanceof win.HTMLInputElement)) return;
    setElementChecked(el, checked);
    el.dispatchEvent(new win.Event("click", {
        bubbles
    }));
}
// src/form.ts
function getClosestForm(el) {
    if (isFormElement(el)) return el.form;
    else return el.closest("form");
}
function isFormElement(el) {
    return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
    if (!el) return;
    const form = getClosestForm(el);
    form?.addEventListener("reset", callback, {
        passive: true
    });
    return ()=>{
        form?.removeEventListener("reset", callback);
    };
}
function trackFieldsetDisabled(el, callback) {
    const fieldset = el?.closest("fieldset");
    if (!fieldset) return;
    callback(fieldset.disabled);
    const win = fieldset.ownerDocument.defaultView || window;
    const obs = new win.MutationObserver(()=>callback(fieldset.disabled));
    obs.observe(fieldset, {
        attributes: true,
        attributeFilter: [
            "disabled"
        ]
    });
    return ()=>obs.disconnect();
}
function isNativeDisabled(el) {
    return el.matches(":disabled");
}
function trackFormControl(el, options) {
    if (!el) return;
    const { onFieldsetDisabledChange, onFormReset } = options;
    const cleanups = [
        trackFormReset(el, onFormReset),
        trackFieldsetDisabled(el, onFieldsetDisabledChange)
    ];
    return ()=>{
        cleanups.forEach((cleanup)=>cleanup?.());
    };
}
;
}}),
"[project]/node_modules/@zag-js/element-rect/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/index.ts
__turbopack_esm__({
    "trackElementRect": (()=>trackElementRect)
});
var rafId;
var observedElements = /* @__PURE__ */ new Map();
var getRectFn = (el)=>el.getBoundingClientRect();
function trackElementRect(el, options) {
    const { scope = "rect", getRect = getRectFn, onChange } = options;
    const loop = getLoopFn({
        scope,
        getRect
    });
    const data = observedElements.get(el);
    if (!data) {
        observedElements.set(el, {
            rect: {},
            callbacks: [
                onChange
            ]
        });
        if (observedElements.size === 1) {
            rafId = requestAnimationFrame(loop);
        }
    } else {
        data.callbacks.push(onChange);
        onChange(getRect(el));
    }
    return function unobserve() {
        const data2 = observedElements.get(el);
        if (!data2) return;
        const index = data2.callbacks.indexOf(onChange);
        if (index > -1) {
            data2.callbacks.splice(index, 1);
        }
        if (data2.callbacks.length === 0) {
            observedElements.delete(el);
            if (observedElements.size === 0) {
                cancelAnimationFrame(rafId);
            }
        }
    };
}
function getLoopFn(options) {
    const { scope, getRect } = options;
    const isEqual = getEqualityFn(scope);
    return function loop() {
        const changedRectsData = [];
        observedElements.forEach((data, element)=>{
            const newRect = getRect(element);
            if (!isEqual(data.rect, newRect)) {
                data.rect = newRect;
                changedRectsData.push(data);
            }
        });
        changedRectsData.forEach((data)=>{
            data.callbacks.forEach((callback)=>callback(data.rect));
        });
        rafId = requestAnimationFrame(loop);
    };
}
var isEqualSize = (a, b)=>a.width === b.width && a.height === b.height;
var isEqualPosition = (a, b)=>a.top === b.top && a.left === b.left;
var isEqualRect = (a, b)=>isEqualSize(a, b) && isEqualPosition(a, b);
function getEqualityFn(scope) {
    if (scope === "size") return isEqualSize;
    if (scope === "position") return isEqualPosition;
    return isEqualRect;
}
;
}}),
"[project]/node_modules/@zag-js/radio-group/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "itemProps": (()=>itemProps),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitItemProps": (()=>splitItemProps),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$visible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/focus-visible/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/form-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$element$2d$rect$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/element-rect/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
// src/radio-group.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("radio-group").parts("root", "label", "item", "itemText", "itemControl", "indicator");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `radio-group:${ctx.id}`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `radio-group:${ctx.id}:label`,
    getItemId: (ctx, value)=>ctx.ids?.item?.(value) ?? `radio-group:${ctx.id}:radio:${value}`,
    getItemHiddenInputId: (ctx, value)=>ctx.ids?.itemHiddenInput?.(value) ?? `radio-group:${ctx.id}:radio:input:${value}`,
    getItemControlId: (ctx, value)=>ctx.ids?.itemControl?.(value) ?? `radio-group:${ctx.id}:radio:control:${value}`,
    getItemLabelId: (ctx, value)=>ctx.ids?.itemLabel?.(value) ?? `radio-group:${ctx.id}:radio:label:${value}`,
    getIndicatorId: (ctx)=>ctx.ids?.indicator ?? `radio-group:${ctx.id}:indicator`,
    getRootEl: (ctx)=>dom.getById(ctx, dom.getRootId(ctx)),
    getItemHiddenInputEl: (ctx, value)=>dom.getById(ctx, dom.getItemHiddenInputId(ctx, value)),
    getIndicatorEl: (ctx)=>dom.getById(ctx, dom.getIndicatorId(ctx)),
    getFirstEnabledInputEl: (ctx)=>dom.getRootEl(ctx)?.querySelector("input:not(:disabled)"),
    getFirstEnabledAndCheckedInputEl: (ctx)=>dom.getRootEl(ctx)?.querySelector("input:not(:disabled):checked"),
    getInputEls: (ctx)=>{
        const ownerId = CSS.escape(dom.getRootId(ctx));
        const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["queryAll"])(dom.getRootEl(ctx), selector);
    },
    getActiveRadioEl: (ctx)=>{
        if (!ctx.value) return;
        return dom.getById(ctx, dom.getItemId(ctx, ctx.value));
    },
    getOffsetRect: (el)=>({
            left: el?.offsetLeft ?? 0,
            top: el?.offsetTop ?? 0,
            width: el?.offsetWidth ?? 0,
            height: el?.offsetHeight ?? 0
        }),
    getRectById: (ctx, id)=>{
        const radioEl = dom.getById(ctx, dom.getItemId(ctx, id));
        if (!radioEl) return;
        return dom.resolveRect(dom.getOffsetRect(radioEl));
    },
    resolveRect: (rect)=>({
            width: `${rect.width}px`,
            height: `${rect.height}px`,
            left: `${rect.left}px`,
            top: `${rect.top}px`
        })
});
// src/radio-group.connect.ts
function connect(state, send, normalize) {
    const groupDisabled = state.context.isDisabled;
    const readOnly = state.context.readOnly;
    function getItemState(props2) {
        return {
            invalid: !!props2.invalid,
            disabled: !!props2.disabled || groupDisabled,
            checked: state.context.value === props2.value,
            focused: state.context.focusedValue === props2.value,
            hovered: state.context.hoveredValue === props2.value,
            active: state.context.activeValue === props2.value
        };
    }
    function getItemDataAttrs(props2) {
        const radioState = getItemState(props2);
        return {
            "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(radioState.focused),
            "data-focus-visible": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(radioState.focused && state.context.focusVisible),
            "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(radioState.disabled),
            "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(readOnly),
            "data-state": radioState.checked ? "checked" : "unchecked",
            "data-hover": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(radioState.hovered),
            "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(radioState.invalid),
            "data-orientation": state.context.orientation,
            "data-ssr": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.ssr)
        };
    }
    const focus = ()=>{
        const firstEnabledAndCheckedInput = dom.getFirstEnabledAndCheckedInputEl(state.context);
        if (firstEnabledAndCheckedInput) {
            firstEnabledAndCheckedInput.focus();
            return;
        }
        const firstEnabledInput = dom.getFirstEnabledInputEl(state.context);
        firstEnabledInput?.focus();
    };
    return {
        focus,
        value: state.context.value,
        setValue (value) {
            send({
                type: "SET_VALUE",
                value,
                isTrusted: false
            });
        },
        clearValue () {
            send({
                type: "SET_VALUE",
                value: null,
                isTrusted: false
            });
        },
        getRootProps () {
            return normalize.element({
                ...parts.root.attrs,
                role: "radiogroup",
                id: dom.getRootId(state.context),
                "aria-labelledby": dom.getLabelId(state.context),
                "data-orientation": state.context.orientation,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(groupDisabled),
                "aria-orientation": state.context.orientation,
                dir: state.context.dir,
                style: {
                    position: "relative"
                }
            });
        },
        getLabelProps () {
            return normalize.element({
                ...parts.label.attrs,
                dir: state.context.dir,
                "data-orientation": state.context.orientation,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(groupDisabled),
                id: dom.getLabelId(state.context),
                onClick: focus
            });
        },
        getItemState,
        getItemProps (props2) {
            const itemState = getItemState(props2);
            return normalize.label({
                ...parts.item.attrs,
                dir: state.context.dir,
                id: dom.getItemId(state.context, props2.value),
                htmlFor: dom.getItemHiddenInputId(state.context, props2.value),
                ...getItemDataAttrs(props2),
                onPointerMove () {
                    if (itemState.disabled) return;
                    if (itemState.hovered) return;
                    send({
                        type: "SET_HOVERED",
                        value: props2.value,
                        hovered: true
                    });
                },
                onPointerLeave () {
                    if (itemState.disabled) return;
                    send({
                        type: "SET_HOVERED",
                        value: null
                    });
                },
                onPointerDown (event) {
                    if (itemState.disabled) return;
                    if (itemState.focused && event.pointerType === "mouse") {
                        event.preventDefault();
                    }
                    send({
                        type: "SET_ACTIVE",
                        value: props2.value,
                        active: true
                    });
                },
                onPointerUp () {
                    if (itemState.disabled) return;
                    send({
                        type: "SET_ACTIVE",
                        value: null
                    });
                }
            });
        },
        getItemTextProps (props2) {
            return normalize.element({
                ...parts.itemText.attrs,
                dir: state.context.dir,
                id: dom.getItemLabelId(state.context, props2.value),
                ...getItemDataAttrs(props2)
            });
        },
        getItemControlProps (props2) {
            const controlState = getItemState(props2);
            return normalize.element({
                ...parts.itemControl.attrs,
                dir: state.context.dir,
                id: dom.getItemControlId(state.context, props2.value),
                "data-active": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(controlState.active),
                "aria-hidden": true,
                ...getItemDataAttrs(props2)
            });
        },
        getItemHiddenInputProps (props2) {
            const inputState = getItemState(props2);
            return normalize.input({
                "data-ownedby": dom.getRootId(state.context),
                id: dom.getItemHiddenInputId(state.context, props2.value),
                type: "radio",
                name: state.context.name || state.context.id,
                form: state.context.form,
                value: props2.value,
                onClick (event) {
                    if (readOnly) {
                        event.preventDefault();
                        return;
                    }
                    if (event.currentTarget.checked) {
                        send({
                            type: "SET_VALUE",
                            value: props2.value,
                            isTrusted: true
                        });
                    }
                },
                onBlur () {
                    send({
                        type: "SET_FOCUSED",
                        value: null,
                        focused: false,
                        focusVisible: false
                    });
                },
                onFocus () {
                    const focusVisible = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$visible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFocusVisible"])();
                    send({
                        type: "SET_FOCUSED",
                        value: props2.value,
                        focused: true,
                        focusVisible
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (event.key === " ") {
                        send({
                            type: "SET_ACTIVE",
                            value: props2.value,
                            active: true
                        });
                    }
                },
                onKeyUp (event) {
                    if (event.defaultPrevented) return;
                    if (event.key === " ") {
                        send({
                            type: "SET_ACTIVE",
                            value: null
                        });
                    }
                },
                disabled: inputState.disabled,
                defaultChecked: inputState.checked,
                style: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["visuallyHiddenStyle"]
            });
        },
        getIndicatorProps () {
            return normalize.element({
                id: dom.getIndicatorId(state.context),
                ...parts.indicator.attrs,
                dir: state.context.dir,
                hidden: state.context.value == null,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(groupDisabled),
                "data-orientation": state.context.orientation,
                style: {
                    "--transition-property": "left, top, width, height",
                    "--left": state.context.indicatorRect?.left,
                    "--top": state.context.indicatorRect?.top,
                    "--width": state.context.indicatorRect?.width,
                    "--height": state.context.indicatorRect?.height,
                    position: "absolute",
                    willChange: "var(--transition-property)",
                    transitionProperty: "var(--transition-property)",
                    transitionDuration: state.context.canIndicatorTransition ? "var(--transition-duration, 150ms)" : "0ms",
                    transitionTimingFunction: "var(--transition-timing-function)",
                    [state.context.orientation === "horizontal" ? "left" : "top"]: state.context.orientation === "horizontal" ? "var(--left)" : "var(--top)"
                }
            });
        }
    };
}
var { not } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guards"];
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "radio",
        initial: "idle",
        context: {
            value: null,
            activeValue: null,
            focusedValue: null,
            hoveredValue: null,
            disabled: false,
            orientation: "vertical",
            ...ctx,
            indicatorRect: {},
            canIndicatorTransition: false,
            fieldsetDisabled: false,
            focusVisible: false,
            ssr: true
        },
        computed: {
            isDisabled: (ctx2)=>!!ctx2.disabled || ctx2.fieldsetDisabled
        },
        entry: [
            "syncIndicatorRect",
            "syncSsr"
        ],
        exit: [
            "cleanupObserver"
        ],
        activities: [
            "trackFormControlState",
            "trackFocusVisible"
        ],
        watch: {
            value: [
                "setIndicatorTransition",
                "syncIndicatorRect",
                "syncInputElements"
            ]
        },
        on: {
            SET_VALUE: [
                {
                    guard: not("isTrusted"),
                    actions: [
                        "setValue",
                        "dispatchChangeEvent"
                    ]
                },
                {
                    actions: [
                        "setValue"
                    ]
                }
            ],
            SET_HOVERED: {
                actions: "setHovered"
            },
            SET_ACTIVE: {
                actions: "setActive"
            },
            SET_FOCUSED: {
                actions: "setFocused"
            }
        },
        states: {
            idle: {}
        }
    }, {
        guards: {
            isTrusted: (_ctx, evt)=>!!evt.isTrusted
        },
        activities: {
            trackFormControlState (ctx2, _evt, { send, initialContext }) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackFormControl"])(dom.getRootEl(ctx2), {
                    onFieldsetDisabledChange (disabled) {
                        ctx2.fieldsetDisabled = disabled;
                    },
                    onFormReset () {
                        send({
                            type: "SET_VALUE",
                            value: initialContext.value
                        });
                    }
                });
            },
            trackFocusVisible (ctx2) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$visible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackFocusVisible"])({
                    root: dom.getRootNode(ctx2)
                });
            }
        },
        actions: {
            setValue (ctx2, evt) {
                set.value(ctx2, evt.value);
            },
            setHovered (ctx2, evt) {
                ctx2.hoveredValue = evt.value;
            },
            setActive (ctx2, evt) {
                ctx2.activeValue = evt.value;
            },
            setFocused (ctx2, evt) {
                ctx2.focusedValue = evt.value;
                ctx2.focusVisible = evt.focusVisible;
            },
            syncInputElements (ctx2) {
                const inputs = dom.getInputEls(ctx2);
                inputs.forEach((input)=>{
                    input.checked = input.value === ctx2.value;
                });
            },
            setIndicatorTransition (ctx2) {
                ctx2.canIndicatorTransition = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isString"])(ctx2.value);
            },
            cleanupObserver (ctx2) {
                ctx2.indicatorCleanup?.();
            },
            syncSsr (ctx2) {
                ctx2.ssr = false;
            },
            syncIndicatorRect (ctx2) {
                ctx2.indicatorCleanup?.();
                if (!dom.getIndicatorEl(ctx2)) return;
                const value = ctx2.value;
                const radioEl = dom.getActiveRadioEl(ctx2);
                if (value == null || !radioEl) {
                    ctx2.indicatorRect = {};
                    return;
                }
                ctx2.indicatorCleanup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$element$2d$rect$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackElementRect"])(radioEl, {
                    getRect (el) {
                        return dom.getOffsetRect(el);
                    },
                    onChange (rect) {
                        ctx2.indicatorRect = dom.resolveRect(rect);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["nextTick"])(()=>{
                            ctx2.canIndicatorTransition = false;
                        });
                    }
                });
            },
            dispatchChangeEvent (ctx2) {
                const inputEls = dom.getInputEls(ctx2);
                inputEls.forEach((inputEl)=>{
                    const checked = inputEl.value === ctx2.value;
                    if (checked === inputEl.checked) return;
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dispatchInputCheckedEvent"])(inputEl, {
                        checked
                    });
                });
            }
        }
    });
}
var invoke = {
    change: (ctx)=>{
        if (ctx.value == null) return;
        ctx.onValueChange?.({
            value: ctx.value
        });
    }
};
var set = {
    value: (ctx, value)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value, value)) return;
        ctx.value = value;
        invoke.change(ctx);
    }
};
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "dir",
    "disabled",
    "form",
    "getRootNode",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
var itemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "value",
    "disabled",
    "invalid"
]);
var splitItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(itemProps);
;
}}),
"[project]/node_modules/@zag-js/radio-group/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as radioGroupAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "radioGroupAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$radio$2d$group$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$radio$2d$group$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/radio-group/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/rating-group/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "itemProps": (()=>itemProps),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitItemProps": (()=>splitItemProps),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/form-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
;
;
;
;
;
;
;
// src/rating-group.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("rating-group").parts("root", "label", "item", "control");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `rating:${ctx.id}`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `rating:${ctx.id}:label`,
    getHiddenInputId: (ctx)=>ctx.ids?.hiddenInput ?? `rating:${ctx.id}:input`,
    getControlId: (ctx)=>ctx.ids?.control ?? `rating:${ctx.id}:control`,
    getItemId: (ctx, id)=>ctx.ids?.item?.(id) ?? `rating:${ctx.id}:item:${id}`,
    getRootEl: (ctx)=>dom.getById(ctx, dom.getRootId(ctx)),
    getControlEl: (ctx)=>dom.getById(ctx, dom.getControlId(ctx)),
    getRadioEl: (ctx, value = ctx.value)=>{
        const selector = `[role=radio][aria-posinset='${Math.ceil(value)}']`;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["query"])(dom.getControlEl(ctx), selector);
    },
    getHiddenInputEl: (ctx)=>dom.getById(ctx, dom.getHiddenInputId(ctx)),
    dispatchChangeEvent: (ctx)=>{
        const inputEl = dom.getHiddenInputEl(ctx);
        if (!inputEl) return;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dispatchInputValueEvent"])(inputEl, {
            value: ctx.value
        });
    }
});
// src/rating-group.connect.ts
function connect(state, send, normalize) {
    const interactive = state.context.isInteractive;
    const disabled = state.context.isDisabled;
    const readOnly = state.context.readOnly;
    const value = state.context.value;
    const hoveredValue = state.context.hoveredValue;
    const translations = state.context.translations;
    function getItemState(props2) {
        const value2 = state.context.isHovering ? state.context.hoveredValue : state.context.value;
        const equal = Math.ceil(value2) === props2.index;
        const highlighted = props2.index <= value2 || equal;
        const half = equal && Math.abs(value2 - props2.index) === 0.5;
        return {
            highlighted,
            half,
            checked: equal || state.context.value === -1 && props2.index === 1
        };
    }
    return {
        hovering: state.context.isHovering,
        value,
        hoveredValue,
        count: state.context.count,
        items: Array.from({
            length: state.context.count
        }).map((_, index)=>index + 1),
        setValue (value2) {
            send({
                type: "SET_VALUE",
                value: value2
            });
        },
        clearValue () {
            send("CLEAR_VALUE");
        },
        getRootProps () {
            return normalize.element({
                ...parts.root.attrs,
                dir: state.context.dir,
                id: dom.getRootId(state.context)
            });
        },
        getHiddenInputProps () {
            return normalize.input({
                name: state.context.name,
                form: state.context.form,
                type: "text",
                hidden: true,
                disabled,
                readOnly,
                required: state.context.required,
                id: dom.getHiddenInputId(state.context),
                defaultValue: state.context.value
            });
        },
        getLabelProps () {
            return normalize.label({
                ...parts.label.attrs,
                dir: state.context.dir,
                id: dom.getLabelId(state.context),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                htmlFor: dom.getHiddenInputId(state.context),
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    event.preventDefault();
                    const radioEl = dom.getRadioEl(state.context, 1);
                    radioEl?.focus({
                        preventScroll: true
                    });
                }
            });
        },
        getControlProps () {
            return normalize.element({
                id: dom.getControlId(state.context),
                ...parts.control.attrs,
                dir: state.context.dir,
                role: "radiogroup",
                "aria-orientation": "horizontal",
                "aria-labelledby": dom.getLabelId(state.context),
                "aria-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaAttr"])(readOnly),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(readOnly),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                onPointerMove (event) {
                    if (!interactive) return;
                    if (event.pointerType === "touch") return;
                    send("GROUP_POINTER_OVER");
                },
                onPointerLeave (event) {
                    if (!interactive) return;
                    if (event.pointerType === "touch") return;
                    send("GROUP_POINTER_LEAVE");
                }
            });
        },
        getItemState,
        getItemProps (props2) {
            const { index } = props2;
            const itemState = getItemState(props2);
            const valueText = translations.ratingValueText(index);
            return normalize.element({
                ...parts.item.attrs,
                dir: state.context.dir,
                id: dom.getItemId(state.context, index.toString()),
                role: "radio",
                tabIndex: (()=>{
                    if (readOnly) return itemState.checked ? 0 : void 0;
                    if (disabled) return void 0;
                    return itemState.checked ? 0 : -1;
                })(),
                "aria-roledescription": "rating",
                "aria-label": valueText,
                "aria-disabled": disabled,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(readOnly),
                "aria-setsize": state.context.count,
                "aria-checked": itemState.checked,
                "data-checked": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.checked),
                "aria-posinset": index,
                "data-highlighted": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.highlighted),
                "data-half": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.half),
                onPointerDown (event) {
                    if (!interactive) return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLeftClick"])(event)) return;
                    event.preventDefault();
                },
                onPointerMove (event) {
                    if (!interactive) return;
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    const relativePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRelativePoint"])(point, event.currentTarget);
                    const percentX = relativePoint.getPercentValue({
                        orientation: "horizontal",
                        dir: state.context.dir
                    });
                    const isMidway = percentX < 0.5;
                    send({
                        type: "POINTER_OVER",
                        index,
                        isMidway
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    const keyMap = {
                        ArrowLeft () {
                            send("ARROW_LEFT");
                        },
                        ArrowRight () {
                            send("ARROW_RIGHT");
                        },
                        ArrowUp () {
                            send("ARROW_LEFT");
                        },
                        ArrowDown () {
                            send("ARROW_RIGHT");
                        },
                        Space () {
                            send({
                                type: "SPACE",
                                value: index
                            });
                        },
                        Home () {
                            send("HOME");
                        },
                        End () {
                            send("END");
                        }
                    };
                    const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventKey"])(event, state.context);
                    const exec = keyMap[key];
                    if (exec) {
                        event.preventDefault();
                        exec(event);
                    }
                },
                onClick () {
                    if (!interactive) return;
                    send({
                        type: "CLICK",
                        value: index
                    });
                },
                onFocus () {
                    if (!interactive) return;
                    send("FOCUS");
                },
                onBlur () {
                    if (!interactive) return;
                    send("BLUR");
                }
            });
        }
    };
}
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "rating",
        initial: "idle",
        context: {
            name: "rating",
            count: 5,
            dir: "ltr",
            value: -1,
            readOnly: false,
            disabled: false,
            ...ctx,
            hoveredValue: -1,
            fieldsetDisabled: false,
            translations: {
                ratingValueText: (index)=>`${index} stars`,
                ...ctx.translations
            }
        },
        created: [
            "roundValueIfNeeded"
        ],
        watch: {
            allowHalf: [
                "roundValueIfNeeded"
            ]
        },
        computed: {
            isDisabled: (ctx2)=>!!ctx2.disabled || ctx2.fieldsetDisabled,
            isInteractive: (ctx2)=>!(ctx2.isDisabled || ctx2.readOnly),
            isHovering: (ctx2)=>ctx2.hoveredValue > -1
        },
        activities: [
            "trackFormControlState"
        ],
        on: {
            SET_VALUE: {
                actions: [
                    "setValue"
                ]
            },
            CLEAR_VALUE: {
                actions: [
                    "clearValue"
                ]
            }
        },
        states: {
            idle: {
                entry: "clearHoveredValue",
                on: {
                    GROUP_POINTER_OVER: "hover",
                    FOCUS: "focus",
                    CLICK: {
                        actions: [
                            "setValue",
                            "focusActiveRadio"
                        ]
                    }
                }
            },
            focus: {
                on: {
                    POINTER_OVER: {
                        actions: "setHoveredValue"
                    },
                    GROUP_POINTER_LEAVE: {
                        actions: "clearHoveredValue"
                    },
                    BLUR: "idle",
                    SPACE: {
                        guard: "isValueEmpty",
                        actions: [
                            "setValue"
                        ]
                    },
                    CLICK: {
                        actions: [
                            "setValue",
                            "focusActiveRadio"
                        ]
                    },
                    ARROW_LEFT: {
                        actions: [
                            "setPrevValue",
                            "focusActiveRadio"
                        ]
                    },
                    ARROW_RIGHT: {
                        actions: [
                            "setNextValue",
                            "focusActiveRadio"
                        ]
                    },
                    HOME: {
                        actions: [
                            "setValueToMin",
                            "focusActiveRadio"
                        ]
                    },
                    END: {
                        actions: [
                            "setValueToMax",
                            "focusActiveRadio"
                        ]
                    }
                }
            },
            hover: {
                on: {
                    POINTER_OVER: {
                        actions: "setHoveredValue"
                    },
                    GROUP_POINTER_LEAVE: [
                        {
                            guard: "isRadioFocused",
                            target: "focus",
                            actions: "clearHoveredValue"
                        },
                        {
                            target: "idle",
                            actions: "clearHoveredValue"
                        }
                    ],
                    CLICK: {
                        actions: [
                            "setValue",
                            "focusActiveRadio"
                        ]
                    }
                }
            }
        }
    }, {
        guards: {
            isInteractive: (ctx2)=>!(ctx2.disabled || ctx2.readOnly),
            isHoveredValueEmpty: (ctx2)=>ctx2.hoveredValue === -1,
            isValueEmpty: (ctx2)=>ctx2.value <= 0,
            isRadioFocused: (ctx2)=>!!dom.getControlEl(ctx2)?.contains(dom.getActiveElement(ctx2))
        },
        activities: {
            trackFormControlState (ctx2, _evt, { initialContext }) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackFormControl"])(dom.getHiddenInputEl(ctx2), {
                    onFieldsetDisabledChange (disabled) {
                        ctx2.fieldsetDisabled = disabled;
                    },
                    onFormReset () {
                        set.value(ctx2, initialContext.value);
                    }
                });
            }
        },
        actions: {
            clearHoveredValue (ctx2) {
                set.hoveredValue(ctx2, -1);
            },
            focusActiveRadio (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>dom.getRadioEl(ctx2)?.focus());
            },
            setPrevValue (ctx2) {
                const factor = ctx2.allowHalf ? 0.5 : 1;
                set.value(ctx2, Math.max(0, ctx2.value - factor));
            },
            setNextValue (ctx2) {
                const factor = ctx2.allowHalf ? 0.5 : 1;
                const value = ctx2.value === -1 ? 0 : ctx2.value;
                set.value(ctx2, Math.min(ctx2.count, value + factor));
            },
            setValueToMin (ctx2) {
                set.value(ctx2, 1);
            },
            setValueToMax (ctx2) {
                set.value(ctx2, ctx2.count);
            },
            setValue (ctx2, evt) {
                const value = ctx2.hoveredValue === -1 ? evt.value : ctx2.hoveredValue;
                set.value(ctx2, value);
            },
            clearValue (ctx2) {
                set.value(ctx2, -1);
            },
            setHoveredValue (ctx2, evt) {
                const half = ctx2.allowHalf && evt.isMidway;
                const factor = half ? 0.5 : 0;
                set.hoveredValue(ctx2, evt.index - factor);
            },
            roundValueIfNeeded (ctx2) {
                if (ctx2.allowHalf) return;
                ctx2.value = Math.round(ctx2.value);
            }
        }
    });
}
var invoke = {
    change: (ctx)=>{
        ctx.onValueChange?.({
            value: ctx.value
        });
        dom.dispatchChangeEvent(ctx);
    },
    hoverChange: (ctx)=>{
        ctx.onHoverChange?.({
            hoveredValue: ctx.hoveredValue
        });
    }
};
var set = {
    value: (ctx, value)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value, value)) return;
        ctx.value = value;
        invoke.change(ctx);
    },
    hoveredValue: (ctx, value)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.hoveredValue, value)) return;
        ctx.hoveredValue = value;
        invoke.hoverChange(ctx);
    }
};
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "allowHalf",
    "autoFocus",
    "count",
    "dir",
    "disabled",
    "form",
    "getRootNode",
    "id",
    "ids",
    "name",
    "onHoverChange",
    "onValueChange",
    "required",
    "readOnly",
    "translations",
    "value"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
var itemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "index"
]);
var splitItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(itemProps);
;
}}),
"[project]/node_modules/@zag-js/rating-group/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as ratingGroupAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ratingGroupAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$rating$2d$group$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$rating$2d$group$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/rating-group/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/select/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "collection": (()=>collection),
    "connect": (()=>connect),
    "itemGroupLabelProps": (()=>itemGroupLabelProps),
    "itemGroupProps": (()=>itemGroupProps),
    "itemProps": (()=>itemProps),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitItemGroupLabelProps": (()=>splitItemGroupLabelProps),
    "splitItemGroupProps": (()=>splitItemGroupProps),
    "splitItemProps": (()=>splitItemProps),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/store/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$collection$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/collection/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/popper/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/form-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dismissable/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
// src/select.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("select").parts("label", "positioner", "trigger", "indicator", "clearTrigger", "item", "itemText", "itemIndicator", "itemGroup", "itemGroupLabel", "list", "content", "root", "control", "valueText");
var parts = anatomy.build();
var collection = (options)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$collection$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ListCollection"](options));
};
collection.empty = ()=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$collection$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ListCollection"]({
        items: []
    }));
};
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `select:${ctx.id}`,
    getContentId: (ctx)=>ctx.ids?.content ?? `select:${ctx.id}:content`,
    getTriggerId: (ctx)=>ctx.ids?.trigger ?? `select:${ctx.id}:trigger`,
    getClearTriggerId: (ctx)=>ctx.ids?.clearTrigger ?? `select:${ctx.id}:clear-trigger`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `select:${ctx.id}:label`,
    getControlId: (ctx)=>ctx.ids?.control ?? `select:${ctx.id}:control`,
    getItemId: (ctx, id)=>ctx.ids?.item?.(id) ?? `select:${ctx.id}:option:${id}`,
    getHiddenSelectId: (ctx)=>ctx.ids?.hiddenSelect ?? `select:${ctx.id}:select`,
    getPositionerId: (ctx)=>ctx.ids?.positioner ?? `select:${ctx.id}:positioner`,
    getItemGroupId: (ctx, id)=>ctx.ids?.itemGroup?.(id) ?? `select:${ctx.id}:optgroup:${id}`,
    getItemGroupLabelId: (ctx, id)=>ctx.ids?.itemGroupLabel?.(id) ?? `select:${ctx.id}:optgroup-label:${id}`,
    getHiddenSelectEl: (ctx)=>dom.getById(ctx, dom.getHiddenSelectId(ctx)),
    getContentEl: (ctx)=>dom.getById(ctx, dom.getContentId(ctx)),
    getControlEl: (ctx)=>dom.getById(ctx, dom.getControlId(ctx)),
    getTriggerEl: (ctx)=>dom.getById(ctx, dom.getTriggerId(ctx)),
    getClearTriggerEl: (ctx)=>dom.getById(ctx, dom.getClearTriggerId(ctx)),
    getPositionerEl: (ctx)=>dom.getById(ctx, dom.getPositionerId(ctx)),
    getHighlightedOptionEl (ctx) {
        if (!ctx.highlightedValue) return null;
        return dom.getById(ctx, dom.getItemId(ctx, ctx.highlightedValue));
    }
});
// src/select.connect.ts
function connect(state, send, normalize) {
    const disabled = state.context.isDisabled;
    const invalid = state.context.invalid;
    const readOnly = state.context.readOnly;
    const interactive = state.context.isInteractive;
    const composite = state.context.composite;
    const open = state.hasTag("open");
    const focused = state.matches("focused");
    const highlightedValue = state.context.highlightedValue;
    const highlightedItem = state.context.highlightedItem;
    const selectedItems = state.context.selectedItems;
    const isTypingAhead = state.context.isTypingAhead;
    const collection2 = state.context.collection;
    const ariaActiveDescendant = highlightedValue ? dom.getItemId(state.context, highlightedValue) : void 0;
    function getItemState(props2) {
        const _disabled = collection2.getItemDisabled(props2.item);
        const value = collection2.getItemValue(props2.item);
        return {
            value,
            disabled: Boolean(disabled || _disabled),
            highlighted: highlightedValue === value,
            selected: state.context.value.includes(value)
        };
    }
    const popperStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacementStyles"])({
        ...state.context.positioning,
        placement: state.context.currentPlacement
    });
    return {
        open,
        focused,
        empty: state.context.value.length === 0,
        highlightedItem,
        highlightedValue,
        selectedItems,
        hasSelectedItems: state.context.hasSelectedItems,
        value: state.context.value,
        valueAsString: state.context.valueAsString,
        collection: collection2,
        multiple: !!state.context.multiple,
        disabled: !!disabled,
        setCollection (collection3) {
            send({
                type: "COLLECTION.SET",
                value: collection3
            });
        },
        reposition (options = {}) {
            send({
                type: "POSITIONING.SET",
                options
            });
        },
        focus () {
            dom.getTriggerEl(state.context)?.focus({
                preventScroll: true
            });
        },
        setOpen (nextOpen) {
            if (nextOpen === open) return;
            send(nextOpen ? "OPEN" : "CLOSE");
        },
        selectValue (value) {
            send({
                type: "ITEM.SELECT",
                value
            });
        },
        setValue (value) {
            send({
                type: "VALUE.SET",
                value
            });
        },
        selectAll () {
            send({
                type: "VALUE.SET",
                value: collection2.getValues()
            });
        },
        highlightValue (value) {
            send({
                type: "HIGHLIGHTED_VALUE.SET",
                value
            });
        },
        clearValue (value) {
            if (value) {
                send({
                    type: "ITEM.CLEAR",
                    value
                });
            } else {
                send({
                    type: "VALUE.CLEAR"
                });
            }
        },
        getItemState,
        getRootProps () {
            return normalize.element({
                ...parts.root.attrs,
                dir: state.context.dir,
                id: dom.getRootId(state.context),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(readOnly)
            });
        },
        getLabelProps () {
            return normalize.label({
                dir: state.context.dir,
                id: dom.getLabelId(state.context),
                ...parts.label.attrs,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(readOnly),
                htmlFor: dom.getHiddenSelectId(state.context),
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (disabled) return;
                    dom.getTriggerEl(state.context)?.focus({
                        preventScroll: true
                    });
                }
            });
        },
        getControlProps () {
            return normalize.element({
                ...parts.control.attrs,
                dir: state.context.dir,
                id: dom.getControlId(state.context),
                "data-state": open ? "open" : "closed",
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid)
            });
        },
        getValueTextProps () {
            return normalize.element({
                ...parts.valueText.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused)
            });
        },
        getTriggerProps () {
            return normalize.button({
                id: dom.getTriggerId(state.context),
                disabled,
                dir: state.context.dir,
                type: "button",
                role: "combobox",
                "aria-controls": dom.getContentId(state.context),
                "aria-expanded": open,
                "aria-haspopup": "listbox",
                "data-state": open ? "open" : "closed",
                "aria-invalid": invalid,
                "aria-labelledby": dom.getLabelId(state.context),
                ...parts.trigger.attrs,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(readOnly),
                "data-placement": state.context.currentPlacement,
                "data-placeholder-shown": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(!state.context.hasSelectedItems),
                onClick (event) {
                    if (!interactive) return;
                    if (event.defaultPrevented) return;
                    send({
                        type: "TRIGGER.CLICK"
                    });
                },
                onFocus () {
                    send("TRIGGER.FOCUS");
                },
                onBlur () {
                    send("TRIGGER.BLUR");
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    const keyMap = {
                        ArrowUp () {
                            send({
                                type: "TRIGGER.ARROW_UP"
                            });
                        },
                        ArrowDown (event2) {
                            send({
                                type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN"
                            });
                        },
                        ArrowLeft () {
                            send({
                                type: "TRIGGER.ARROW_LEFT"
                            });
                        },
                        ArrowRight () {
                            send({
                                type: "TRIGGER.ARROW_RIGHT"
                            });
                        },
                        Home () {
                            send({
                                type: "TRIGGER.HOME"
                            });
                        },
                        End () {
                            send({
                                type: "TRIGGER.END"
                            });
                        },
                        Enter () {
                            send({
                                type: "TRIGGER.ENTER"
                            });
                        },
                        Space (event2) {
                            if (isTypingAhead) {
                                send({
                                    type: "TRIGGER.TYPEAHEAD",
                                    key: event2.key
                                });
                            } else {
                                send({
                                    type: "TRIGGER.ENTER"
                                });
                            }
                        }
                    };
                    const exec = keyMap[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventKey"])(event, state.context)];
                    if (exec) {
                        exec(event);
                        event.preventDefault();
                        return;
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getByTypeahead"].isValidEvent(event)) {
                        send({
                            type: "TRIGGER.TYPEAHEAD",
                            key: event.key
                        });
                        event.preventDefault();
                    }
                }
            });
        },
        getIndicatorProps () {
            return normalize.element({
                ...parts.indicator.attrs,
                dir: state.context.dir,
                "aria-hidden": true,
                "data-state": open ? "open" : "closed",
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(readOnly)
            });
        },
        getItemProps (props2) {
            const itemState = getItemState(props2);
            return normalize.element({
                id: dom.getItemId(state.context, itemState.value),
                role: "option",
                ...parts.item.attrs,
                dir: state.context.dir,
                "data-value": itemState.value,
                "aria-selected": itemState.selected,
                "data-state": itemState.selected ? "checked" : "unchecked",
                "data-highlighted": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.highlighted),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
                "aria-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaAttr"])(itemState.disabled),
                onPointerMove (event) {
                    if (itemState.disabled || event.pointerType !== "mouse") return;
                    if (itemState.value === state.context.highlightedValue) return;
                    send({
                        type: "ITEM.POINTER_MOVE",
                        value: itemState.value
                    });
                },
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (itemState.disabled) return;
                    send({
                        type: "ITEM.CLICK",
                        src: "pointerup",
                        value: itemState.value
                    });
                },
                onPointerLeave (event) {
                    if (itemState.disabled) return;
                    if (props2.persistFocus) return;
                    if (event.pointerType !== "mouse") return;
                    const pointerMoved = state.previousEvent.type.includes("POINTER");
                    if (!pointerMoved) return;
                    send({
                        type: "ITEM.POINTER_LEAVE"
                    });
                }
            });
        },
        getItemTextProps (props2) {
            const itemState = getItemState(props2);
            return normalize.element({
                ...parts.itemText.attrs,
                "data-state": itemState.selected ? "checked" : "unchecked",
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
                "data-highlighted": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.highlighted)
            });
        },
        getItemIndicatorProps (props2) {
            const itemState = getItemState(props2);
            return normalize.element({
                "aria-hidden": true,
                ...parts.itemIndicator.attrs,
                "data-state": itemState.selected ? "checked" : "unchecked",
                hidden: !itemState.selected
            });
        },
        getItemGroupLabelProps (props2) {
            const { htmlFor } = props2;
            return normalize.element({
                ...parts.itemGroupLabel.attrs,
                id: dom.getItemGroupLabelId(state.context, htmlFor),
                role: "group",
                dir: state.context.dir
            });
        },
        getItemGroupProps (props2) {
            const { id } = props2;
            return normalize.element({
                ...parts.itemGroup.attrs,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                id: dom.getItemGroupId(state.context, id),
                "aria-labelledby": dom.getItemGroupLabelId(state.context, id),
                dir: state.context.dir
            });
        },
        getClearTriggerProps () {
            return normalize.button({
                ...parts.clearTrigger.attrs,
                id: dom.getClearTriggerId(state.context),
                type: "button",
                "aria-label": "Clear value",
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                disabled,
                hidden: !state.context.hasSelectedItems,
                dir: state.context.dir,
                onClick (event) {
                    if (event.defaultPrevented) return;
                    send("CLEAR.CLICK");
                }
            });
        },
        getHiddenSelectProps () {
            return normalize.select({
                name: state.context.name,
                form: state.context.form,
                disabled,
                multiple: state.context.multiple,
                required: state.context.required,
                "aria-hidden": true,
                id: dom.getHiddenSelectId(state.context),
                defaultValue: state.context.multiple ? state.context.value : state.context.value[0],
                style: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["visuallyHiddenStyle"],
                tabIndex: -1,
                // Some browser extensions will focus the hidden select.
                // Let's forward the focus to the trigger.
                onFocus () {
                    dom.getTriggerEl(state.context)?.focus({
                        preventScroll: true
                    });
                },
                "aria-labelledby": dom.getLabelId(state.context)
            });
        },
        getPositionerProps () {
            return normalize.element({
                ...parts.positioner.attrs,
                dir: state.context.dir,
                id: dom.getPositionerId(state.context),
                style: popperStyles.floating
            });
        },
        getContentProps () {
            return normalize.element({
                hidden: !open,
                dir: state.context.dir,
                id: dom.getContentId(state.context),
                role: composite ? "listbox" : "dialog",
                ...parts.content.attrs,
                "data-state": open ? "open" : "closed",
                "data-placement": state.context.currentPlacement,
                "data-activedescendant": ariaActiveDescendant,
                "aria-activedescendant": composite ? ariaActiveDescendant : void 0,
                "aria-multiselectable": state.context.multiple && composite ? true : void 0,
                "aria-labelledby": dom.getLabelId(state.context),
                tabIndex: 0,
                onKeyDown (event) {
                    if (!interactive) return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isSelfTarget"])(event)) return;
                    if (event.key === "Tab") {
                        const valid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isValidTabEvent"])(event);
                        if (!valid) {
                            event.preventDefault();
                            return;
                        }
                    }
                    const keyMap = {
                        ArrowUp () {
                            send({
                                type: "CONTENT.ARROW_UP"
                            });
                        },
                        ArrowDown () {
                            send({
                                type: "CONTENT.ARROW_DOWN"
                            });
                        },
                        Home () {
                            send({
                                type: "CONTENT.HOME"
                            });
                        },
                        End () {
                            send({
                                type: "CONTENT.END"
                            });
                        },
                        Enter () {
                            send({
                                type: "ITEM.CLICK",
                                src: "keydown.enter"
                            });
                        },
                        Space (event2) {
                            if (isTypingAhead) {
                                send({
                                    type: "CONTENT.TYPEAHEAD",
                                    key: event2.key
                                });
                            } else {
                                keyMap.Enter?.(event2);
                            }
                        }
                    };
                    const exec = keyMap[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventKey"])(event)];
                    if (exec) {
                        exec(event);
                        event.preventDefault();
                        return;
                    }
                    const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEditableElement"])(target)) {
                        return;
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getByTypeahead"].isValidEvent(event)) {
                        send({
                            type: "CONTENT.TYPEAHEAD",
                            key: event.key
                        });
                        event.preventDefault();
                    }
                }
            });
        },
        getListProps () {
            return normalize.element({
                ...parts.list.attrs,
                tabIndex: 0,
                role: !composite ? "listbox" : void 0,
                "aria-labelledby": dom.getTriggerId(state.context),
                "aria-activedescendant": !composite ? ariaActiveDescendant : void 0,
                "aria-multiselectable": !composite && state.context.multiple ? true : void 0
            });
        }
    };
}
var { and, not, or } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guards"];
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "select",
        context: {
            value: [],
            highlightedValue: null,
            loopFocus: false,
            closeOnSelect: !ctx.multiple,
            disabled: false,
            readOnly: false,
            composite: true,
            ...ctx,
            highlightedItem: null,
            selectedItems: [],
            valueAsString: "",
            collection: ctx.collection ?? collection.empty(),
            typeahead: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getByTypeahead"].defaultOptions,
            fieldsetDisabled: false,
            positioning: {
                placement: "bottom-start",
                gutter: 8,
                ...ctx.positioning
            }
        },
        computed: {
            hasSelectedItems: (ctx2)=>ctx2.value.length > 0,
            isTypingAhead: (ctx2)=>ctx2.typeahead.keysSoFar !== "",
            isDisabled: (ctx2)=>!!ctx2.disabled || ctx2.fieldsetDisabled,
            isInteractive: (ctx2)=>!(ctx2.isDisabled || ctx2.readOnly)
        },
        initial: ctx.open ? "open" : "idle",
        created: [
            "syncCollection"
        ],
        entry: [
            "syncSelectElement"
        ],
        watch: {
            open: [
                "toggleVisibility"
            ],
            value: [
                "syncSelectedItems",
                "syncSelectElement"
            ],
            highlightedValue: [
                "syncHighlightedItem"
            ],
            collection: [
                "syncCollection"
            ]
        },
        on: {
            "HIGHLIGHTED_VALUE.SET": {
                actions: [
                    "setHighlightedItem"
                ]
            },
            "ITEM.SELECT": {
                actions: [
                    "selectItem"
                ]
            },
            "ITEM.CLEAR": {
                actions: [
                    "clearItem"
                ]
            },
            "VALUE.SET": {
                actions: [
                    "setSelectedItems"
                ]
            },
            "VALUE.CLEAR": {
                actions: [
                    "clearSelectedItems"
                ]
            },
            "CLEAR.CLICK": {
                actions: [
                    "clearSelectedItems",
                    "focusTriggerEl"
                ]
            },
            "COLLECTION.SET": {
                actions: [
                    "setCollection"
                ]
            }
        },
        activities: [
            "trackFormControlState"
        ],
        states: {
            idle: {
                tags: [
                    "closed"
                ],
                on: {
                    "CONTROLLED.OPEN": [
                        {
                            guard: "isTriggerClickEvent",
                            target: "open",
                            actions: [
                                "setInitialFocus",
                                "highlightFirstSelectedItem"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setInitialFocus"
                            ]
                        }
                    ],
                    "TRIGGER.CLICK": [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen",
                                "setInitialFocus",
                                "highlightFirstSelectedItem"
                            ]
                        }
                    ],
                    "TRIGGER.FOCUS": {
                        target: "focused"
                    },
                    OPEN: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setInitialFocus",
                                "invokeOnOpen"
                            ]
                        }
                    ]
                }
            },
            focused: {
                tags: [
                    "closed"
                ],
                on: {
                    "CONTROLLED.OPEN": [
                        {
                            guard: "isTriggerClickEvent",
                            target: "open",
                            actions: [
                                "setInitialFocus",
                                "highlightFirstSelectedItem"
                            ]
                        },
                        {
                            guard: "isTriggerArrowUpEvent",
                            target: "open",
                            actions: [
                                "setInitialFocus",
                                "highlightComputedLastItem"
                            ]
                        },
                        {
                            guard: or("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
                            target: "open",
                            actions: [
                                "setInitialFocus",
                                "highlightComputedFirstItem"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setInitialFocus"
                            ]
                        }
                    ],
                    OPEN: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setInitialFocus",
                                "invokeOnOpen"
                            ]
                        }
                    ],
                    "TRIGGER.BLUR": {
                        target: "idle"
                    },
                    "TRIGGER.CLICK": [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setInitialFocus",
                                "invokeOnOpen",
                                "highlightFirstSelectedItem"
                            ]
                        }
                    ],
                    "TRIGGER.ENTER": [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setInitialFocus",
                                "invokeOnOpen",
                                "highlightComputedFirstItem"
                            ]
                        }
                    ],
                    "TRIGGER.ARROW_UP": [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setInitialFocus",
                                "invokeOnOpen",
                                "highlightComputedLastItem"
                            ]
                        }
                    ],
                    "TRIGGER.ARROW_DOWN": [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setInitialFocus",
                                "invokeOnOpen",
                                "highlightComputedFirstItem"
                            ]
                        }
                    ],
                    "TRIGGER.ARROW_LEFT": [
                        {
                            guard: and(not("multiple"), "hasSelectedItems"),
                            actions: [
                                "selectPreviousItem"
                            ]
                        },
                        {
                            guard: not("multiple"),
                            actions: [
                                "selectLastItem"
                            ]
                        }
                    ],
                    "TRIGGER.ARROW_RIGHT": [
                        {
                            guard: and(not("multiple"), "hasSelectedItems"),
                            actions: [
                                "selectNextItem"
                            ]
                        },
                        {
                            guard: not("multiple"),
                            actions: [
                                "selectFirstItem"
                            ]
                        }
                    ],
                    "TRIGGER.HOME": {
                        guard: not("multiple"),
                        actions: [
                            "selectFirstItem"
                        ]
                    },
                    "TRIGGER.END": {
                        guard: not("multiple"),
                        actions: [
                            "selectLastItem"
                        ]
                    },
                    "TRIGGER.TYPEAHEAD": {
                        guard: not("multiple"),
                        actions: [
                            "selectMatchingItem"
                        ]
                    }
                }
            },
            open: {
                tags: [
                    "open"
                ],
                exit: [
                    "scrollContentToTop"
                ],
                activities: [
                    "trackDismissableElement",
                    "computePlacement",
                    "scrollToHighlightedItem"
                ],
                on: {
                    "CONTROLLED.CLOSE": {
                        target: "focused",
                        actions: [
                            "focusTriggerEl",
                            "clearHighlightedItem"
                        ]
                    },
                    CLOSE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "focused",
                            actions: [
                                "invokeOnClose",
                                "focusTriggerEl",
                                "clearHighlightedItem"
                            ]
                        }
                    ],
                    "TRIGGER.CLICK": [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "focused",
                            actions: [
                                "invokeOnClose",
                                "clearHighlightedItem"
                            ]
                        }
                    ],
                    "ITEM.CLICK": [
                        {
                            guard: and("closeOnSelect", "isOpenControlled"),
                            actions: [
                                "selectHighlightedItem",
                                "invokeOnClose"
                            ]
                        },
                        {
                            guard: "closeOnSelect",
                            target: "focused",
                            actions: [
                                "selectHighlightedItem",
                                "invokeOnClose",
                                "focusTriggerEl",
                                "clearHighlightedItem"
                            ]
                        },
                        {
                            actions: [
                                "selectHighlightedItem"
                            ]
                        }
                    ],
                    "CONTENT.HOME": {
                        actions: [
                            "highlightFirstItem"
                        ]
                    },
                    "CONTENT.END": {
                        actions: [
                            "highlightLastItem"
                        ]
                    },
                    "CONTENT.ARROW_DOWN": [
                        {
                            guard: and("hasHighlightedItem", "loop", "isLastItemHighlighted"),
                            actions: [
                                "highlightFirstItem"
                            ]
                        },
                        {
                            guard: "hasHighlightedItem",
                            actions: [
                                "highlightNextItem"
                            ]
                        },
                        {
                            actions: [
                                "highlightFirstItem"
                            ]
                        }
                    ],
                    "CONTENT.ARROW_UP": [
                        {
                            guard: and("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
                            actions: [
                                "highlightLastItem"
                            ]
                        },
                        {
                            guard: "hasHighlightedItem",
                            actions: [
                                "highlightPreviousItem"
                            ]
                        },
                        {
                            actions: [
                                "highlightLastItem"
                            ]
                        }
                    ],
                    "CONTENT.TYPEAHEAD": {
                        actions: [
                            "highlightMatchingItem"
                        ]
                    },
                    "ITEM.POINTER_MOVE": {
                        actions: [
                            "highlightItem"
                        ]
                    },
                    "ITEM.POINTER_LEAVE": {
                        actions: [
                            "clearHighlightedItem"
                        ]
                    },
                    "POSITIONING.SET": {
                        actions: [
                            "reposition"
                        ]
                    }
                }
            }
        }
    }, {
        guards: {
            loop: (ctx2)=>!!ctx2.loopFocus,
            multiple: (ctx2)=>!!ctx2.multiple,
            hasSelectedItems: (ctx2)=>!!ctx2.hasSelectedItems,
            hasHighlightedItem: (ctx2)=>ctx2.highlightedValue != null,
            isFirstItemHighlighted: (ctx2)=>ctx2.highlightedValue === ctx2.collection.firstValue,
            isLastItemHighlighted: (ctx2)=>ctx2.highlightedValue === ctx2.collection.lastValue,
            closeOnSelect: (ctx2, evt)=>!!(evt.closeOnSelect ?? ctx2.closeOnSelect),
            // guard assertions (for controlled mode)
            isOpenControlled: (ctx2)=>!!ctx2["open.controlled"],
            isTriggerClickEvent: (_ctx, evt)=>evt.previousEvent?.type === "TRIGGER.CLICK",
            isTriggerEnterEvent: (_ctx, evt)=>evt.previousEvent?.type === "TRIGGER.ENTER",
            isTriggerArrowUpEvent: (_ctx, evt)=>evt.previousEvent?.type === "TRIGGER.ARROW_UP",
            isTriggerArrowDownEvent: (_ctx, evt)=>evt.previousEvent?.type === "TRIGGER.ARROW_DOWN"
        },
        activities: {
            trackFormControlState (ctx2, _evt, { initialContext }) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackFormControl"])(dom.getHiddenSelectEl(ctx2), {
                    onFieldsetDisabledChange (disabled) {
                        ctx2.fieldsetDisabled = disabled;
                    },
                    onFormReset () {
                        set.selectedItems(ctx2, initialContext.value);
                    }
                });
            },
            trackDismissableElement (ctx2, _evt, { send }) {
                const contentEl = ()=>dom.getContentEl(ctx2);
                let restoreFocus = true;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackDismissableElement"])(contentEl, {
                    defer: true,
                    exclude: [
                        dom.getTriggerEl(ctx2),
                        dom.getClearTriggerEl(ctx2)
                    ],
                    onFocusOutside: ctx2.onFocusOutside,
                    onPointerDownOutside: ctx2.onPointerDownOutside,
                    onInteractOutside (event) {
                        ctx2.onInteractOutside?.(event);
                        restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
                    },
                    onDismiss () {
                        send({
                            type: "CLOSE",
                            src: "interact-outside",
                            restoreFocus
                        });
                    }
                });
            },
            computePlacement (ctx2) {
                ctx2.currentPlacement = ctx2.positioning.placement;
                const triggerEl = ()=>dom.getTriggerEl(ctx2);
                const positionerEl = ()=>dom.getPositionerEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(triggerEl, positionerEl, {
                    defer: true,
                    ...ctx2.positioning,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            scrollToHighlightedItem (ctx2, _evt, { getState }) {
                const exec = (immediate)=>{
                    if (ctx2.highlightedValue == null) return;
                    const state = getState();
                    if (state.event.type.includes("POINTER")) return;
                    const optionEl = dom.getHighlightedOptionEl(ctx2);
                    const contentEl2 = dom.getContentEl(ctx2);
                    if (ctx2.scrollToIndexFn) {
                        const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);
                        ctx2.scrollToIndexFn({
                            index: highlightedIndex,
                            immediate
                        });
                        return;
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scrollIntoView"])(optionEl, {
                        rootEl: contentEl2,
                        block: "nearest"
                    });
                };
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>exec(true));
                const contentEl = ()=>dom.getContentEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["observeAttributes"])(contentEl, {
                    defer: true,
                    attributes: [
                        "data-activedescendant"
                    ],
                    callback () {
                        exec(false);
                    }
                });
            }
        },
        actions: {
            reposition (ctx2, evt) {
                const positionerEl = ()=>dom.getPositionerEl(ctx2);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(dom.getTriggerEl(ctx2), positionerEl, {
                    ...ctx2.positioning,
                    ...evt.options,
                    defer: true,
                    listeners: false,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            toggleVisibility (ctx2, evt, { send }) {
                send({
                    type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
                    previousEvent: evt
                });
            },
            highlightPreviousItem (ctx2) {
                if (ctx2.highlightedValue == null) return;
                const value = ctx2.collection.getPreviousValue(ctx2.highlightedValue);
                set.highlightedItem(ctx2, value);
            },
            highlightNextItem (ctx2) {
                if (ctx2.highlightedValue == null) return;
                const value = ctx2.collection.getNextValue(ctx2.highlightedValue);
                set.highlightedItem(ctx2, value);
            },
            highlightFirstItem (ctx2) {
                const value = ctx2.collection.firstValue;
                set.highlightedItem(ctx2, value);
            },
            highlightLastItem (ctx2) {
                const value = ctx2.collection.lastValue;
                set.highlightedItem(ctx2, value);
            },
            setInitialFocus (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getInitialFocus"])({
                        root: dom.getContentEl(ctx2)
                    });
                    element?.focus({
                        preventScroll: true
                    });
                });
            },
            focusTriggerEl (ctx2, evt) {
                const restoreFocus = evt.restoreFocus ?? evt.previousEvent?.restoreFocus;
                if (restoreFocus != null && !restoreFocus) return;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const element = dom.getTriggerEl(ctx2);
                    element?.focus({
                        preventScroll: true
                    });
                });
            },
            selectHighlightedItem (ctx2, evt) {
                let value = evt.value ?? ctx2.highlightedValue;
                if (value == null) return;
                const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(value);
                value = nullable ? null : value;
                set.selectedItem(ctx2, value, nullable);
            },
            highlightComputedFirstItem (ctx2) {
                const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.firstValue;
                set.highlightedItem(ctx2, value);
            },
            highlightComputedLastItem (ctx2) {
                const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.lastValue;
                set.highlightedItem(ctx2, value);
            },
            highlightFirstSelectedItem (ctx2) {
                if (!ctx2.hasSelectedItems) return;
                const [value] = ctx2.collection.sort(ctx2.value);
                set.highlightedItem(ctx2, value);
            },
            highlightItem (ctx2, evt) {
                set.highlightedItem(ctx2, evt.value);
            },
            highlightMatchingItem (ctx2, evt) {
                const value = ctx2.collection.search(evt.key, {
                    state: ctx2.typeahead,
                    currentValue: ctx2.highlightedValue
                });
                if (value == null) return;
                set.highlightedItem(ctx2, value);
            },
            setHighlightedItem (ctx2, evt) {
                set.highlightedItem(ctx2, evt.value);
            },
            clearHighlightedItem (ctx2) {
                set.highlightedItem(ctx2, null, true);
            },
            selectItem (ctx2, evt) {
                const nullable = ctx2.deselectable && !ctx2.multiple && ctx2.value.includes(evt.value);
                const value = nullable ? null : evt.value;
                set.selectedItem(ctx2, value, nullable);
            },
            clearItem (ctx2, evt) {
                const value = ctx2.value.filter((v)=>v !== evt.value);
                set.selectedItems(ctx2, value);
            },
            setSelectedItems (ctx2, evt) {
                set.selectedItems(ctx2, evt.value);
            },
            clearSelectedItems (ctx2) {
                set.selectedItems(ctx2, []);
            },
            selectPreviousItem (ctx2) {
                const value = ctx2.collection.getPreviousValue(ctx2.value[0]);
                set.selectedItem(ctx2, value);
            },
            selectNextItem (ctx2) {
                const value = ctx2.collection.getNextValue(ctx2.value[0]);
                set.selectedItem(ctx2, value);
            },
            selectFirstItem (ctx2) {
                const value = ctx2.collection.firstValue;
                set.selectedItem(ctx2, value);
            },
            selectLastItem (ctx2) {
                const value = ctx2.collection.lastValue;
                set.selectedItem(ctx2, value);
            },
            selectMatchingItem (ctx2, evt) {
                const value = ctx2.collection.search(evt.key, {
                    state: ctx2.typeahead,
                    currentValue: ctx2.value[0]
                });
                if (value == null) return;
                set.selectedItem(ctx2, value);
            },
            scrollContentToTop (ctx2) {
                if (ctx2.scrollToIndexFn) {
                    ctx2.scrollToIndexFn({
                        index: 0,
                        immediate: true
                    });
                } else {
                    dom.getContentEl(ctx2)?.scrollTo(0, 0);
                }
            },
            invokeOnOpen (ctx2) {
                ctx2.onOpenChange?.({
                    open: true
                });
            },
            invokeOnClose (ctx2) {
                ctx2.onOpenChange?.({
                    open: false
                });
            },
            syncSelectElement (ctx2) {
                const selectEl = dom.getHiddenSelectEl(ctx2);
                if (!selectEl) return;
                if (ctx2.value.length === 0 && !ctx2.multiple) {
                    selectEl.selectedIndex = -1;
                    return;
                }
                for (const option of selectEl.options){
                    option.selected = ctx2.value.includes(option.value);
                }
            },
            setCollection (ctx2, evt) {
                ctx2.collection = evt.value;
            },
            syncCollection (ctx2) {
                const selectedItems = ctx2.collection.findMany(ctx2.value);
                const valueAsString = ctx2.collection.stringifyItems(selectedItems);
                ctx2.highlightedItem = ctx2.collection.find(ctx2.highlightedValue);
                ctx2.selectedItems = selectedItems;
                ctx2.valueAsString = valueAsString;
            },
            syncSelectedItems (ctx2) {
                sync.valueChange(ctx2);
            },
            syncHighlightedItem (ctx2) {
                sync.highlightChange(ctx2);
            }
        }
    });
}
function dispatchChangeEvent(ctx) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
        const node = dom.getHiddenSelectEl(ctx);
        if (!node) return;
        const win = dom.getWin(ctx);
        const changeEvent = new win.Event("change", {
            bubbles: true,
            composed: true
        });
        node.dispatchEvent(changeEvent);
    });
}
var sync = {
    valueChange: (ctx)=>{
        const prevSelectedItems = ctx.selectedItems;
        ctx.selectedItems = ctx.value.map((value)=>{
            const foundItem = prevSelectedItems.find((item)=>ctx.collection.getItemValue(item) === value);
            if (foundItem) return foundItem;
            return ctx.collection.find(value);
        });
        ctx.valueAsString = ctx.collection.stringifyItems(ctx.selectedItems);
    },
    highlightChange: (ctx)=>{
        ctx.highlightedItem = ctx.collection.find(ctx.highlightedValue);
    }
};
var invoke = {
    valueChange: (ctx)=>{
        sync.valueChange(ctx);
        ctx.onValueChange?.({
            value: Array.from(ctx.value),
            items: Array.from(ctx.selectedItems)
        });
        dispatchChangeEvent(ctx);
    },
    highlightChange: (ctx)=>{
        sync.highlightChange(ctx);
        ctx.onHighlightChange?.({
            highlightedValue: ctx.highlightedValue,
            highlightedItem: ctx.highlightedItem,
            highlightedIndex: ctx.collection.indexOf(ctx.highlightedValue)
        });
    }
};
var set = {
    selectedItem: (ctx, value, force = false)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value, value)) return;
        if (value == null && !force) return;
        if (value == null && force) {
            ctx.value = [];
            invoke.valueChange(ctx);
            return;
        }
        ctx.value = ctx.multiple ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addOrRemove"])(ctx.value, value) : [
            value
        ];
        invoke.valueChange(ctx);
    },
    selectedItems: (ctx, value)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value, value)) return;
        ctx.value = value;
        invoke.valueChange(ctx);
    },
    highlightedItem: (ctx, value, force = false)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.highlightedValue, value)) return;
        if (value == null && !force) return;
        ctx.highlightedValue = value ?? null;
        invoke.highlightChange(ctx);
    }
};
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "closeOnSelect",
    "collection",
    "dir",
    "disabled",
    "deselectable",
    "form",
    "getRootNode",
    "highlightedValue",
    "id",
    "ids",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "open.controlled",
    "open",
    "composite",
    "positioning",
    "required",
    "readOnly",
    "scrollToIndexFn",
    "value"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
var itemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "item",
    "persistFocus"
]);
var splitItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(itemProps);
var itemGroupProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "id"
]);
var splitItemGroupProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(itemGroupProps);
var itemGroupLabelProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "htmlFor"
]);
var splitItemGroupLabelProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(itemGroupLabelProps);
;
}}),
"[project]/node_modules/@zag-js/select/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as selectAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "selectAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$select$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$select$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/select/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/numeric-range/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/index.ts
__turbopack_esm__({
    "clampValue": (()=>clampValue),
    "getClosestValueIndex": (()=>getClosestValueIndex),
    "getMaxValueAtIndex": (()=>getMaxValueAtIndex),
    "getMinValueAtIndex": (()=>getMinValueAtIndex),
    "getNextStepValue": (()=>getNextStepValue),
    "getPercentValue": (()=>getPercentValue),
    "getPreviousStepValue": (()=>getPreviousStepValue),
    "getRoundedValue": (()=>getRoundedValue),
    "getValuePercent": (()=>getValuePercent),
    "getValueRanges": (()=>getValueRanges),
    "getValueSetterAtIndex": (()=>getValueSetterAtIndex),
    "getValueTransformer": (()=>getValueTransformer),
    "isValueAtMax": (()=>isValueAtMax),
    "isValueAtMin": (()=>isValueAtMin),
    "isValueWithinRange": (()=>isValueWithinRange),
    "mod": (()=>mod),
    "roundToStepPrecision": (()=>roundToStepPrecision),
    "snapValueToStep": (()=>snapValueToStep),
    "toFixedNumber": (()=>toFixedNumber)
});
function getMinValueAtIndex(index, values, minValue) {
    return index === 0 ? minValue : values[index - 1];
}
function getMaxValueAtIndex(index, values, maxValue) {
    return index === values.length - 1 ? maxValue : values[index + 1];
}
function isValueAtMax(value, maxValue) {
    return value >= maxValue;
}
function isValueAtMin(value, minValue) {
    return value <= minValue;
}
function isValueWithinRange(value, minValue, maxValue) {
    return value >= minValue && value <= maxValue;
}
function getRoundedValue(value, minValue, step) {
    return Math.round((value - minValue) / step) * step + minValue;
}
function clampValue(value, minValue, maxValue) {
    return Math.min(Math.max(value, minValue), maxValue);
}
function getValuePercent(value, minValue, maxValue) {
    return (value - minValue) / (maxValue - minValue);
}
function getPercentValue(percent, minValue, maxValue, step) {
    const value = percent * (maxValue - minValue) + minValue;
    const roundedValue = getRoundedValue(value, minValue, step);
    return clampValue(roundedValue, minValue, maxValue);
}
function roundToStepPrecision(value, step) {
    let roundedValue = value;
    let stepString = step.toString();
    let pointIndex = stepString.indexOf(".");
    let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;
    if (precision > 0) {
        let pow = Math.pow(10, precision);
        roundedValue = Math.round(roundedValue * pow) / pow;
    }
    return roundedValue;
}
function snapValueToStep(value, min, max, step) {
    min = Number(min);
    max = Number(max);
    let remainder = (value - (isNaN(min) ? 0 : min)) % step;
    let snappedValue = roundToStepPrecision(Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder, step);
    if (!isNaN(min)) {
        if (snappedValue < min) {
            snappedValue = min;
        } else if (!isNaN(max) && snappedValue > max) {
            snappedValue = min + Math.floor(roundToStepPrecision((max - min) / step, step)) * step;
        }
    } else if (!isNaN(max) && snappedValue > max) {
        snappedValue = Math.floor(roundToStepPrecision(max / step, step)) * step;
    }
    snappedValue = roundToStepPrecision(snappedValue, step);
    return snappedValue;
}
function setValueAtIndex(values, index, value) {
    if (values[index] === value) return values;
    return [
        ...values.slice(0, index),
        value,
        ...values.slice(index + 1)
    ];
}
function getValueSetterAtIndex(index, ctx) {
    const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
    const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
    let nextValues = ctx.values.slice();
    return function setValue(value) {
        let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);
        nextValues = setValueAtIndex(nextValues, index, value);
        nextValues[index] = nextValue;
        return nextValues;
    };
}
function getNextStepValue(index, ctx) {
    const nextValue = ctx.values[index] + ctx.step;
    return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue(index, ctx) {
    const nextValue = ctx.values[index] - ctx.step;
    return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getClosestValueIndex(values, targetValue) {
    let targetIndex = values.findIndex((value)=>targetValue - value < 0);
    if (targetIndex === 0) {
        return targetIndex;
    }
    if (targetIndex === -1) {
        return values.length - 1;
    }
    let valueBefore = values[targetIndex - 1];
    let valueAfter = values[targetIndex];
    if (Math.abs(valueBefore - targetValue) < Math.abs(valueAfter - targetValue)) {
        return targetIndex - 1;
    }
    return targetIndex;
}
function getValueRanges(values, minValue, maxValue, gap) {
    return values.map((value, index)=>{
        const min = index === 0 ? minValue : values[index - 1] + gap;
        const max = index === values.length - 1 ? maxValue : values[index + 1] - gap;
        return {
            min,
            max,
            value
        };
    });
}
function getValueTransformer(valueA, valueB) {
    const input = {
        min: valueA[0],
        max: valueA[1]
    };
    const output = {
        min: valueB[0],
        max: valueB[1]
    };
    return function getValue(value) {
        if (input.min === input.max || output.min === output.max) return output.min;
        const ratio = (output.max - output.min) / (input.max - input.min);
        return output.min + ratio * (value - input.min);
    };
}
function toFixedNumber(value, digits = 0, base = 10) {
    const pow = Math.pow(base, digits);
    return Math.round(value * pow) / pow;
}
function mod(value, modulo) {
    return (value % modulo + modulo) % modulo;
}
;
}}),
"[project]/node_modules/@zag-js/element-size/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/track-size.ts
__turbopack_esm__({
    "trackElementSize": (()=>trackElementSize),
    "trackElementsSize": (()=>trackElementsSize)
});
function trackElementSize(element, callback) {
    if (!element) {
        callback(void 0);
        return;
    }
    callback({
        width: element.offsetWidth,
        height: element.offsetHeight
    });
    const win = element.ownerDocument.defaultView ?? window;
    const observer = new win.ResizeObserver((entries)=>{
        if (!Array.isArray(entries) || !entries.length) return;
        const [entry] = entries;
        let width;
        let height;
        if ("borderBoxSize" in entry) {
            const borderSizeEntry = entry["borderBoxSize"];
            const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
            width = borderSize["inlineSize"];
            height = borderSize["blockSize"];
        } else {
            width = element.offsetWidth;
            height = element.offsetHeight;
        }
        callback({
            width,
            height
        });
    });
    observer.observe(element, {
        box: "border-box"
    });
    return ()=>observer.unobserve(element);
}
// src/track-sizes.ts
function trackElementsSize(options) {
    const { getNodes, observeMutation = true, callback } = options;
    const cleanups = [];
    let firstNode = null;
    function trigger() {
        const elements = getNodes();
        firstNode = elements[0];
        const fns = elements.map((element, index)=>trackElementSize(element, (size)=>{
                callback(size, index);
            }));
        cleanups.push(...fns);
    }
    trigger();
    if (observeMutation) {
        const fn = trackMutation(firstNode, trigger);
        cleanups.push(fn);
    }
    return ()=>{
        cleanups.forEach((cleanup)=>{
            cleanup?.();
        });
    };
}
function trackMutation(el, cb) {
    if (!el || !el.parentElement) return;
    const win = el.ownerDocument?.defaultView ?? window;
    const observer = new win.MutationObserver(()=>{
        cb();
    });
    observer.observe(el.parentElement, {
        childList: true
    });
    return ()=>{
        observer.disconnect();
    };
}
;
}}),
"[project]/node_modules/@zag-js/slider/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitProps": (()=>splitProps),
    "splitThumbProps": (()=>splitThumbProps),
    "thumbProps": (()=>thumbProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/numeric-range/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/form-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$element$2d$size$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/element-size/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
// src/slider.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("slider").parts("root", "label", "thumb", "valueText", "track", "range", "control", "markerGroup", "marker", "draggingIndicator");
var parts = anatomy.build();
function getBounds(value) {
    const firstValue = value[0];
    const lastThumb = value[value.length - 1];
    return [
        firstValue,
        lastThumb
    ];
}
function getRangeOffsets(ctx) {
    const [firstPercent, lastPercent] = getBounds(ctx.valuePercent);
    if (ctx.valuePercent.length === 1) {
        if (ctx.origin === "center") {
            const isNegative = ctx.valuePercent[0] < 50;
            const start = isNegative ? `${ctx.valuePercent[0]}%` : "50%";
            const end = isNegative ? "50%" : `${100 - ctx.valuePercent[0]}%`;
            return {
                start,
                end
            };
        }
        return {
            start: "0%",
            end: `${100 - lastPercent}%`
        };
    }
    return {
        start: `${firstPercent}%`,
        end: `${100 - lastPercent}%`
    };
}
function getRangeStyle(ctx) {
    if (ctx.isVertical) {
        return {
            position: "absolute",
            bottom: "var(--slider-range-start)",
            top: "var(--slider-range-end)"
        };
    }
    return {
        position: "absolute",
        [ctx.isRtl ? "right" : "left"]: "var(--slider-range-start)",
        [ctx.isRtl ? "left" : "right"]: "var(--slider-range-end)"
    };
}
function getVerticalThumbOffset(ctx) {
    const { height = 0 } = ctx.thumbSize ?? {};
    const getValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getValueTransformer"])([
        ctx.min,
        ctx.max
    ], [
        -height / 2,
        height / 2
    ]);
    return parseFloat(getValue(ctx.value).toFixed(2));
}
function getHorizontalThumbOffset(ctx) {
    const { width = 0 } = ctx.thumbSize ?? {};
    if (ctx.isRtl) {
        const getValue2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getValueTransformer"])([
            ctx.max,
            ctx.min
        ], [
            -width / 2,
            width / 2
        ]);
        return -1 * parseFloat(getValue2(ctx.value).toFixed(2));
    }
    const getValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getValueTransformer"])([
        ctx.min,
        ctx.max
    ], [
        -width / 2,
        width / 2
    ]);
    return parseFloat(getValue(ctx.value).toFixed(2));
}
function getOffset(ctx, percent) {
    if (ctx.thumbAlignment === "center") return `${percent}%`;
    const offset = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx);
    return `calc(${percent}% - ${offset}px)`;
}
function getThumbOffset(ctx) {
    let percent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getValuePercent"])(ctx.value, ctx.min, ctx.max) * 100;
    return getOffset(ctx, percent);
}
function getVisibility(ctx) {
    let visibility = "visible";
    if (ctx.thumbAlignment === "contain" && !ctx.hasMeasuredThumbSize) {
        visibility = "hidden";
    }
    return visibility;
}
function getThumbStyle(ctx, index) {
    const placementProp = ctx.isVertical ? "bottom" : "insetInlineStart";
    return {
        visibility: getVisibility(ctx),
        position: "absolute",
        transform: "var(--slider-thumb-transform)",
        [placementProp]: `var(--slider-thumb-offset-${index})`
    };
}
function getControlStyle() {
    return {
        touchAction: "none",
        userSelect: "none",
        WebkitUserSelect: "none",
        position: "relative"
    };
}
function getRootStyle(ctx) {
    const range = getRangeOffsets(ctx);
    const offsetStyles = ctx.value.reduce((styles, value, index)=>{
        const offset = getThumbOffset({
            ...ctx,
            value
        });
        return {
            ...styles,
            [`--slider-thumb-offset-${index}`]: offset
        };
    }, {});
    return {
        ...offsetStyles,
        "--slider-thumb-transform": ctx.isVertical ? "translateY(50%)" : ctx.isRtl ? "translateX(50%)" : "translateX(-50%)",
        "--slider-range-start": range.start,
        "--slider-range-end": range.end
    };
}
function getMarkerStyle(ctx, value) {
    return {
        // @ts-expect-error
        visibility: getVisibility(ctx),
        position: "absolute",
        pointerEvents: "none",
        // @ts-expect-error
        [ctx.isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset({
            ...ctx,
            value
        }),
        translate: "var(--tx) var(--ty)",
        "--tx": ctx.isHorizontal ? ctx.isRtl ? "50%" : "-50%" : "0%",
        "--ty": !ctx.isHorizontal ? "50%" : "0%"
    };
}
function getMarkerGroupStyle() {
    return {
        userSelect: "none",
        WebkitUserSelect: "none",
        pointerEvents: "none",
        position: "relative"
    };
}
var styleGetterFns = {
    getRootStyle,
    getControlStyle,
    getThumbStyle,
    getRangeStyle,
    getMarkerStyle,
    getMarkerGroupStyle
};
// src/slider.dom.ts
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    ...styleGetterFns,
    getRootId: (ctx)=>ctx.ids?.root ?? `slider:${ctx.id}`,
    getThumbId: (ctx, index)=>ctx.ids?.thumb?.(index) ?? `slider:${ctx.id}:thumb:${index}`,
    getHiddenInputId: (ctx, index)=>ctx.ids?.hiddenInput?.(index) ?? `slider:${ctx.id}:input:${index}`,
    getControlId: (ctx)=>ctx.ids?.control ?? `slider:${ctx.id}:control`,
    getTrackId: (ctx)=>ctx.ids?.track ?? `slider:${ctx.id}:track`,
    getRangeId: (ctx)=>ctx.ids?.range ?? `slider:${ctx.id}:range`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `slider:${ctx.id}:label`,
    getValueTextId: (ctx)=>ctx.ids?.valueText ?? `slider:${ctx.id}:value-text`,
    getMarkerId: (ctx, value)=>ctx.ids?.marker?.(value) ?? `slider:${ctx.id}:marker:${value}`,
    getRootEl: (ctx)=>dom.getById(ctx, dom.getRootId(ctx)),
    getThumbEl: (ctx, index)=>dom.getById(ctx, dom.getThumbId(ctx, index)),
    getHiddenInputEl: (ctx, index)=>dom.getById(ctx, dom.getHiddenInputId(ctx, index)),
    getControlEl: (ctx)=>dom.getById(ctx, dom.getControlId(ctx)),
    getElements: (ctx)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["queryAll"])(dom.getControlEl(ctx), "[role=slider]"),
    getFirstEl: (ctx)=>dom.getElements(ctx)[0],
    getRangeEl: (ctx)=>dom.getById(ctx, dom.getRangeId(ctx)),
    getValueFromPoint (ctx, point) {
        const controlEl = dom.getControlEl(ctx);
        if (!controlEl) return;
        const relativePoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRelativePoint"])(point, controlEl);
        const percent = relativePoint.getPercentValue({
            orientation: ctx.orientation,
            dir: ctx.dir,
            inverted: {
                y: true
            }
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPercentValue"])(percent, ctx.min, ctx.max, ctx.step);
    },
    dispatchChangeEvent (ctx) {
        const valueArray = Array.from(ctx.value);
        valueArray.forEach((value, index)=>{
            const inputEl = dom.getHiddenInputEl(ctx, index);
            if (!inputEl) return;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dispatchInputValueEvent"])(inputEl, {
                value
            });
        });
    }
});
function normalizeValues(ctx, nextValues) {
    return nextValues.map((value, index, values)=>{
        return constrainValue({
            ...ctx,
            value: values
        }, value, index);
    });
}
function getRangeAtIndex(ctx, index) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getValueRanges"])(ctx.value, ctx.min, ctx.max, ctx.minStepsBetweenThumbs)[index];
}
function constrainValue(ctx, value, index) {
    const range = getRangeAtIndex(ctx, index);
    const snapValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["snapValueToStep"])(value, ctx.min, ctx.max, ctx.step);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(snapValue, range.min, range.max);
}
function decrement(ctx, index, step) {
    const idx = index ?? ctx.focusedIndex;
    const range = getRangeAtIndex(ctx, idx);
    const nextValues = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPreviousStepValue"])(idx, {
        ...range,
        step: step ?? ctx.step,
        values: ctx.value
    });
    nextValues[idx] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(nextValues[idx], range.min, range.max);
    return nextValues;
}
function increment(ctx, index, step) {
    const idx = index ?? ctx.focusedIndex;
    const range = getRangeAtIndex(ctx, idx);
    const nextValues = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNextStepValue"])(idx, {
        ...range,
        step: step ?? ctx.step,
        values: ctx.value
    });
    nextValues[idx] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(nextValues[idx], range.min, range.max);
    return nextValues;
}
function getClosestIndex(ctx, pointValue) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getClosestValueIndex"])(ctx.value, pointValue);
}
function assignArray(current, next) {
    for(let i = 0; i < next.length; i++){
        const value = next[i];
        current[i] = value;
    }
}
// src/slider.connect.ts
function connect(state, send, normalize) {
    const ariaLabel = state.context["aria-label"];
    const ariaLabelledBy = state.context["aria-labelledby"];
    const sliderValue = state.context.value;
    const focused = state.matches("focus");
    const dragging = state.matches("dragging");
    const disabled = state.context.isDisabled;
    const invalid = state.context.invalid;
    const interactive = state.context.isInteractive;
    const isHorizontal = state.context.orientation === "horizontal";
    const isVertical = state.context.orientation === "vertical";
    function getValuePercentFn(value) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getValuePercent"])(value, state.context.min, state.context.max);
    }
    function getPercentValueFn(percent) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPercentValue"])(percent, state.context.min, state.context.max, state.context.step);
    }
    return {
        value: state.context.value,
        dragging,
        focused,
        setValue (value) {
            send({
                type: "SET_VALUE",
                value
            });
        },
        getThumbValue (index) {
            return sliderValue[index];
        },
        setThumbValue (index, value) {
            send({
                type: "SET_VALUE",
                index,
                value
            });
        },
        getValuePercent: getValuePercentFn,
        getPercentValue: getPercentValueFn,
        getThumbPercent (index) {
            return getValuePercentFn(sliderValue[index]);
        },
        setThumbPercent (index, percent) {
            const value = getPercentValueFn(percent);
            send({
                type: "SET_VALUE",
                index,
                value
            });
        },
        getThumbMin (index) {
            return getRangeAtIndex(state.context, index).min;
        },
        getThumbMax (index) {
            return getRangeAtIndex(state.context, index).max;
        },
        increment (index) {
            send({
                type: "INCREMENT",
                index
            });
        },
        decrement (index) {
            send({
                type: "DECREMENT",
                index
            });
        },
        focus () {
            if (!interactive) return;
            send({
                type: "FOCUS",
                index: 0
            });
        },
        getLabelProps () {
            return normalize.label({
                ...parts.label.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-orientation": state.context.orientation,
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-dragging": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(dragging),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                id: dom.getLabelId(state.context),
                htmlFor: dom.getHiddenInputId(state.context, 0),
                onClick (event) {
                    if (!interactive) return;
                    event.preventDefault();
                    dom.getFirstEl(state.context)?.focus();
                },
                style: {
                    userSelect: "none",
                    WebkitUserSelect: "none"
                }
            });
        },
        getRootProps () {
            return normalize.element({
                ...parts.root.attrs,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-orientation": state.context.orientation,
                "data-dragging": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(dragging),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                id: dom.getRootId(state.context),
                dir: state.context.dir,
                style: dom.getRootStyle(state.context)
            });
        },
        getValueTextProps () {
            return normalize.element({
                ...parts.valueText.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-orientation": state.context.orientation,
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                id: dom.getValueTextId(state.context)
            });
        },
        getTrackProps () {
            return normalize.element({
                ...parts.track.attrs,
                dir: state.context.dir,
                id: dom.getTrackId(state.context),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-dragging": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(dragging),
                "data-orientation": state.context.orientation,
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                style: {
                    position: "relative"
                }
            });
        },
        getThumbProps (props2) {
            const { index = 0, name } = props2;
            const value = sliderValue[index];
            const range = getRangeAtIndex(state.context, index);
            const valueText = state.context.getAriaValueText?.({
                value,
                index
            });
            const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;
            const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;
            return normalize.element({
                ...parts.thumb.attrs,
                dir: state.context.dir,
                "data-index": index,
                "data-name": name,
                id: dom.getThumbId(state.context, index),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-orientation": state.context.orientation,
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused && state.context.focusedIndex === index),
                "data-dragging": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(dragging && state.context.focusedIndex === index),
                draggable: false,
                "aria-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaAttr"])(disabled),
                "aria-label": _ariaLabel,
                "aria-labelledby": _ariaLabelledBy ?? dom.getLabelId(state.context),
                "aria-orientation": state.context.orientation,
                "aria-valuemax": range.max,
                "aria-valuemin": range.min,
                "aria-valuenow": sliderValue[index],
                "aria-valuetext": valueText,
                role: "slider",
                tabIndex: disabled ? void 0 : 0,
                style: dom.getThumbStyle(state.context, index),
                onPointerDown (event) {
                    if (!interactive) return;
                    send({
                        type: "THUMB_POINTER_DOWN",
                        index
                    });
                    event.stopPropagation();
                },
                onBlur () {
                    if (!interactive) return;
                    send("BLUR");
                },
                onFocus () {
                    if (!interactive) return;
                    send({
                        type: "FOCUS",
                        index
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    const step = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventStep"])(event) * state.context.step;
                    const keyMap = {
                        ArrowUp () {
                            if (isHorizontal) return;
                            send({
                                type: "ARROW_INC",
                                step,
                                src: "ArrowUp"
                            });
                        },
                        ArrowDown () {
                            if (isHorizontal) return;
                            send({
                                type: "ARROW_DEC",
                                step,
                                src: "ArrowDown"
                            });
                        },
                        ArrowLeft () {
                            if (isVertical) return;
                            send({
                                type: "ARROW_DEC",
                                step,
                                src: "ArrowLeft"
                            });
                        },
                        ArrowRight () {
                            if (isVertical) return;
                            send({
                                type: "ARROW_INC",
                                step,
                                src: "ArrowRight"
                            });
                        },
                        PageUp () {
                            send({
                                type: "ARROW_INC",
                                step,
                                src: "PageUp"
                            });
                        },
                        PageDown () {
                            send({
                                type: "ARROW_DEC",
                                step,
                                src: "PageDown"
                            });
                        },
                        Home () {
                            send("HOME");
                        },
                        End () {
                            send("END");
                        }
                    };
                    const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventKey"])(event, state.context);
                    const exec = keyMap[key];
                    if (exec) {
                        exec(event);
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
            });
        },
        getHiddenInputProps (props2) {
            const { index = 0, name } = props2;
            return normalize.input({
                name: name ?? (state.context.name ? state.context.name + (state.context.value.length > 1 ? "[]" : "") : void 0),
                form: state.context.form,
                type: "text",
                hidden: true,
                defaultValue: state.context.value[index],
                id: dom.getHiddenInputId(state.context, index)
            });
        },
        getRangeProps () {
            return normalize.element({
                id: dom.getRangeId(state.context),
                ...parts.range.attrs,
                dir: state.context.dir,
                "data-dragging": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(dragging),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-orientation": state.context.orientation,
                style: dom.getRangeStyle(state.context)
            });
        },
        getControlProps () {
            return normalize.element({
                ...parts.control.attrs,
                dir: state.context.dir,
                id: dom.getControlId(state.context),
                "data-dragging": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(dragging),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-orientation": state.context.orientation,
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                style: dom.getControlStyle(),
                onPointerDown (event) {
                    if (!interactive) return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLeftClick"])(event)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isModifierKey"])(event)) return;
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    send({
                        type: "POINTER_DOWN",
                        point
                    });
                    event.preventDefault();
                    event.stopPropagation();
                }
            });
        },
        getMarkerGroupProps () {
            return normalize.element({
                ...parts.markerGroup.attrs,
                role: "presentation",
                dir: state.context.dir,
                "aria-hidden": true,
                "data-orientation": state.context.orientation,
                style: dom.getMarkerGroupStyle()
            });
        },
        getMarkerProps (props2) {
            const style = dom.getMarkerStyle(state.context, props2.value);
            let markerState;
            const first = state.context.value[0];
            const last = state.context.value[state.context.value.length - 1];
            if (props2.value < first) {
                markerState = "under-value";
            } else if (props2.value > last) {
                markerState = "over-value";
            } else {
                markerState = "at-value";
            }
            return normalize.element({
                ...parts.marker.attrs,
                id: dom.getMarkerId(state.context, props2.value),
                role: "presentation",
                dir: state.context.dir,
                "data-orientation": state.context.orientation,
                "data-value": props2.value,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-state": markerState,
                style
            });
        },
        getDraggingIndicatorProps (props2) {
            const { index = 0 } = props2;
            const isDragging = index === state.context.focusedIndex && dragging;
            return normalize.element({
                ...parts.draggingIndicator.attrs,
                role: "presentation",
                dir: state.context.dir,
                hidden: !isDragging,
                "data-orientation": state.context.orientation,
                "data-state": isDragging ? "open" : "closed",
                style: dom.getThumbStyle(state.context, index)
            });
        }
    };
}
var isEqualSize = (a, b)=>{
    return a?.width === b?.width && a?.height === b?.height;
};
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "slider",
        initial: "idle",
        context: {
            thumbSize: null,
            thumbAlignment: "contain",
            min: 0,
            max: 100,
            step: 1,
            value: [
                0
            ],
            origin: "start",
            orientation: "horizontal",
            dir: "ltr",
            minStepsBetweenThumbs: 0,
            disabled: false,
            readOnly: false,
            ...ctx,
            focusedIndex: -1,
            fieldsetDisabled: false
        },
        computed: {
            isHorizontal: (ctx2)=>ctx2.orientation === "horizontal",
            isVertical: (ctx2)=>ctx2.orientation === "vertical",
            isRtl: (ctx2)=>ctx2.orientation === "horizontal" && ctx2.dir === "rtl",
            isDisabled: (ctx2)=>!!ctx2.disabled || ctx2.fieldsetDisabled,
            isInteractive: (ctx2)=>!(ctx2.readOnly || ctx2.isDisabled),
            hasMeasuredThumbSize: (ctx2)=>ctx2.thumbSize != null,
            valuePercent (ctx2) {
                return ctx2.value.map((value)=>100 * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getValuePercent"])(value, ctx2.min, ctx2.max));
            }
        },
        watch: {
            value: [
                "syncInputElements"
            ]
        },
        entry: [
            "coarseValue"
        ],
        activities: [
            "trackFormControlState",
            "trackThumbsSize"
        ],
        on: {
            SET_VALUE: [
                {
                    guard: "hasIndex",
                    actions: "setValueAtIndex"
                },
                {
                    actions: "setValue"
                }
            ],
            INCREMENT: {
                actions: "incrementThumbAtIndex"
            },
            DECREMENT: {
                actions: "decrementThumbAtIndex"
            }
        },
        states: {
            idle: {
                on: {
                    POINTER_DOWN: {
                        target: "dragging",
                        actions: [
                            "setClosestThumbIndex",
                            "setPointerValue",
                            "focusActiveThumb"
                        ]
                    },
                    FOCUS: {
                        target: "focus",
                        actions: "setFocusedIndex"
                    },
                    THUMB_POINTER_DOWN: {
                        target: "dragging",
                        actions: [
                            "setFocusedIndex",
                            "focusActiveThumb"
                        ]
                    }
                }
            },
            focus: {
                entry: "focusActiveThumb",
                on: {
                    POINTER_DOWN: {
                        target: "dragging",
                        actions: [
                            "setClosestThumbIndex",
                            "setPointerValue",
                            "focusActiveThumb"
                        ]
                    },
                    THUMB_POINTER_DOWN: {
                        target: "dragging",
                        actions: [
                            "setFocusedIndex",
                            "focusActiveThumb"
                        ]
                    },
                    ARROW_DEC: {
                        actions: [
                            "decrementThumbAtIndex",
                            "invokeOnChangeEnd"
                        ]
                    },
                    ARROW_INC: {
                        actions: [
                            "incrementThumbAtIndex",
                            "invokeOnChangeEnd"
                        ]
                    },
                    HOME: {
                        actions: [
                            "setFocusedThumbToMin",
                            "invokeOnChangeEnd"
                        ]
                    },
                    END: {
                        actions: [
                            "setFocusedThumbToMax",
                            "invokeOnChangeEnd"
                        ]
                    },
                    BLUR: {
                        target: "idle",
                        actions: "clearFocusedIndex"
                    }
                }
            },
            dragging: {
                entry: "focusActiveThumb",
                activities: "trackPointerMove",
                on: {
                    POINTER_UP: {
                        target: "focus",
                        actions: "invokeOnChangeEnd"
                    },
                    POINTER_MOVE: {
                        actions: "setPointerValue"
                    }
                }
            }
        }
    }, {
        guards: {
            hasIndex: (_ctx, evt)=>evt.index != null
        },
        activities: {
            trackFormControlState (ctx2, _evt, { initialContext }) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackFormControl"])(dom.getRootEl(ctx2), {
                    onFieldsetDisabledChange (disabled) {
                        ctx2.fieldsetDisabled = disabled;
                    },
                    onFormReset () {
                        set.value(ctx2, initialContext.value);
                    }
                });
            },
            trackPointerMove (ctx2, _evt, { send }) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackPointerMove"])(dom.getDoc(ctx2), {
                    onPointerMove (info) {
                        send({
                            type: "POINTER_MOVE",
                            point: info.point
                        });
                    },
                    onPointerUp () {
                        send("POINTER_UP");
                    }
                });
            },
            trackThumbsSize (ctx2) {
                if (ctx2.thumbAlignment !== "contain" || ctx2.thumbSize) return;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$element$2d$size$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackElementsSize"])({
                    getNodes: ()=>dom.getElements(ctx2),
                    observeMutation: true,
                    callback (size) {
                        if (!size || isEqualSize(ctx2.thumbSize, size)) return;
                        ctx2.thumbSize = size;
                    }
                });
            }
        },
        actions: {
            syncInputElements (ctx2) {
                ctx2.value.forEach((value, index)=>{
                    const inputEl = dom.getHiddenInputEl(ctx2, index);
                    dom.setValue(inputEl, value);
                });
            },
            invokeOnChangeEnd (ctx2) {
                invoke.valueChangeEnd(ctx2);
            },
            setClosestThumbIndex (ctx2, evt) {
                const pointValue = dom.getValueFromPoint(ctx2, evt.point);
                if (pointValue == null) return;
                const focusedIndex = getClosestIndex(ctx2, pointValue);
                set.focusedIndex(ctx2, focusedIndex);
            },
            setFocusedIndex (ctx2, evt) {
                set.focusedIndex(ctx2, evt.index);
            },
            clearFocusedIndex (ctx2) {
                set.focusedIndex(ctx2, -1);
            },
            setPointerValue (ctx2, evt) {
                const pointerValue = dom.getValueFromPoint(ctx2, evt.point);
                if (pointerValue == null) return;
                const value = constrainValue(ctx2, pointerValue, ctx2.focusedIndex);
                set.valueAtIndex(ctx2, ctx2.focusedIndex, value);
            },
            focusActiveThumb (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const thumbEl = dom.getThumbEl(ctx2, ctx2.focusedIndex);
                    thumbEl?.focus({
                        preventScroll: true
                    });
                });
            },
            decrementThumbAtIndex (ctx2, evt) {
                const value = decrement(ctx2, evt.index, evt.step);
                set.value(ctx2, value);
            },
            incrementThumbAtIndex (ctx2, evt) {
                const value = increment(ctx2, evt.index, evt.step);
                set.value(ctx2, value);
            },
            setFocusedThumbToMin (ctx2) {
                const { min } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
                set.valueAtIndex(ctx2, ctx2.focusedIndex, min);
            },
            setFocusedThumbToMax (ctx2) {
                const { max } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
                set.valueAtIndex(ctx2, ctx2.focusedIndex, max);
            },
            coarseValue (ctx2) {
                const value = normalizeValues(ctx2, ctx2.value);
                set.value(ctx2, value);
            },
            setValueAtIndex (ctx2, evt) {
                const value = constrainValue(ctx2, evt.value, evt.index);
                set.valueAtIndex(ctx2, evt.index, value);
            },
            setValue (ctx2, evt) {
                const value = normalizeValues(ctx2, evt.value);
                set.value(ctx2, value);
            }
        }
    });
}
var invoke = {
    valueChange (ctx) {
        ctx.onValueChange?.({
            value: Array.from(ctx.value)
        });
        dom.dispatchChangeEvent(ctx);
    },
    valueChangeEnd (ctx) {
        ctx.onValueChangeEnd?.({
            value: Array.from(ctx.value)
        });
    },
    focusChange (ctx) {
        ctx.onFocusChange?.({
            value: Array.from(ctx.value),
            focusedIndex: ctx.focusedIndex
        });
    }
};
var set = {
    valueAtIndex: (ctx, index, value)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value[index], value)) return;
        ctx.value[index] = value;
        invoke.valueChange(ctx);
    },
    value: (ctx, value)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value, value)) return;
        assignArray(ctx.value, value);
        invoke.valueChange(ctx);
    },
    focusedIndex: (ctx, index)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.focusedIndex, index)) return;
        ctx.focusedIndex = index;
        invoke.focusChange(ctx);
    }
};
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "aria-label",
    "aria-labelledby",
    "dir",
    "disabled",
    "form",
    "getAriaValueText",
    "getRootNode",
    "id",
    "ids",
    "invalid",
    "max",
    "min",
    "minStepsBetweenThumbs",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueChangeEnd",
    "orientation",
    "origin",
    "readOnly",
    "step",
    "thumbAlignment",
    "thumbAlignment",
    "thumbSize",
    "value"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
var thumbProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "index",
    "name"
]);
var splitThumbProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(thumbProps);
;
}}),
"[project]/node_modules/@zag-js/slider/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as sliderAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "sliderAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$slider$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$slider$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/slider/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/switch/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$visible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/focus-visible/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/form-utils/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
// src/switch.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("switch").parts("root", "label", "control", "thumb");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `switch:${ctx.id}`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `switch:${ctx.id}:label`,
    getThumbId: (ctx)=>ctx.ids?.thumb ?? `switch:${ctx.id}:thumb`,
    getControlId: (ctx)=>ctx.ids?.control ?? `switch:${ctx.id}:control`,
    getHiddenInputId: (ctx)=>ctx.ids?.hiddenInput ?? `switch:${ctx.id}:input`,
    getRootEl: (ctx)=>dom.getById(ctx, dom.getRootId(ctx)),
    getHiddenInputEl: (ctx)=>dom.getById(ctx, dom.getHiddenInputId(ctx))
});
// src/switch.connect.ts
function connect(state, send, normalize) {
    const disabled = state.context.isDisabled;
    const readOnly = state.context.readOnly;
    const checked = state.context.checked;
    const focused = !disabled && state.context.focused;
    const focusVisible = !disabled && state.context.focusVisible;
    const dataAttrs = {
        "data-active": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.active),
        "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
        "data-focus-visible": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focusVisible),
        "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(readOnly),
        "data-hover": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.hovered),
        "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
        "data-state": state.context.checked ? "checked" : "unchecked",
        "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.invalid)
    };
    return {
        checked,
        disabled,
        focused,
        setChecked (checked2) {
            send({
                type: "CHECKED.SET",
                checked: checked2,
                isTrusted: false
            });
        },
        toggleChecked () {
            send({
                type: "CHECKED.TOGGLE",
                checked,
                isTrusted: false
            });
        },
        getRootProps () {
            return normalize.label({
                ...parts.root.attrs,
                ...dataAttrs,
                dir: state.context.dir,
                id: dom.getRootId(state.context),
                htmlFor: dom.getHiddenInputId(state.context),
                onPointerMove () {
                    if (disabled) return;
                    send({
                        type: "CONTEXT.SET",
                        context: {
                            hovered: true
                        }
                    });
                },
                onPointerLeave () {
                    if (disabled) return;
                    send({
                        type: "CONTEXT.SET",
                        context: {
                            hovered: false
                        }
                    });
                },
                onClick (event) {
                    if (disabled) return;
                    const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
                    if (target === dom.getHiddenInputEl(state.context)) {
                        event.stopPropagation();
                    }
                }
            });
        },
        getLabelProps () {
            return normalize.element({
                ...parts.label.attrs,
                ...dataAttrs,
                dir: state.context.dir,
                id: dom.getLabelId(state.context)
            });
        },
        getThumbProps () {
            return normalize.element({
                ...parts.thumb.attrs,
                ...dataAttrs,
                dir: state.context.dir,
                id: dom.getThumbId(state.context),
                "aria-hidden": true
            });
        },
        getControlProps () {
            return normalize.element({
                ...parts.control.attrs,
                ...dataAttrs,
                dir: state.context.dir,
                id: dom.getControlId(state.context),
                "aria-hidden": true
            });
        },
        getHiddenInputProps () {
            return normalize.input({
                id: dom.getHiddenInputId(state.context),
                type: "checkbox",
                required: state.context.required,
                defaultChecked: checked,
                disabled,
                "aria-labelledby": dom.getLabelId(state.context),
                "aria-invalid": state.context.invalid,
                name: state.context.name,
                form: state.context.form,
                value: state.context.value,
                style: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["visuallyHiddenStyle"],
                onFocus () {
                    const focusVisible2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$visible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFocusVisible"])();
                    send({
                        type: "CONTEXT.SET",
                        context: {
                            focused: true,
                            focusVisible: focusVisible2
                        }
                    });
                },
                onBlur () {
                    send({
                        type: "CONTEXT.SET",
                        context: {
                            focused: false,
                            focusVisible: false
                        }
                    });
                },
                onClick (event) {
                    if (readOnly) {
                        event.preventDefault();
                        return;
                    }
                    const checked2 = event.currentTarget.checked;
                    send({
                        type: "CHECKED.SET",
                        checked: checked2,
                        isTrusted: true
                    });
                }
            });
        }
    };
}
var { not } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guards"];
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "switch",
        initial: "ready",
        context: {
            checked: false,
            label: "switch",
            value: "on",
            disabled: false,
            ...ctx,
            fieldsetDisabled: false,
            focusVisible: false
        },
        computed: {
            isDisabled: (ctx2)=>ctx2.disabled || ctx2.fieldsetDisabled
        },
        watch: {
            disabled: "removeFocusIfNeeded",
            checked: "syncInputElement"
        },
        activities: [
            "trackFormControlState",
            "trackPressEvent",
            "trackFocusVisible"
        ],
        on: {
            "CHECKED.TOGGLE": [
                {
                    guard: not("isTrusted"),
                    actions: [
                        "toggleChecked",
                        "dispatchChangeEvent"
                    ]
                },
                {
                    actions: [
                        "toggleChecked"
                    ]
                }
            ],
            "CHECKED.SET": [
                {
                    guard: not("isTrusted"),
                    actions: [
                        "setChecked",
                        "dispatchChangeEvent"
                    ]
                },
                {
                    actions: [
                        "setChecked"
                    ]
                }
            ],
            "CONTEXT.SET": {
                actions: [
                    "setContext"
                ]
            }
        },
        states: {
            ready: {}
        }
    }, {
        guards: {
            isTrusted: (_ctx, evt)=>!!evt.isTrusted
        },
        activities: {
            trackPressEvent (ctx2) {
                if (ctx2.isDisabled) return;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackPress"])({
                    pointerNode: dom.getRootEl(ctx2),
                    keyboardNode: dom.getHiddenInputEl(ctx2),
                    isValidKey: (event)=>event.key === " ",
                    onPress: ()=>ctx2.active = false,
                    onPressStart: ()=>ctx2.active = true,
                    onPressEnd: ()=>ctx2.active = false
                });
            },
            trackFocusVisible (ctx2) {
                if (ctx2.isDisabled) return;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$visible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackFocusVisible"])({
                    root: dom.getRootNode(ctx2)
                });
            },
            trackFormControlState (ctx2, _evt, { send, initialContext }) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackFormControl"])(dom.getHiddenInputEl(ctx2), {
                    onFieldsetDisabledChange (disabled) {
                        ctx2.fieldsetDisabled = disabled;
                    },
                    onFormReset () {
                        send({
                            type: "CHECKED.SET",
                            checked: !!initialContext.checked,
                            src: "form-reset"
                        });
                    }
                });
            }
        },
        actions: {
            setContext (ctx2, evt) {
                Object.assign(ctx2, evt.context);
            },
            syncInputElement (ctx2) {
                const inputEl = dom.getHiddenInputEl(ctx2);
                if (!inputEl) return;
                inputEl.checked = !!ctx2.checked;
            },
            removeFocusIfNeeded (ctx2) {
                if (ctx2.disabled && ctx2.focused) {
                    ctx2.focused = false;
                }
            },
            setChecked (ctx2, evt) {
                set.checked(ctx2, evt.checked);
            },
            toggleChecked (ctx2, _evt) {
                set.checked(ctx2, !ctx2.checked);
            },
            dispatchChangeEvent (ctx2) {
                const inputEl = dom.getHiddenInputEl(ctx2);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dispatchInputCheckedEvent"])(inputEl, {
                    checked: ctx2.checked
                });
            }
        }
    });
}
var invoke = {
    change: (ctx)=>{
        ctx.onCheckedChange?.({
            checked: ctx.checked
        });
    }
};
var set = {
    checked: (ctx, checked)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.checked, checked)) return;
        ctx.checked = checked;
        invoke.change(ctx);
    }
};
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "checked",
    "dir",
    "disabled",
    "form",
    "getRootNode",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
;
}}),
"[project]/node_modules/@zag-js/switch/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as switchAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "switchAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$switch$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$switch$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/switch/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/avatar/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
;
;
;
;
;
// src/avatar.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("avatar").parts("root", "image", "fallback");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `avatar:${ctx.id}`,
    getImageId: (ctx)=>ctx.ids?.image ?? `avatar:${ctx.id}:image`,
    getFallbackId: (ctx)=>ctx.ids?.fallback ?? `avatar:${ctx.id}:fallback`,
    getRootEl: (ctx)=>dom.getById(ctx, dom.getRootId(ctx)),
    getImageEl: (ctx)=>dom.getById(ctx, dom.getImageId(ctx))
});
// src/avatar.connect.ts
function connect(state, send, normalize) {
    const loaded = state.matches("loaded");
    return {
        loaded,
        setSrc (src) {
            send({
                type: "SRC.SET",
                src
            });
        },
        setLoaded () {
            send({
                type: "IMG.LOADED",
                src: "api"
            });
        },
        setError () {
            send({
                type: "IMG.ERROR",
                src: "api"
            });
        },
        getRootProps () {
            return normalize.element({
                ...parts.root.attrs,
                dir: state.context.dir,
                id: dom.getRootId(state.context)
            });
        },
        getImageProps () {
            return normalize.img({
                ...parts.image.attrs,
                hidden: !loaded,
                dir: state.context.dir,
                id: dom.getImageId(state.context),
                "data-state": loaded ? "visible" : "hidden",
                onLoad () {
                    send({
                        type: "IMG.LOADED",
                        src: "element"
                    });
                },
                onError () {
                    send({
                        type: "IMG.ERROR",
                        src: "element"
                    });
                }
            });
        },
        getFallbackProps () {
            return normalize.element({
                ...parts.fallback.attrs,
                dir: state.context.dir,
                id: dom.getFallbackId(state.context),
                hidden: loaded,
                "data-state": loaded ? "hidden" : "visible"
            });
        }
    };
}
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "avatar",
        initial: "loading",
        activities: [
            "trackImageRemoval"
        ],
        context: ctx,
        on: {
            "SRC.CHANGE": {
                target: "loading"
            },
            "IMG.UNMOUNT": {
                target: "error"
            }
        },
        states: {
            loading: {
                activities: [
                    "trackSrcChange"
                ],
                entry: [
                    "checkImageStatus"
                ],
                on: {
                    "IMG.LOADED": {
                        target: "loaded",
                        actions: [
                            "invokeOnLoad"
                        ]
                    },
                    "IMG.ERROR": {
                        target: "error",
                        actions: [
                            "invokeOnError"
                        ]
                    }
                }
            },
            error: {
                activities: [
                    "trackSrcChange"
                ],
                on: {
                    "IMG.LOADED": {
                        target: "loaded",
                        actions: [
                            "invokeOnLoad"
                        ]
                    }
                }
            },
            loaded: {
                activities: [
                    "trackSrcChange"
                ],
                on: {
                    "IMG.ERROR": {
                        target: "error",
                        actions: [
                            "invokeOnError"
                        ]
                    }
                }
            }
        }
    }, {
        activities: {
            trackSrcChange (ctx2, _evt, { send }) {
                const imageEl = dom.getImageEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["observeAttributes"])(imageEl, {
                    attributes: [
                        "src",
                        "srcset"
                    ],
                    callback () {
                        send({
                            type: "SRC.CHANGE"
                        });
                    }
                });
            },
            trackImageRemoval (ctx2, _evt, { send }) {
                const rootEl = dom.getRootEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["observeChildren"])(rootEl, {
                    callback (records) {
                        const removedNodes = Array.from(records[0].removedNodes);
                        const removed = removedNodes.find((node)=>node.nodeType === Node.ELEMENT_NODE && node.matches("[data-scope=avatar][data-part=image]"));
                        if (removed) {
                            send({
                                type: "IMG.UNMOUNT"
                            });
                        }
                    }
                });
            }
        },
        actions: {
            invokeOnLoad (ctx2) {
                ctx2.onStatusChange?.({
                    status: "loaded"
                });
            },
            invokeOnError (ctx2) {
                ctx2.onStatusChange?.({
                    status: "error"
                });
            },
            checkImageStatus (ctx2, _evt, { send }) {
                const imageEl = dom.getImageEl(ctx2);
                if (imageEl?.complete) {
                    const type = hasLoaded(imageEl) ? "IMG.LOADED" : "IMG.ERROR";
                    send({
                        type,
                        src: "ssr"
                    });
                }
            }
        }
    });
}
function hasLoaded(image) {
    return image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;
}
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "dir",
    "id",
    "ids",
    "onStatusChange",
    "getRootNode"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
;
}}),
"[project]/node_modules/@zag-js/avatar/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as avatarAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "avatarAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$avatar$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$avatar$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/avatar/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/collapsible/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/store/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
// src/collapsible.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("collapsible").parts("root", "trigger", "content");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `collapsible:${ctx.id}`,
    getContentId: (ctx)=>ctx.ids?.content ?? `collapsible:${ctx.id}:content`,
    getTriggerId: (ctx)=>ctx.ids?.trigger ?? `collapsible:${ctx.id}:trigger`,
    getRootEl: (ctx)=>dom.getById(ctx, dom.getRootId(ctx)),
    getContentEl: (ctx)=>dom.getById(ctx, dom.getContentId(ctx)),
    getTriggerEl: (ctx)=>dom.getById(ctx, dom.getTriggerId(ctx))
});
// src/collapsible.connect.ts
function connect(state, send, normalize) {
    const visible = state.matches("open", "closing");
    const open = state.matches("open");
    const height = state.context.height;
    const width = state.context.width;
    const disabled = !!state.context.disabled;
    const skip = !state.context.initial && open;
    return {
        disabled,
        visible,
        open,
        setOpen (nextOpen) {
            if (nextOpen === open) return;
            send(nextOpen ? "OPEN" : "CLOSE");
        },
        getRootProps () {
            return normalize.element({
                ...parts.root.attrs,
                "data-state": open ? "open" : "closed",
                dir: state.context.dir,
                id: dom.getRootId(state.context)
            });
        },
        getContentProps () {
            return normalize.element({
                ...parts.content.attrs,
                "data-state": skip ? void 0 : open ? "open" : "closed",
                id: dom.getContentId(state.context),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                hidden: !visible,
                style: {
                    "--height": height != null ? `${height}px` : void 0,
                    "--width": width != null ? `${width}px` : void 0
                }
            });
        },
        getTriggerProps () {
            return normalize.element({
                ...parts.trigger.attrs,
                id: dom.getTriggerId(state.context),
                dir: state.context.dir,
                type: "button",
                "data-state": open ? "open" : "closed",
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "aria-controls": dom.getContentId(state.context),
                "aria-expanded": visible || false,
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (disabled) return;
                    send({
                        type: open ? "CLOSE" : "OPEN",
                        src: "trigger.click"
                    });
                }
            });
        }
    };
}
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "collapsible",
        initial: ctx.open ? "open" : "closed",
        context: {
            ...ctx,
            height: 0,
            width: 0,
            initial: false,
            stylesRef: null,
            unmountAnimationName: null
        },
        watch: {
            open: [
                "setInitial",
                "computeSize",
                "toggleVisibility"
            ]
        },
        exit: [
            "clearInitial"
        ],
        states: {
            closed: {
                tags: [
                    "closed"
                ],
                on: {
                    "CONTROLLED.OPEN": "open",
                    OPEN: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setInitial",
                                "computeSize",
                                "invokeOnOpen"
                            ]
                        }
                    ]
                }
            },
            closing: {
                tags: [
                    "open"
                ],
                activities: [
                    "trackAnimationEvents"
                ],
                on: {
                    "CONTROLLED.CLOSE": "closed",
                    "CONTROLLED.OPEN": "open",
                    OPEN: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setInitial",
                                "invokeOnOpen"
                            ]
                        }
                    ],
                    CLOSE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnExitComplete"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "setInitial",
                                "computeSize",
                                "invokeOnExitComplete"
                            ]
                        }
                    ],
                    "ANIMATION.END": {
                        target: "closed",
                        actions: [
                            "invokeOnExitComplete"
                        ]
                    }
                }
            },
            open: {
                tags: [
                    "open"
                ],
                on: {
                    "CONTROLLED.CLOSE": "closing",
                    CLOSE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closing",
                            actions: [
                                "setInitial",
                                "computeSize",
                                "invokeOnClose"
                            ]
                        }
                    ]
                }
            }
        }
    }, {
        guards: {
            isOpenControlled: (ctx2)=>!!ctx2["open.controlled"]
        },
        activities: {
            trackAnimationEvents (ctx2, _evt, { send }) {
                let cleanup;
                const rafCleanup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const contentEl = dom.getContentEl(ctx2);
                    if (!contentEl) return;
                    const animationName = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getComputedStyle"])(contentEl).animationName;
                    const hasNoAnimation = !animationName || animationName === "none";
                    if (hasNoAnimation) {
                        send({
                            type: "ANIMATION.END"
                        });
                        return;
                    }
                    const onEnd = (event)=>{
                        const win = contentEl.ownerDocument.defaultView || window;
                        const animationName2 = win.getComputedStyle(contentEl).animationName;
                        const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
                        if (target === contentEl && animationName2 === ctx2.unmountAnimationName) {
                            send({
                                type: "ANIMATION.END"
                            });
                        }
                    };
                    contentEl.addEventListener("animationend", onEnd);
                    cleanup = ()=>{
                        contentEl.removeEventListener("animationend", onEnd);
                    };
                });
                return ()=>{
                    rafCleanup();
                    cleanup?.();
                };
            }
        },
        actions: {
            setInitial (ctx2) {
                ctx2.initial = true;
            },
            clearInitial (ctx2) {
                ctx2.initial = false;
            },
            computeSize (ctx2, evt) {
                ctx2._rafCleanup?.();
                ctx2._rafCleanup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const contentEl = dom.getContentEl(ctx2);
                    if (!contentEl) return;
                    ctx2.stylesRef || (ctx2.stylesRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])({
                        animationName: contentEl.style.animationName,
                        animationDuration: contentEl.style.animationDuration
                    }));
                    if (evt.type === "CLOSE" || !ctx2.open) {
                        const win = contentEl.ownerDocument.defaultView || window;
                        ctx2.unmountAnimationName = win.getComputedStyle(contentEl).animationName;
                    }
                    const hidden = contentEl.hidden;
                    contentEl.style.animationName = "none";
                    contentEl.style.animationDuration = "0s";
                    contentEl.hidden = false;
                    const rect = contentEl.getBoundingClientRect();
                    ctx2.height = rect.height;
                    ctx2.width = rect.width;
                    if (ctx2.initial) {
                        contentEl.style.animationName = ctx2.stylesRef.animationName;
                        contentEl.style.animationDuration = ctx2.stylesRef.animationDuration;
                    }
                    contentEl.hidden = hidden;
                });
            },
            invokeOnOpen: (ctx2)=>{
                ctx2.onOpenChange?.({
                    open: true
                });
            },
            invokeOnClose: (ctx2)=>{
                ctx2.onOpenChange?.({
                    open: false
                });
            },
            invokeOnExitComplete (ctx2) {
                ctx2.onExitComplete?.();
            },
            toggleVisibility: (ctx2, _evt, { send })=>{
                send({
                    type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE"
                });
            }
        }
    });
}
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "dir",
    "disabled",
    "getRootNode",
    "id",
    "ids",
    "onExitComplete",
    "onOpenChange",
    "open.controlled",
    "open"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
;
}}),
"[project]/node_modules/@zag-js/collapsible/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as collapsibleAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "collapsibleAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$collapsible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$collapsible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/collapsible/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/hover-card/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/popper/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dismissable/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
// src/hover-card.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getTriggerId: (ctx)=>ctx.ids?.trigger ?? `hover-card:${ctx.id}:trigger`,
    getContentId: (ctx)=>ctx.ids?.content ?? `hover-card:${ctx.id}:content`,
    getPositionerId: (ctx)=>ctx.ids?.positioner ?? `hover-card:${ctx.id}:popper`,
    getArrowId: (ctx)=>ctx.ids?.arrow ?? `hover-card:${ctx.id}:arrow`,
    getTriggerEl: (ctx)=>dom.getById(ctx, dom.getTriggerId(ctx)),
    getContentEl: (ctx)=>dom.getById(ctx, dom.getContentId(ctx)),
    getPositionerEl: (ctx)=>dom.getById(ctx, dom.getPositionerId(ctx))
});
// src/hover-card.connect.ts
function connect(state, send, normalize) {
    const open = state.hasTag("open");
    const popperStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacementStyles"])({
        ...state.context.positioning,
        placement: state.context.currentPlacement
    });
    return {
        open,
        setOpen (nextOpen) {
            if (nextOpen === open) return;
            send(nextOpen ? "OPEN" : "CLOSE");
        },
        reposition (options = {}) {
            send({
                type: "POSITIONING.SET",
                options
            });
        },
        getArrowProps () {
            return normalize.element({
                id: dom.getArrowId(state.context),
                ...parts.arrow.attrs,
                dir: state.context.dir,
                style: popperStyles.arrow
            });
        },
        getArrowTipProps () {
            return normalize.element({
                ...parts.arrowTip.attrs,
                dir: state.context.dir,
                style: popperStyles.arrowTip
            });
        },
        getTriggerProps () {
            return normalize.element({
                ...parts.trigger.attrs,
                dir: state.context.dir,
                "data-placement": state.context.currentPlacement,
                id: dom.getTriggerId(state.context),
                "data-state": open ? "open" : "closed",
                onPointerEnter (event) {
                    if (event.pointerType === "touch") return;
                    send({
                        type: "POINTER_ENTER",
                        src: "trigger"
                    });
                },
                onPointerLeave (event) {
                    if (event.pointerType === "touch") return;
                    send({
                        type: "POINTER_LEAVE",
                        src: "trigger"
                    });
                },
                onFocus () {
                    send("TRIGGER_FOCUS");
                },
                onBlur () {
                    send("TRIGGER_BLUR");
                }
            });
        },
        getPositionerProps () {
            return normalize.element({
                id: dom.getPositionerId(state.context),
                ...parts.positioner.attrs,
                dir: state.context.dir,
                style: popperStyles.floating
            });
        },
        getContentProps () {
            return normalize.element({
                ...parts.content.attrs,
                dir: state.context.dir,
                id: dom.getContentId(state.context),
                hidden: !open,
                "data-state": open ? "open" : "closed",
                "data-placement": state.context.currentPlacement,
                onPointerEnter (event) {
                    if (event.pointerType === "touch") return;
                    send({
                        type: "POINTER_ENTER",
                        src: "content"
                    });
                },
                onPointerLeave (event) {
                    if (event.pointerType === "touch") return;
                    send({
                        type: "POINTER_LEAVE",
                        src: "content"
                    });
                }
            });
        }
    };
}
var { not, and } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guards"];
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "hover-card",
        initial: ctx.open ? "open" : "closed",
        context: {
            openDelay: 700,
            closeDelay: 300,
            currentPlacement: void 0,
            ...ctx,
            positioning: {
                placement: "bottom",
                ...ctx.positioning
            }
        },
        watch: {
            open: [
                "toggleVisibility"
            ]
        },
        states: {
            closed: {
                tags: [
                    "closed"
                ],
                entry: [
                    "clearIsPointer"
                ],
                on: {
                    "CONTROLLED.OPEN": "open",
                    POINTER_ENTER: {
                        target: "opening",
                        actions: [
                            "setIsPointer"
                        ]
                    },
                    TRIGGER_FOCUS: "opening",
                    OPEN: "opening"
                }
            },
            opening: {
                tags: [
                    "closed"
                ],
                after: {
                    OPEN_DELAY: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen"
                            ]
                        }
                    ]
                },
                on: {
                    "CONTROLLED.OPEN": "open",
                    POINTER_LEAVE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    TRIGGER_BLUR: [
                        {
                            guard: and("isOpenControlled", not("isPointer")),
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            guard: not("isPointer"),
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    CLOSE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ]
                }
            },
            open: {
                tags: [
                    "open"
                ],
                activities: [
                    "trackDismissableElement",
                    "trackPositioning"
                ],
                on: {
                    "CONTROLLED.CLOSE": "closed",
                    POINTER_ENTER: {
                        actions: [
                            "setIsPointer"
                        ]
                    },
                    POINTER_LEAVE: "closing",
                    CLOSE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    TRIGGER_BLUR: [
                        {
                            guard: and("isOpenControlled", not("isPointer")),
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            guard: not("isPointer"),
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    "POSITIONING.SET": {
                        actions: "reposition"
                    }
                }
            },
            closing: {
                tags: [
                    "open"
                ],
                activities: [
                    "trackPositioning"
                ],
                after: {
                    CLOSE_DELAY: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ]
                },
                on: {
                    "CONTROLLED.CLOSE": "closed",
                    POINTER_ENTER: {
                        target: "open",
                        // no need to invokeOnOpen here because it's still open (but about to close)
                        actions: [
                            "setIsPointer"
                        ]
                    }
                }
            }
        }
    }, {
        guards: {
            isPointer: (ctx2)=>!!ctx2.isPointer,
            isOpenControlled: (ctx2)=>!!ctx2["open.controlled"]
        },
        activities: {
            trackPositioning (ctx2) {
                ctx2.currentPlacement = ctx2.positioning.placement;
                const getPositionerEl = ()=>dom.getPositionerEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(dom.getTriggerEl(ctx2), getPositionerEl, {
                    ...ctx2.positioning,
                    defer: true,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            trackDismissableElement (ctx2, _evt, { send }) {
                const getContentEl = ()=>dom.getContentEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackDismissableElement"])(getContentEl, {
                    defer: true,
                    exclude: [
                        dom.getTriggerEl(ctx2)
                    ],
                    onDismiss () {
                        send({
                            type: "CLOSE",
                            src: "interact-outside"
                        });
                    },
                    onFocusOutside (event) {
                        event.preventDefault();
                    }
                });
            }
        },
        actions: {
            invokeOnClose (ctx2) {
                ctx2.onOpenChange?.({
                    open: false
                });
            },
            invokeOnOpen (ctx2) {
                ctx2.onOpenChange?.({
                    open: true
                });
            },
            setIsPointer (ctx2) {
                ctx2.isPointer = true;
            },
            clearIsPointer (ctx2) {
                ctx2.isPointer = false;
            },
            reposition (ctx2, evt) {
                const getPositionerEl = ()=>dom.getPositionerEl(ctx2);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(dom.getTriggerEl(ctx2), getPositionerEl, {
                    ...ctx2.positioning,
                    ...evt.options,
                    defer: true,
                    listeners: false,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            toggleVisibility (ctx2, evt, { send }) {
                send({
                    type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
                    previousEvent: evt
                });
            }
        },
        delays: {
            OPEN_DELAY: (ctx2)=>ctx2.openDelay,
            CLOSE_DELAY: (ctx2)=>ctx2.closeDelay
        }
    });
}
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "closeDelay",
    "dir",
    "getRootNode",
    "id",
    "ids",
    "onOpenChange",
    "open.controlled",
    "open",
    "openDelay",
    "positioning"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
;
}}),
"[project]/node_modules/@zag-js/hover-card/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as hoverCardAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "hoverCardAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$hover$2d$card$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$hover$2d$card$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/hover-card/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/number-utils/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// src/number.ts
__turbopack_esm__({
    "clamp": (()=>clamp),
    "countDecimals": (()=>countDecimals),
    "decrement": (()=>decrement),
    "formatDecimal": (()=>formatDecimal),
    "increment": (()=>increment),
    "isAtMax": (()=>isAtMax),
    "isAtMin": (()=>isAtMin),
    "isWithinRange": (()=>isWithinRange),
    "nan": (()=>nan),
    "percentToValue": (()=>percentToValue),
    "round": (()=>round),
    "roundToDevicePixel": (()=>roundToDevicePixel),
    "snapToStep": (()=>snapToStep),
    "toRangeArray": (()=>toRangeArray),
    "toRanges": (()=>toRanges),
    "transform": (()=>transform),
    "valueToPercent": (()=>valueToPercent),
    "wrap": (()=>wrap)
});
function wrap(num, max) {
    return (num % max + max) % max;
}
function round(num, t) {
    const p = 10 ** (t ?? 10);
    num = Math.round(num * p) / p;
    return t ? num.toFixed(t) : num.toString();
}
function roundToDevicePixel(num) {
    if (typeof window.devicePixelRatio !== "number") return Math.round(num);
    const dp = window.devicePixelRatio;
    return Math.floor(num * dp + 0.5) / dp;
}
var valueToPercent = (v, r)=>(nan(v) - r.min) * 100 / (r.max - r.min);
var percentToValue = (v, r)=>r.min + (r.max - r.min) * nan(v);
function clamp(v, o) {
    return Math.min(Math.max(nan(v), o.min), o.max);
}
function countDecimals(value) {
    if (!Number.isFinite(value)) return 0;
    let e = 1, p = 0;
    while(Math.round(value * e) / e !== value){
        e *= 10;
        p += 1;
    }
    return p;
}
var increment = (v, s)=>decimalOperation(nan(v), "+", s);
var decrement = (v, s)=>decimalOperation(nan(v), "-", s);
function snapToStep(num, step) {
    const p = countDecimals(step);
    const v = Math.round(nan(num) / step) * step;
    return round(v, p);
}
function nan(v) {
    return Number.isNaN(v) ? 0 : v;
}
function formatDecimal(v, o) {
    return new Intl.NumberFormat("en-US", {
        useGrouping: false,
        style: "decimal",
        minimumFractionDigits: o.minFractionDigits,
        maximumFractionDigits: o.maxFractionDigits
    }).format(nan(v));
}
function isAtMax(val, o) {
    return nan(val) >= o.max;
}
function isAtMin(val, o) {
    return nan(val) <= o.min;
}
function isWithinRange(val, o) {
    return nan(val) >= o.min && nan(val) <= o.max;
}
function decimalOperation(a, op, b) {
    let result = op === "+" ? a + b : a - b;
    if (a % 1 !== 0 || b % 1 !== 0) {
        const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));
        a = Math.round(a * multiplier);
        b = Math.round(b * multiplier);
        result = op === "+" ? a + b : a - b;
        result /= multiplier;
    }
    return result;
}
// src/number-format.ts
var nf = new Intl.NumberFormat("en-US", {
    style: "decimal",
    maximumFractionDigits: 20
});
function formatter(n) {
    return parseFloat(nf.format(n));
}
// src/transform.ts
var transform = (a, b)=>{
    const i = {
        min: a[0],
        max: a[1]
    };
    const o = {
        min: b[0],
        max: b[1]
    };
    return (v)=>{
        if (i.min === i.max || o.min === o.max) return o.min;
        const ratio = (o.max - o.min) / (i.max - i.min);
        return o.min + ratio * (v - i.min);
    };
};
function toRanges(o) {
    const spacing = o.spacing ?? 0;
    return o.value.map((v, i)=>{
        const min = i === 0 ? o.min : o.value[i - 1] + spacing;
        const max = i === o.value.length - 1 ? o.max : o.value[i + 1] - spacing;
        return {
            min,
            max,
            value: v
        };
    });
}
function toRangeArray(o) {
    let i = o.min;
    const range = [];
    while(i <= o.max){
        range.push(i);
        i = formatter(i + o.step);
    }
    return range;
}
;
}}),
"[project]/node_modules/@internationalized/number/dist/NumberFormatter.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ __turbopack_esm__({
    "NumberFormatter": (()=>$488c6ddbf4ef74c2$export$cc77c4ff7e8673c5),
    "numberFormatSignDisplayPolyfill": (()=>$488c6ddbf4ef74c2$export$711b50b3c525e0f2)
});
let $488c6ddbf4ef74c2$var$formatterCache = new Map();
let $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
    // @ts-ignore
    $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat('de-DE', {
        signDisplay: 'exceptZero'
    }).resolvedOptions().signDisplay === 'exceptZero';
// eslint-disable-next-line no-empty
} catch (e) {}
let $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
    // @ts-ignore
    $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat('de-DE', {
        style: 'unit',
        unit: 'degree'
    }).resolvedOptions().style === 'unit';
// eslint-disable-next-line no-empty
} catch (e) {}
// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.
// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.
// Values were determined by switching to each locale manually in Chrome.
const $488c6ddbf4ef74c2$var$UNITS = {
    degree: {
        narrow: {
            default: "\xb0",
            'ja-JP': " \u5EA6",
            'zh-TW': "\u5EA6",
            'sl-SI': " \xb0"
        }
    }
};
class $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {
    /** Formats a number value as a string, according to the locale and options provided to the constructor. */ format(value) {
        let res = '';
        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
        else res = this.numberFormatter.format(value);
        if (this.options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {
            var _UNITS_unit;
            let { unit: unit, unitDisplay: unitDisplay = 'short', locale: locale } = this.resolvedOptions();
            if (!unit) return res;
            let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
            res += values[locale] || values.default;
        }
        return res;
    }
    /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */ formatToParts(value) {
        // TODO: implement signDisplay for formatToParts
        // @ts-ignore
        return this.numberFormatter.formatToParts(value);
    }
    /** Formats a number range as a string. */ formatRange(start, end) {
        // @ts-ignore
        if (typeof this.numberFormatter.formatRange === 'function') return this.numberFormatter.formatRange(start, end);
        if (end < start) throw new RangeError('End date must be >= start date');
        // Very basic fallback for old browsers.
        return `${this.format(start)} \u{2013} ${this.format(end)}`;
    }
    /** Formats a number range as an array of parts. */ formatRangeToParts(start, end) {
        // @ts-ignore
        if (typeof this.numberFormatter.formatRangeToParts === 'function') return this.numberFormatter.formatRangeToParts(start, end);
        if (end < start) throw new RangeError('End date must be >= start date');
        let startParts = this.numberFormatter.formatToParts(start);
        let endParts = this.numberFormatter.formatToParts(end);
        return [
            ...startParts.map((p)=>({
                    ...p,
                    source: 'startRange'
                })),
            {
                type: 'literal',
                value: " \u2013 ",
                source: 'shared'
            },
            ...endParts.map((p)=>({
                    ...p,
                    source: 'endRange'
                }))
        ];
    }
    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {
        let options = this.numberFormatter.resolvedOptions();
        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
            ...options,
            signDisplay: this.options.signDisplay
        };
        if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === 'unit') options = {
            ...options,
            style: 'unit',
            unit: this.options.unit,
            unitDisplay: this.options.unitDisplay
        };
        return options;
    }
    constructor(locale, options = {}){
        this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
        this.options = options;
    }
}
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
    let { numberingSystem: numberingSystem } = options;
    if (numberingSystem && locale.includes('-nu-')) {
        if (!locale.includes('-u-')) locale += '-u-';
        locale += `-nu-${numberingSystem}`;
    }
    if (options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {
        var _UNITS_unit;
        let { unit: unit, unitDisplay: unitDisplay = 'short' } = options;
        if (!unit) throw new Error('unit option must be provided with style: "unit"');
        if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
        options = {
            ...options,
            style: 'decimal'
        };
    }
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : '');
    if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
    let numberFormatter = new Intl.NumberFormat(locale, options);
    $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
    if (signDisplay === 'auto') return numberFormat.format(num);
    else if (signDisplay === 'never') return numberFormat.format(Math.abs(num));
    else {
        let needsPositiveSign = false;
        if (signDisplay === 'always') needsPositiveSign = num > 0 || Object.is(num, 0);
        else if (signDisplay === 'exceptZero') {
            if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
            else needsPositiveSign = num > 0;
        }
        if (needsPositiveSign) {
            let negative = numberFormat.format(-num);
            let noSign = numberFormat.format(num);
            // ignore RTL/LTR marker character
            let minus = negative.replace(noSign, '').replace(/\u200e|\u061C/, '');
            if ([
                ...minus
            ].length !== 1) console.warn('@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case');
            let positive = negative.replace(noSign, '!!!').replace(minus, '+').replace('!!!', noSign);
            return positive;
        } else return numberFormat.format(num);
    }
}
;
 //# sourceMappingURL=NumberFormatter.module.js.map
}}),
"[project]/node_modules/@internationalized/number/dist/NumberParser.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "NumberParser": (()=>$6c7bd7858deea686$export$cd11ab140839f11d)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$internationalized$2f$number$2f$dist$2f$NumberFormatter$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@internationalized/number/dist/NumberFormatter.mjs [app-rsc] (ecmascript)");
;
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp('^.*\\(.*\\).*$');
const $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
    'latn',
    'arab',
    'hanidec'
];
class $6c7bd7858deea686$export$cd11ab140839f11d {
    /**
   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
   */ parse(value) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
    }
    /**
   * Returns whether the given string could potentially be a valid number. This should be used to
   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
   * of the minus/plus sign characters can be checked.
   */ isValidPartialNumber(value, minValue, maxValue) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
    }
    /**
   * Returns a numbering system for which the given string is valid in the current locale.
   * If no numbering system could be detected, the default numbering system for the current
   * locale is returned.
   */ getNumberingSystem(value) {
        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
    }
    constructor(locale, options = {}){
        this.locale = locale;
        this.options = options;
    }
}
const $6c7bd7858deea686$var$numberParserCache = new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
    // First try the default numbering system for the provided locale
    let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
    // If that doesn't match, and the locale doesn't include a hard coded numbering system,
    // try each of the other supported numbering systems until we find one that matches.
    if (!locale.includes('-nu-') && !defaultParser.isValidPartialNumber(value)) {
        for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)if (numberingSystem !== defaultParser.options.numberingSystem) {
            let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes('-u-') ? '-nu-' : '-u-nu-') + numberingSystem, options);
            if (parser.isValidPartialNumber(value)) return parser;
        }
    }
    return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : '');
    let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
    if (!parser) {
        parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
        $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
    }
    return parser;
}
// The actual number parser implementation. Instances of this class are cached
// based on the locale, options, and detected numbering system.
class $6c7bd7858deea686$var$NumberParserImpl {
    parse(value) {
        // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'
        let fullySanitizedValue = this.sanitize(value);
        if (this.symbols.group) fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, '');
        if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, '.');
        if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, '-');
        fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
        if (this.options.style === 'percent') {
            // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing
            let isNegative = fullySanitizedValue.indexOf('-');
            fullySanitizedValue = fullySanitizedValue.replace('-', '');
            let index = fullySanitizedValue.indexOf('.');
            if (index === -1) index = fullySanitizedValue.length;
            fullySanitizedValue = fullySanitizedValue.replace('.', '');
            if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
            else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
            else if (index - 2 === -2) fullySanitizedValue = '0.00';
            else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
            if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
        }
        let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
        if (isNaN(newValue)) return NaN;
        if (this.options.style === 'percent') {
            var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
            // extra step for rounding percents to what our formatter would output
            let options = {
                ...this.options,
                style: 'decimal',
                minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
                maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
            };
            return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$internationalized$2f$number$2f$dist$2f$NumberFormatter$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NumberFormatter"])(this.locale, options).format(newValue));
        }
        // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again
        if (this.options.currencySign === 'accounting' && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
        return newValue;
    }
    sanitize(value) {
        // Remove literals and whitespace, which are allowed anywhere in the string
        value = value.replace(this.symbols.literals, '');
        // Replace the ASCII minus sign with the minus sign used in the current locale
        // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.
        if (this.symbols.minusSign) value = value.replace('-', this.symbols.minusSign);
        // In arab numeral system, their decimal character is 1643, but most keyboards don't type that
        // instead they use the , (44) character or apparently the (1548) character.
        if (this.options.numberingSystem === 'arab') {
            if (this.symbols.decimal) {
                value = value.replace(',', this.symbols.decimal);
                value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
            }
            if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, '.', this.symbols.group);
        }
        // fr-FR group character is char code 8239, but that's not a key on the french keyboard,
        // so allow 'period' as a group char and replace it with a space
        if (this.options.locale === 'fr-FR') value = $6c7bd7858deea686$var$replaceAll(value, '.', String.fromCharCode(8239));
        return value;
    }
    isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
        value = this.sanitize(value);
        // Remove minus or plus sign, which must be at the start of the string.
        if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
        else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);
        // Numbers cannot start with a group separator
        if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
        // Numbers that can't have any decimal values fail if a decimal character is typed
        if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
        // Remove numerals, groups, and decimals
        if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, '');
        value = value.replace(this.symbols.numeral, '');
        if (this.symbols.decimal) value = value.replace(this.symbols.decimal, '');
        // The number is valid if there are no remaining characters
        return value.length === 0;
    }
    constructor(locale, options = {}){
        this.locale = locale;
        this.formatter = new Intl.NumberFormat(locale, options);
        this.options = this.formatter.resolvedOptions();
        this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
        var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
        if (this.options.style === 'percent' && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn('NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.');
    }
}
const $6c7bd7858deea686$var$nonLiteralParts = new Set([
    'decimal',
    'fraction',
    'integer',
    'minusSign',
    'plusSign',
    'group'
]);
// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes
// all unique numbers which we need to check in order to determine all the plural forms for a given locale.
// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script
const $6c7bd7858deea686$var$pluralNumbers = [
    0,
    4,
    2,
    1,
    11,
    20,
    3,
    7,
    100,
    21,
    0.1,
    1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
    var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
    // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set
    let symbolFormatter = new Intl.NumberFormat(locale, {
        ...intlOptions,
        minimumSignificantDigits: 1,
        maximumSignificantDigits: 21
    });
    // Note: some locale's don't add a group symbol until there is a ten thousands place
    let allParts = symbolFormatter.formatToParts(-10000.111);
    let posAllParts = symbolFormatter.formatToParts(10000.111);
    let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n)=>symbolFormatter.formatToParts(n));
    var _allParts_find_value;
    let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p)=>p.type === 'minusSign')) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : '-';
    let plusSign = (_posAllParts_find = posAllParts.find((p)=>p.type === 'plusSign')) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
    // Safari does not support the signDisplay option, but our number parser polyfills it.
    // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.
    // @ts-ignore
    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'exceptZero' || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'always')) plusSign = '+';
    // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters
    // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal
    let decimalParts = new Intl.NumberFormat(locale, {
        ...intlOptions,
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).formatToParts(0.001);
    let decimal = (_decimalParts_find = decimalParts.find((p)=>p.type === 'decimal')) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
    let group = (_allParts_find1 = allParts.find((p)=>p.type === 'group')) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
    // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that
    // don't contribute to the numerical value
    let allPartsLiterals = allParts.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value));
    let pluralPartsLiterals = pluralParts.flatMap((p)=>p.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value)));
    let sortedLiterals = [
        ...new Set([
            ...allPartsLiterals,
            ...pluralPartsLiterals
        ])
    ].sort((a, b)=>b.length - a.length);
    let literals = sortedLiterals.length === 0 ? new RegExp('[\\p{White_Space}]', 'gu') : new RegExp(`${sortedLiterals.join('|')}|[\\p{White_Space}]`, 'gu');
    // These are for replacing non-latn characters with the latn equivalent
    let numerals = [
        ...new Intl.NumberFormat(intlOptions.locale, {
            useGrouping: false
        }).format(9876543210)
    ].reverse();
    let indexes = new Map(numerals.map((d, i)=>[
            d,
            i
        ]));
    let numeral = new RegExp(`[${numerals.join('')}]`, 'g');
    let index = (d)=>String(indexes.get(d));
    return {
        minusSign: minusSign,
        plusSign: plusSign,
        decimal: decimal,
        group: group,
        literals: literals,
        numeral: numeral,
        index: index
    };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace) {
    // @ts-ignore
    if (str.replaceAll) return str.replaceAll(find, replace);
    return str.split(find).join(replace);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
;
 //# sourceMappingURL=NumberParser.module.js.map
}}),
"[project]/node_modules/@zag-js/number-input/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/number-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/store/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$internationalized$2f$number$2f$dist$2f$NumberParser$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@internationalized/number/dist/NumberParser.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/form-utils/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
// src/number-input.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("numberInput").parts("root", "label", "input", "control", "valueText", "incrementTrigger", "decrementTrigger", "scrubber");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `number-input:${ctx.id}`,
    getInputId: (ctx)=>ctx.ids?.input ?? `number-input:${ctx.id}:input`,
    getIncrementTriggerId: (ctx)=>ctx.ids?.incrementTrigger ?? `number-input:${ctx.id}:inc`,
    getDecrementTriggerId: (ctx)=>ctx.ids?.decrementTrigger ?? `number-input:${ctx.id}:dec`,
    getScrubberId: (ctx)=>ctx.ids?.scrubber ?? `number-input:${ctx.id}:scrubber`,
    getCursorId: (ctx)=>`number-input:${ctx.id}:cursor`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `number-input:${ctx.id}:label`,
    getInputEl: (ctx)=>dom.getById(ctx, dom.getInputId(ctx)),
    getIncrementTriggerEl: (ctx)=>dom.getById(ctx, dom.getIncrementTriggerId(ctx)),
    getDecrementTriggerEl: (ctx)=>dom.getById(ctx, dom.getDecrementTriggerId(ctx)),
    getScrubberEl: (ctx)=>dom.getById(ctx, dom.getScrubberId(ctx)),
    getCursorEl: (ctx)=>dom.getDoc(ctx).getElementById(dom.getCursorId(ctx)),
    getPressedTriggerEl: (ctx, hint = ctx.hint)=>{
        let btnEl = null;
        if (hint === "increment") {
            btnEl = dom.getIncrementTriggerEl(ctx);
        }
        if (hint === "decrement") {
            btnEl = dom.getDecrementTriggerEl(ctx);
        }
        return btnEl;
    },
    setupVirtualCursor (ctx) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isSafari"])()) return;
        dom.createVirtualCursor(ctx);
        return ()=>{
            dom.getCursorEl(ctx)?.remove();
        };
    },
    preventTextSelection (ctx) {
        const doc = dom.getDoc(ctx);
        const html = doc.documentElement;
        const body = doc.body;
        body.style.pointerEvents = "none";
        html.style.userSelect = "none";
        html.style.cursor = "ew-resize";
        return ()=>{
            body.style.pointerEvents = "";
            html.style.userSelect = "";
            html.style.cursor = "";
            if (!html.style.length) {
                html.removeAttribute("style");
            }
            if (!body.style.length) {
                body.removeAttribute("style");
            }
        };
    },
    getMousementValue (ctx, event) {
        const x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["roundToDevicePixel"])(event.movementX);
        const y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["roundToDevicePixel"])(event.movementY);
        let hint = x > 0 ? "increment" : x < 0 ? "decrement" : null;
        if (ctx.isRtl && hint === "increment") hint = "decrement";
        if (ctx.isRtl && hint === "decrement") hint = "increment";
        const point = {
            x: ctx.scrubberCursorPoint.x + x,
            y: ctx.scrubberCursorPoint.y + y
        };
        const win = dom.getWin(ctx);
        const width = win.innerWidth;
        const half = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["roundToDevicePixel"])(7.5);
        point.x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["wrap"])(point.x + half, width) - half;
        return {
            hint,
            point
        };
    },
    createVirtualCursor (ctx) {
        const doc = dom.getDoc(ctx);
        const el = doc.createElement("div");
        el.className = "scrubber--cursor";
        el.id = dom.getCursorId(ctx);
        Object.assign(el.style, {
            width: "15px",
            height: "15px",
            position: "fixed",
            pointerEvents: "none",
            left: "0px",
            top: "0px",
            zIndex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MAX_Z_INDEX"],
            transform: ctx.scrubberCursorPoint ? `translate3d(${ctx.scrubberCursorPoint.x}px, ${ctx.scrubberCursorPoint.y}px, 0px)` : void 0,
            willChange: "transform"
        });
        el.innerHTML = `
        <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
          <g transform="translate(2 3)">
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
          </g>
        </svg>`;
        doc.body.appendChild(el);
    }
});
// src/number-input.connect.ts
function connect(state, send, normalize) {
    const focused = state.hasTag("focus");
    const disabled = state.context.isDisabled;
    const readOnly = state.context.readOnly;
    const empty = state.context.isValueEmpty;
    const invalid = state.context.isOutOfRange || !!state.context.invalid;
    const isIncrementDisabled = disabled || !state.context.canIncrement || readOnly;
    const isDecrementDisabled = disabled || !state.context.canDecrement || readOnly;
    const translations = state.context.translations;
    return {
        focused,
        invalid,
        empty,
        value: state.context.formattedValue,
        valueAsNumber: state.context.valueAsNumber,
        setValue (value) {
            send({
                type: "VALUE.SET",
                value
            });
        },
        clearValue () {
            send("VALUE.CLEAR");
        },
        increment () {
            send("VALUE.INCREMENT");
        },
        decrement () {
            send("VALUE.DECREMENT");
        },
        setToMax () {
            send({
                type: "VALUE.SET",
                value: state.context.max
            });
        },
        setToMin () {
            send({
                type: "VALUE.SET",
                value: state.context.min
            });
        },
        focus () {
            dom.getInputEl(state.context)?.focus();
        },
        getRootProps () {
            return normalize.element({
                id: dom.getRootId(state.context),
                ...parts.root.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid)
            });
        },
        getLabelProps () {
            return normalize.label({
                ...parts.label.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                id: dom.getLabelId(state.context),
                htmlFor: dom.getInputId(state.context)
            });
        },
        getControlProps () {
            return normalize.element({
                ...parts.control.attrs,
                dir: state.context.dir,
                role: "group",
                "aria-disabled": disabled,
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "aria-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaAttr"])(state.context.invalid)
            });
        },
        getValueTextProps () {
            return normalize.element({
                ...parts.valueText.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused)
            });
        },
        getInputProps () {
            return normalize.input({
                ...parts.input.attrs,
                dir: state.context.dir,
                name: state.context.name,
                form: state.context.form,
                id: dom.getInputId(state.context),
                role: "spinbutton",
                defaultValue: state.context.formattedValue,
                pattern: state.context.pattern,
                inputMode: state.context.inputMode,
                "aria-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaAttr"])(invalid),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                disabled,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                readOnly: state.context.readOnly,
                required: state.context.required,
                autoComplete: "off",
                autoCorrect: "off",
                spellCheck: "false",
                type: "text",
                "aria-roledescription": "numberfield",
                "aria-valuemin": state.context.min,
                "aria-valuemax": state.context.max,
                "aria-valuenow": Number.isNaN(state.context.valueAsNumber) ? void 0 : state.context.valueAsNumber,
                "aria-valuetext": state.context.valueText,
                onFocus () {
                    send("INPUT.FOCUS");
                },
                onBlur () {
                    send("INPUT.BLUR");
                },
                onChange (event) {
                    send({
                        type: "INPUT.CHANGE",
                        target: event.currentTarget,
                        hint: "set"
                    });
                },
                onBeforeInput (event) {
                    try {
                        const { selectionStart, selectionEnd, value } = event.currentTarget;
                        const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
                        const isValid = state.context.parser.isValidPartialNumber(nextValue);
                        if (!isValid) {
                            event.preventDefault();
                        }
                    } catch  {}
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (readOnly) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isComposingEvent"])(event)) return;
                    const step = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventStep"])(event) * state.context.step;
                    const keyMap = {
                        ArrowUp () {
                            send({
                                type: "INPUT.ARROW_UP",
                                step
                            });
                            event.preventDefault();
                        },
                        ArrowDown () {
                            send({
                                type: "INPUT.ARROW_DOWN",
                                step
                            });
                            event.preventDefault();
                        },
                        Home () {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isModifierKey"])(event)) return;
                            send("INPUT.HOME");
                            event.preventDefault();
                        },
                        End () {
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isModifierKey"])(event)) return;
                            send("INPUT.END");
                            event.preventDefault();
                        },
                        Enter () {
                            send("INPUT.ENTER");
                        }
                    };
                    const exec = keyMap[event.key];
                    exec?.(event);
                }
            });
        },
        getDecrementTriggerProps () {
            return normalize.button({
                ...parts.decrementTrigger.attrs,
                dir: state.context.dir,
                id: dom.getDecrementTriggerId(state.context),
                disabled: isDecrementDisabled,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(isDecrementDisabled),
                "aria-label": translations.decrementLabel,
                type: "button",
                tabIndex: -1,
                "aria-controls": dom.getInputId(state.context),
                onPointerDown (event) {
                    if (isDecrementDisabled || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLeftClick"])(event)) return;
                    send({
                        type: "TRIGGER.PRESS_DOWN",
                        hint: "decrement",
                        pointerType: event.pointerType
                    });
                    if (event.pointerType === "mouse") {
                        event.preventDefault();
                    }
                    if (event.pointerType === "touch") {
                        event.currentTarget?.focus({
                            preventScroll: true
                        });
                    }
                },
                onPointerUp (event) {
                    send({
                        type: "TRIGGER.PRESS_UP",
                        hint: "decrement",
                        pointerType: event.pointerType
                    });
                },
                onPointerLeave () {
                    if (isDecrementDisabled) return;
                    send({
                        type: "TRIGGER.PRESS_UP",
                        hint: "decrement"
                    });
                }
            });
        },
        getIncrementTriggerProps () {
            return normalize.button({
                ...parts.incrementTrigger.attrs,
                dir: state.context.dir,
                id: dom.getIncrementTriggerId(state.context),
                disabled: isIncrementDisabled,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(isIncrementDisabled),
                "aria-label": translations.incrementLabel,
                type: "button",
                tabIndex: -1,
                "aria-controls": dom.getInputId(state.context),
                onPointerDown (event) {
                    if (isIncrementDisabled || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLeftClick"])(event)) return;
                    send({
                        type: "TRIGGER.PRESS_DOWN",
                        hint: "increment",
                        pointerType: event.pointerType
                    });
                    if (event.pointerType === "mouse") {
                        event.preventDefault();
                    }
                    if (event.pointerType === "touch") {
                        event.currentTarget?.focus({
                            preventScroll: true
                        });
                    }
                },
                onPointerUp (event) {
                    send({
                        type: "TRIGGER.PRESS_UP",
                        hint: "increment",
                        pointerType: event.pointerType
                    });
                },
                onPointerLeave (event) {
                    send({
                        type: "TRIGGER.PRESS_UP",
                        hint: "increment",
                        pointerType: event.pointerType
                    });
                }
            });
        },
        getScrubberProps () {
            return normalize.element({
                ...parts.scrubber.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                id: dom.getScrubberId(state.context),
                role: "presentation",
                onMouseDown (event) {
                    if (disabled) return;
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    point.x = point.x - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["roundToDevicePixel"])(7.5);
                    point.y = point.y - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["roundToDevicePixel"])(7.5);
                    send({
                        type: "SCRUBBER.PRESS_DOWN",
                        point
                    });
                    event.preventDefault();
                },
                style: {
                    cursor: disabled ? void 0 : "ew-resize"
                }
            });
        }
    };
}
// src/cursor.ts
function recordCursor(inputEl) {
    if (inputEl.ownerDocument.activeElement !== inputEl) return;
    try {
        const { selectionStart: start, selectionEnd: end, value } = inputEl;
        const beforeTxt = value.substring(0, start);
        const afterTxt = value.substring(end);
        return {
            start,
            end,
            value,
            beforeTxt,
            afterTxt
        };
    } catch  {}
}
function restoreCursor(inputEl, selection) {
    if (inputEl.ownerDocument.activeElement !== inputEl) return;
    if (!selection) {
        inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
        return;
    }
    try {
        const { value } = inputEl;
        const { beforeTxt = "", afterTxt = "", start } = selection;
        let startPos = value.length;
        if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
        } else if (start != null) {
            const beforeLastChar = beforeTxt[start - 1];
            const newIndex = value.indexOf(beforeLastChar, start - 1);
            if (newIndex !== -1) {
                startPos = newIndex + 1;
            }
        }
        inputEl.setSelectionRange(startPos, startPos);
    } catch  {}
}
var createFormatter = (locale, options = {})=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(new Intl.NumberFormat(locale, options));
};
var createParser = (locale, options = {})=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ref"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$internationalized$2f$number$2f$dist$2f$NumberParser$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NumberParser"](locale, options));
};
var parseValue = (ctx, value)=>{
    if (!ctx.formatOptions) return parseFloat(value);
    return ctx.parser.parse(String(value));
};
var formatValue = (ctx, value)=>{
    if (Number.isNaN(value)) return "";
    if (!ctx.formatOptions) return value.toString();
    return ctx.formatter.format(value);
};
// src/number-input.machine.ts
var { not, and } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guards"];
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "number-input",
        initial: "idle",
        context: {
            dir: "ltr",
            locale: "en-US",
            focusInputOnChange: true,
            clampValueOnBlur: true,
            allowOverflow: false,
            inputMode: "decimal",
            pattern: "[0-9]*(.[0-9]+)?",
            value: "",
            step: 1,
            min: Number.MIN_SAFE_INTEGER,
            max: Number.MAX_SAFE_INTEGER,
            invalid: false,
            spinOnPress: true,
            disabled: false,
            readOnly: false,
            ...ctx,
            hint: null,
            scrubberCursorPoint: null,
            fieldsetDisabled: false,
            formatter: createFormatter(ctx.locale || "en-US", ctx.formatOptions),
            parser: createParser(ctx.locale || "en-US", ctx.formatOptions),
            translations: {
                incrementLabel: "increment value",
                decrementLabel: "decrease value",
                ...ctx.translations
            }
        },
        computed: {
            isRtl: (ctx2)=>ctx2.dir === "rtl",
            valueAsNumber: (ctx2)=>parseValue(ctx2, ctx2.value),
            formattedValue: (ctx2)=>formatValue(ctx2, ctx2.valueAsNumber),
            isAtMin: (ctx2)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isAtMin"])(ctx2.valueAsNumber, ctx2),
            isAtMax: (ctx2)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isAtMax"])(ctx2.valueAsNumber, ctx2),
            isOutOfRange: (ctx2)=>!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isWithinRange"])(ctx2.valueAsNumber, ctx2),
            isValueEmpty: (ctx2)=>ctx2.value === "",
            isDisabled: (ctx2)=>!!ctx2.disabled || ctx2.fieldsetDisabled,
            canIncrement: (ctx2)=>ctx2.allowOverflow || !ctx2.isAtMax,
            canDecrement: (ctx2)=>ctx2.allowOverflow || !ctx2.isAtMin,
            valueText: (ctx2)=>ctx2.translations.valueText?.(ctx2.value)
        },
        watch: {
            formatOptions: [
                "setFormatterAndParser",
                "syncInputElement"
            ],
            locale: [
                "setFormatterAndParser",
                "syncInputElement"
            ],
            value: [
                "syncInputElement"
            ],
            isOutOfRange: [
                "invokeOnInvalid"
            ],
            scrubberCursorPoint: [
                "setVirtualCursorPosition"
            ]
        },
        activities: [
            "trackFormControl"
        ],
        on: {
            "VALUE.SET": {
                actions: [
                    "setRawValue",
                    "setHintToSet"
                ]
            },
            "VALUE.CLEAR": {
                actions: [
                    "clearValue"
                ]
            },
            "VALUE.INCREMENT": {
                actions: [
                    "increment"
                ]
            },
            "VALUE.DECREMENT": {
                actions: [
                    "decrement"
                ]
            }
        },
        states: {
            idle: {
                on: {
                    "TRIGGER.PRESS_DOWN": [
                        {
                            guard: "isTouchPointer",
                            target: "before:spin",
                            actions: [
                                "setHint"
                            ]
                        },
                        {
                            target: "before:spin",
                            actions: [
                                "focusInput",
                                "invokeOnFocus",
                                "setHint"
                            ]
                        }
                    ],
                    "SCRUBBER.PRESS_DOWN": {
                        target: "scrubbing",
                        actions: [
                            "focusInput",
                            "invokeOnFocus",
                            "setHint",
                            "setCursorPoint"
                        ]
                    },
                    "INPUT.FOCUS": {
                        target: "focused",
                        actions: [
                            "focusInput",
                            "invokeOnFocus"
                        ]
                    }
                }
            },
            focused: {
                tags: "focus",
                activities: "attachWheelListener",
                on: {
                    "TRIGGER.PRESS_DOWN": [
                        {
                            guard: "isTouchPointer",
                            target: "before:spin",
                            actions: [
                                "setHint"
                            ]
                        },
                        {
                            target: "before:spin",
                            actions: [
                                "focusInput",
                                "setHint"
                            ]
                        }
                    ],
                    "SCRUBBER.PRESS_DOWN": {
                        target: "scrubbing",
                        actions: [
                            "focusInput",
                            "setHint",
                            "setCursorPoint"
                        ]
                    },
                    "INPUT.ARROW_UP": {
                        actions: "increment"
                    },
                    "INPUT.ARROW_DOWN": {
                        actions: "decrement"
                    },
                    "INPUT.HOME": {
                        actions: "decrementToMin"
                    },
                    "INPUT.END": {
                        actions: "incrementToMax"
                    },
                    "INPUT.CHANGE": {
                        actions: [
                            "setValue",
                            "setHint"
                        ]
                    },
                    "INPUT.BLUR": [
                        {
                            guard: and("clampValueOnBlur", not("isInRange")),
                            target: "idle",
                            actions: [
                                "setClampedValue",
                                "clearHint",
                                "invokeOnBlur"
                            ]
                        },
                        {
                            target: "idle",
                            actions: [
                                "setFormattedValue",
                                "clearHint",
                                "invokeOnBlur"
                            ]
                        }
                    ],
                    "INPUT.ENTER": {
                        actions: [
                            "setFormattedValue",
                            "clearHint",
                            "invokeOnBlur"
                        ]
                    }
                }
            },
            "before:spin": {
                tags: "focus",
                activities: "trackButtonDisabled",
                entry: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["choose"])([
                    {
                        guard: "isIncrementHint",
                        actions: "increment"
                    },
                    {
                        guard: "isDecrementHint",
                        actions: "decrement"
                    }
                ]),
                after: {
                    CHANGE_DELAY: {
                        target: "spinning",
                        guard: and("isInRange", "spinOnPress")
                    }
                },
                on: {
                    "TRIGGER.PRESS_UP": [
                        {
                            guard: "isTouchPointer",
                            target: "focused",
                            actions: "clearHint"
                        },
                        {
                            target: "focused",
                            actions: [
                                "focusInput",
                                "clearHint"
                            ]
                        }
                    ]
                }
            },
            spinning: {
                tags: "focus",
                activities: "trackButtonDisabled",
                every: [
                    {
                        delay: "CHANGE_INTERVAL",
                        guard: and(not("isAtMin"), "isIncrementHint"),
                        actions: "increment"
                    },
                    {
                        delay: "CHANGE_INTERVAL",
                        guard: and(not("isAtMax"), "isDecrementHint"),
                        actions: "decrement"
                    }
                ],
                on: {
                    "TRIGGER.PRESS_UP": {
                        target: "focused",
                        actions: [
                            "focusInput",
                            "clearHint"
                        ]
                    }
                }
            },
            scrubbing: {
                tags: "focus",
                activities: [
                    "activatePointerLock",
                    "trackMousemove",
                    "setupVirtualCursor",
                    "preventTextSelection"
                ],
                on: {
                    "SCRUBBER.POINTER_UP": {
                        target: "focused",
                        actions: [
                            "focusInput",
                            "clearCursorPoint"
                        ]
                    },
                    "SCRUBBER.POINTER_MOVE": [
                        {
                            guard: "isIncrementHint",
                            actions: [
                                "increment",
                                "setCursorPoint"
                            ]
                        },
                        {
                            guard: "isDecrementHint",
                            actions: [
                                "decrement",
                                "setCursorPoint"
                            ]
                        }
                    ]
                }
            }
        }
    }, {
        delays: {
            CHANGE_INTERVAL: 50,
            CHANGE_DELAY: 300
        },
        guards: {
            clampValueOnBlur: (ctx2)=>ctx2.clampValueOnBlur,
            isAtMin: (ctx2)=>ctx2.isAtMin,
            spinOnPress: (ctx2)=>!!ctx2.spinOnPress,
            isAtMax: (ctx2)=>ctx2.isAtMax,
            isInRange: (ctx2)=>!ctx2.isOutOfRange,
            isDecrementHint: (ctx2, evt)=>(evt.hint ?? ctx2.hint) === "decrement",
            isIncrementHint: (ctx2, evt)=>(evt.hint ?? ctx2.hint) === "increment",
            isTouchPointer: (_ctx, evt)=>evt.pointerType === "touch"
        },
        activities: {
            trackFormControl (ctx2, _evt, { initialContext }) {
                const inputEl = dom.getInputEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackFormControl"])(inputEl, {
                    onFieldsetDisabledChange (disabled) {
                        ctx2.fieldsetDisabled = disabled;
                    },
                    onFormReset () {
                        set.value(ctx2, initialContext.value);
                    }
                });
            },
            setupVirtualCursor (ctx2) {
                return dom.setupVirtualCursor(ctx2);
            },
            preventTextSelection (ctx2) {
                return dom.preventTextSelection(ctx2);
            },
            trackButtonDisabled (ctx2, _evt, { send }) {
                const btn = dom.getPressedTriggerEl(ctx2, ctx2.hint);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["observeAttributes"])(btn, {
                    attributes: [
                        "disabled"
                    ],
                    callback () {
                        send({
                            type: "TRIGGER.PRESS_UP",
                            src: "attr"
                        });
                    }
                });
            },
            attachWheelListener (ctx2, _evt, { send }) {
                const inputEl = dom.getInputEl(ctx2);
                if (!inputEl || !dom.isActiveElement(ctx2, inputEl) || !ctx2.allowMouseWheel) return;
                function onWheel(event) {
                    event.preventDefault();
                    const dir = Math.sign(event.deltaY) * -1;
                    if (dir === 1) {
                        send("VALUE.INCREMENT");
                    } else if (dir === -1) {
                        send("VALUE.DECREMENT");
                    }
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])(inputEl, "wheel", onWheel, {
                    passive: false
                });
            },
            activatePointerLock (ctx2) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isSafari"])()) return;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["requestPointerLock"])(dom.getDoc(ctx2));
            },
            trackMousemove (ctx2, _evt, { send }) {
                const doc = dom.getDoc(ctx2);
                function onMousemove(event) {
                    if (!ctx2.scrubberCursorPoint) return;
                    const value = dom.getMousementValue(ctx2, event);
                    if (!value.hint) return;
                    send({
                        type: "SCRUBBER.POINTER_MOVE",
                        hint: value.hint,
                        point: value.point
                    });
                }
                function onMouseup() {
                    send("SCRUBBER.POINTER_UP");
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["callAll"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])(doc, "mousemove", onMousemove, false), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])(doc, "mouseup", onMouseup, false));
            }
        },
        actions: {
            focusInput (ctx2) {
                if (!ctx2.focusInputOnChange) return;
                const inputEl = dom.getInputEl(ctx2);
                if (dom.isActiveElement(ctx2, inputEl)) return;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>inputEl?.focus({
                        preventScroll: true
                    }));
            },
            increment (ctx2, evt) {
                const nextValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["increment"])(ctx2.valueAsNumber, evt.step ?? ctx2.step);
                const value = formatValue(ctx2, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clamp"])(nextValue, ctx2));
                set.value(ctx2, value);
            },
            decrement (ctx2, evt) {
                const nextValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["decrement"])(ctx2.valueAsNumber, evt.step ?? ctx2.step);
                const value = formatValue(ctx2, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clamp"])(nextValue, ctx2));
                set.value(ctx2, value);
            },
            setClampedValue (ctx2) {
                const nextValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clamp"])(ctx2.valueAsNumber, ctx2);
                set.value(ctx2, formatValue(ctx2, nextValue));
            },
            setRawValue (ctx2, evt) {
                const parsedValue = parseValue(ctx2, evt.value);
                const value = formatValue(ctx2, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clamp"])(parsedValue, ctx2));
                set.value(ctx2, value);
            },
            setValue (ctx2, evt) {
                const value = evt.target?.value ?? evt.value;
                set.value(ctx2, value);
            },
            clearValue (ctx2) {
                set.value(ctx2, "");
            },
            incrementToMax (ctx2) {
                const value = formatValue(ctx2, ctx2.max);
                set.value(ctx2, value);
            },
            decrementToMin (ctx2) {
                const value = formatValue(ctx2, ctx2.min);
                set.value(ctx2, value);
            },
            setHint (ctx2, evt) {
                ctx2.hint = evt.hint;
            },
            clearHint (ctx2) {
                ctx2.hint = null;
            },
            setHintToSet (ctx2) {
                ctx2.hint = "set";
            },
            invokeOnFocus (ctx2) {
                ctx2.onFocusChange?.({
                    focused: true,
                    value: ctx2.formattedValue,
                    valueAsNumber: ctx2.valueAsNumber
                });
            },
            invokeOnBlur (ctx2) {
                ctx2.onFocusChange?.({
                    focused: false,
                    value: ctx2.formattedValue,
                    valueAsNumber: ctx2.valueAsNumber
                });
            },
            invokeOnInvalid (ctx2) {
                if (!ctx2.isOutOfRange) return;
                const reason = ctx2.valueAsNumber > ctx2.max ? "rangeOverflow" : "rangeUnderflow";
                ctx2.onValueInvalid?.({
                    reason,
                    value: ctx2.formattedValue,
                    valueAsNumber: ctx2.valueAsNumber
                });
            },
            syncInputElement (ctx2, evt) {
                const value = evt.type.endsWith("CHANGE") ? ctx2.value : ctx2.formattedValue;
                sync.input(ctx2, value);
            },
            setFormattedValue (ctx2) {
                set.value(ctx2, ctx2.formattedValue);
            },
            setCursorPoint (ctx2, evt) {
                ctx2.scrubberCursorPoint = evt.point;
            },
            clearCursorPoint (ctx2) {
                ctx2.scrubberCursorPoint = null;
            },
            setVirtualCursorPosition (ctx2) {
                const cursorEl = dom.getCursorEl(ctx2);
                if (!cursorEl || !ctx2.scrubberCursorPoint) return;
                const { x, y } = ctx2.scrubberCursorPoint;
                cursorEl.style.transform = `translate3d(${x}px, ${y}px, 0px)`;
            },
            setFormatterAndParser (ctx2) {
                if (!ctx2.locale) return;
                ctx2.formatter = createFormatter(ctx2.locale, ctx2.formatOptions);
                ctx2.parser = createParser(ctx2.locale, ctx2.formatOptions);
            }
        },
        compareFns: {
            formatOptions: (a, b)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(a, b),
            scrubberCursorPoint: (a, b)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(a, b)
        }
    });
}
var sync = {
    input (ctx, value) {
        const inputEl = dom.getInputEl(ctx);
        if (!inputEl) return;
        const sel = recordCursor(inputEl);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
            dom.setValue(inputEl, value);
            restoreCursor(inputEl, sel);
        });
    }
};
var invoke = {
    onChange: (ctx)=>{
        ctx.onValueChange?.({
            value: ctx.value,
            valueAsNumber: ctx.valueAsNumber
        });
    }
};
var set = {
    value: (ctx, value)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value, value)) return;
        ctx.value = value;
        invoke.onChange(ctx);
    }
};
;
}}),
"[project]/node_modules/@zag-js/number-input/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as numberInputAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "numberInputAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$input$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$number$2d$input$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/number-input/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/pin-input/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/form-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
;
;
;
;
;
;
// src/pin-input.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("pinInput").parts("root", "label", "input", "control");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `pin-input:${ctx.id}`,
    getInputId: (ctx, id)=>ctx.ids?.input?.(id) ?? `pin-input:${ctx.id}:${id}`,
    getHiddenInputId: (ctx)=>ctx.ids?.hiddenInput ?? `pin-input:${ctx.id}:hidden`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `pin-input:${ctx.id}:label`,
    getControlId: (ctx)=>ctx.ids?.control ?? `pin-input:${ctx.id}:control`,
    getRootEl: (ctx)=>dom.getById(ctx, dom.getRootId(ctx)),
    getInputEls: (ctx)=>{
        const ownerId = CSS.escape(dom.getRootId(ctx));
        const selector = `input[data-ownedby=${ownerId}]`;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["queryAll"])(dom.getRootEl(ctx), selector);
    },
    getInputEl: (ctx, id)=>dom.getById(ctx, dom.getInputId(ctx, id)),
    getFocusedInputEl: (ctx)=>dom.getInputEls(ctx)[ctx.focusedIndex],
    getFirstInputEl: (ctx)=>dom.getInputEls(ctx)[0],
    getHiddenInputEl: (ctx)=>dom.getById(ctx, dom.getHiddenInputId(ctx))
});
// src/pin-input.utils.ts
var REGEX = {
    numeric: /^[0-9]+$/,
    alphabetic: /^[A-Za-z]+$/,
    alphanumeric: /^[a-zA-Z0-9]+$/i
};
function isValidType(ctx, value) {
    if (!ctx.type) return true;
    return !!REGEX[ctx.type]?.test(value);
}
function isValidValue(ctx, value) {
    if (!ctx.pattern) return isValidType(ctx, value);
    const regex = new RegExp(ctx.pattern, "g");
    return regex.test(value);
}
// src/pin-input.connect.ts
function connect(state, send, normalize) {
    const complete = state.context.isValueComplete;
    const invalid = state.context.invalid;
    const focusedIndex = state.context.focusedIndex;
    const translations = state.context.translations;
    function focus() {
        dom.getFirstInputEl(state.context)?.focus();
    }
    return {
        focus,
        value: state.context.value,
        valueAsString: state.context.valueAsString,
        complete,
        setValue (value) {
            if (!Array.isArray(value)) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["invariant"])("[pin-input/setValue] value must be an array");
            }
            send({
                type: "VALUE.SET",
                value
            });
        },
        clearValue () {
            send({
                type: "VALUE.CLEAR"
            });
        },
        setValueAtIndex (index, value) {
            send({
                type: "VALUE.SET",
                value,
                index
            });
        },
        getRootProps () {
            return normalize.element({
                dir: state.context.dir,
                ...parts.root.attrs,
                id: dom.getRootId(state.context),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.disabled),
                "data-complete": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(complete),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.readOnly)
            });
        },
        getLabelProps () {
            return normalize.label({
                ...parts.label.attrs,
                dir: state.context.dir,
                htmlFor: dom.getHiddenInputId(state.context),
                id: dom.getLabelId(state.context),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.disabled),
                "data-complete": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(complete),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.readOnly),
                onClick (event) {
                    event.preventDefault();
                    focus();
                }
            });
        },
        getHiddenInputProps () {
            return normalize.input({
                "aria-hidden": true,
                type: "text",
                tabIndex: -1,
                id: dom.getHiddenInputId(state.context),
                readOnly: state.context.readOnly,
                disabled: state.context.disabled,
                required: state.context.required,
                name: state.context.name,
                form: state.context.form,
                style: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["visuallyHiddenStyle"],
                maxLength: state.context.valueLength,
                defaultValue: state.context.valueAsString
            });
        },
        getControlProps () {
            return normalize.element({
                ...parts.control.attrs,
                dir: state.context.dir,
                id: dom.getControlId(state.context)
            });
        },
        getInputProps (props) {
            const { index } = props;
            const inputType = state.context.type === "numeric" ? "tel" : "text";
            return normalize.input({
                ...parts.input.attrs,
                dir: state.context.dir,
                disabled: state.context.disabled,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.disabled),
                "data-complete": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(complete),
                id: dom.getInputId(state.context, index.toString()),
                "data-ownedby": dom.getRootId(state.context),
                "aria-label": translations.inputLabel(index, state.context.valueLength),
                inputMode: state.context.otp || state.context.type === "numeric" ? "numeric" : "text",
                "aria-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ariaAttr"])(invalid),
                "data-invalid": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(invalid),
                type: state.context.mask ? "password" : inputType,
                defaultValue: state.context.value[index] || "",
                readOnly: state.context.readOnly,
                autoCapitalize: "none",
                autoComplete: state.context.otp ? "one-time-code" : "off",
                placeholder: focusedIndex === index ? "" : state.context.placeholder,
                onBeforeInput (event) {
                    try {
                        const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getBeforeInputValue"])(event);
                        const isValid = isValidValue(state.context, value);
                        if (!isValid) {
                            send({
                                type: "VALUE.INVALID",
                                value
                            });
                            event.preventDefault();
                        }
                        if (value.length > 2) {
                            event.currentTarget.setSelectionRange(0, 1, "forward");
                        }
                    } catch  {}
                },
                onChange (event) {
                    const evt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNativeEvent"])(event);
                    const { value } = event.currentTarget;
                    if (evt.inputType === "insertFromPaste" || value.length > 2) {
                        send({
                            type: "INPUT.PASTE",
                            value
                        });
                        event.currentTarget.value = value[0];
                        event.preventDefault();
                        return;
                    }
                    if (evt.inputType === "deleteContentBackward") {
                        send("INPUT.BACKSPACE");
                        return;
                    }
                    send({
                        type: "INPUT.CHANGE",
                        value,
                        index
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isComposingEvent"])(event)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isModifierKey"])(event)) return;
                    const keyMap = {
                        Backspace () {
                            send("INPUT.BACKSPACE");
                        },
                        Delete () {
                            send("INPUT.DELETE");
                        },
                        ArrowLeft () {
                            send("INPUT.ARROW_LEFT");
                        },
                        ArrowRight () {
                            send("INPUT.ARROW_RIGHT");
                        },
                        Enter () {
                            send("INPUT.ENTER");
                        }
                    };
                    const exec = keyMap[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventKey"])(event, state.context)];
                    if (exec) {
                        exec(event);
                        event.preventDefault();
                    }
                },
                onFocus () {
                    send({
                        type: "INPUT.FOCUS",
                        index
                    });
                },
                onBlur () {
                    send({
                        type: "INPUT.BLUR",
                        index
                    });
                }
            });
        }
    };
}
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "pin-input",
        initial: "idle",
        context: {
            value: [],
            placeholder: "\u25CB",
            otp: false,
            type: "numeric",
            ...ctx,
            focusedIndex: -1,
            translations: {
                inputLabel: (index, length)=>`pin code ${index + 1} of ${length}`,
                ...ctx.translations
            }
        },
        computed: {
            valueLength: (ctx2)=>ctx2.value.length,
            filledValueLength: (ctx2)=>ctx2.value.filter((v)=>v?.trim() !== "").length,
            isValueComplete: (ctx2)=>ctx2.valueLength === ctx2.filledValueLength,
            valueAsString: (ctx2)=>ctx2.value.join(""),
            focusedValue: (ctx2)=>ctx2.value[ctx2.focusedIndex] || ""
        },
        entry: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["choose"])([
            {
                guard: "autoFocus",
                actions: [
                    "setupValue",
                    "setFocusIndexToFirst"
                ]
            },
            {
                actions: [
                    "setupValue"
                ]
            }
        ]),
        watch: {
            focusedIndex: [
                "focusInput",
                "selectInputIfNeeded"
            ],
            value: [
                "syncInputElements"
            ],
            isValueComplete: [
                "invokeOnComplete",
                "blurFocusedInputIfNeeded"
            ]
        },
        on: {
            "VALUE.SET": [
                {
                    guard: "hasIndex",
                    actions: [
                        "setValueAtIndex"
                    ]
                },
                {
                    actions: [
                        "setValue"
                    ]
                }
            ],
            "VALUE.CLEAR": {
                actions: [
                    "clearValue",
                    "setFocusIndexToFirst"
                ]
            }
        },
        states: {
            idle: {
                on: {
                    "INPUT.FOCUS": {
                        target: "focused",
                        actions: "setFocusedIndex"
                    }
                }
            },
            focused: {
                on: {
                    "INPUT.CHANGE": [
                        {
                            guard: "isFinalValue",
                            actions: [
                                "setFocusedValue",
                                "syncInputValue"
                            ]
                        },
                        {
                            actions: [
                                "setFocusedValue",
                                "setNextFocusedIndex",
                                "syncInputValue"
                            ]
                        }
                    ],
                    "INPUT.PASTE": {
                        actions: [
                            "setPastedValue",
                            "setLastValueFocusIndex"
                        ]
                    },
                    "INPUT.BLUR": {
                        target: "idle",
                        actions: "clearFocusedIndex"
                    },
                    "INPUT.DELETE": {
                        guard: "hasValue",
                        actions: "clearFocusedValue"
                    },
                    "INPUT.ARROW_LEFT": {
                        actions: "setPrevFocusedIndex"
                    },
                    "INPUT.ARROW_RIGHT": {
                        actions: "setNextFocusedIndex"
                    },
                    "INPUT.BACKSPACE": [
                        {
                            guard: "hasValue",
                            actions: [
                                "clearFocusedValue"
                            ]
                        },
                        {
                            actions: [
                                "setPrevFocusedIndex",
                                "clearFocusedValue"
                            ]
                        }
                    ],
                    "INPUT.ENTER": {
                        guard: "isValueComplete",
                        actions: "requestFormSubmit"
                    },
                    "VALUE.INVALID": {
                        actions: "invokeOnInvalid"
                    }
                }
            }
        }
    }, {
        guards: {
            autoFocus: (ctx2)=>!!ctx2.autoFocus,
            isValueEmpty: (_ctx, evt)=>evt.value === "",
            hasValue: (ctx2)=>ctx2.value[ctx2.focusedIndex] !== "",
            isValueComplete: (ctx2)=>ctx2.isValueComplete,
            isFinalValue: (ctx2)=>ctx2.filledValueLength + 1 === ctx2.valueLength && ctx2.value.findIndex((v)=>v.trim() === "") === ctx2.focusedIndex,
            hasIndex: (_ctx, evt)=>evt.index !== void 0,
            isDisabled: (ctx2)=>!!ctx2.disabled
        },
        actions: {
            setupValue (ctx2) {
                if (ctx2.value.length) return;
                const inputEls = dom.getInputEls(ctx2);
                const emptyValues = Array.from({
                    length: inputEls.length
                }).fill("");
                assignValue(ctx2, emptyValues);
            },
            focusInput (ctx2) {
                if (ctx2.focusedIndex === -1) return;
                dom.getFocusedInputEl(ctx2)?.focus({
                    preventScroll: true
                });
            },
            selectInputIfNeeded (ctx2) {
                if (!ctx2.selectOnFocus || ctx2.focusedIndex === -1) return;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    dom.getFocusedInputEl(ctx2)?.select();
                });
            },
            invokeOnComplete (ctx2) {
                if (!ctx2.isValueComplete) return;
                ctx2.onValueComplete?.({
                    value: Array.from(ctx2.value),
                    valueAsString: ctx2.valueAsString
                });
            },
            invokeOnInvalid (ctx2, evt) {
                ctx2.onValueInvalid?.({
                    value: evt.value,
                    index: ctx2.focusedIndex
                });
            },
            clearFocusedIndex (ctx2) {
                ctx2.focusedIndex = -1;
            },
            setFocusedIndex (ctx2, evt) {
                ctx2.focusedIndex = evt.index;
            },
            setValue (ctx2, evt) {
                set.value(ctx2, evt.value);
            },
            setFocusedValue (ctx2, evt) {
                const nextValue = getNextValue(ctx2.focusedValue, evt.value);
                set.valueAtIndex(ctx2, ctx2.focusedIndex, nextValue);
            },
            revertInputValue (ctx2) {
                const inputEl = dom.getFocusedInputEl(ctx2);
                dom.setValue(inputEl, ctx2.focusedValue);
            },
            syncInputValue (ctx2, evt) {
                const inputEl = dom.getInputEl(ctx2, evt.index.toString());
                dom.setValue(inputEl, ctx2.value[evt.index]);
            },
            syncInputElements (ctx2) {
                const inputEls = dom.getInputEls(ctx2);
                inputEls.forEach((inputEl, index)=>{
                    dom.setValue(inputEl, ctx2.value[index]);
                });
            },
            setPastedValue (ctx2, evt) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const startIndex = Math.min(ctx2.focusedIndex, ctx2.filledValueLength);
                    const left = startIndex > 0 ? ctx2.valueAsString.substring(0, ctx2.focusedIndex) : "";
                    const right = evt.value.substring(0, ctx2.valueLength - startIndex);
                    const value = left + right;
                    set.value(ctx2, value.split(""));
                });
            },
            setValueAtIndex (ctx2, evt) {
                const nextValue = getNextValue(ctx2.focusedValue, evt.value);
                set.valueAtIndex(ctx2, evt.index, nextValue);
            },
            clearValue (ctx2) {
                const nextValue = Array.from({
                    length: ctx2.valueLength
                }).fill("");
                set.value(ctx2, nextValue);
            },
            clearFocusedValue (ctx2) {
                set.valueAtIndex(ctx2, ctx2.focusedIndex, "");
            },
            setFocusIndexToFirst (ctx2) {
                ctx2.focusedIndex = 0;
            },
            setNextFocusedIndex (ctx2) {
                ctx2.focusedIndex = Math.min(ctx2.focusedIndex + 1, ctx2.valueLength - 1);
            },
            setPrevFocusedIndex (ctx2) {
                ctx2.focusedIndex = Math.max(ctx2.focusedIndex - 1, 0);
            },
            setLastValueFocusIndex (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    ctx2.focusedIndex = Math.min(ctx2.filledValueLength, ctx2.valueLength - 1);
                });
            },
            blurFocusedInputIfNeeded (ctx2) {
                if (!ctx2.blurOnComplete) return;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    dom.getFocusedInputEl(ctx2)?.blur();
                });
            },
            requestFormSubmit (ctx2) {
                if (!ctx2.name || !ctx2.isValueComplete) return;
                const inputEl = dom.getHiddenInputEl(ctx2);
                inputEl?.form?.requestSubmit();
            }
        }
    });
}
function assignValue(ctx, value) {
    const arr = Array.isArray(value) ? value : value.split("").filter(Boolean);
    arr.forEach((value2, index)=>{
        ctx.value[index] = value2;
    });
}
function getNextValue(current, next) {
    let nextValue = next;
    if (current[0] === next[0]) nextValue = next[1];
    else if (current[0] === next[1]) nextValue = next[0];
    return nextValue.split("")[nextValue.length - 1];
}
var invoke = {
    change (ctx) {
        ctx.onValueChange?.({
            value: Array.from(ctx.value),
            valueAsString: ctx.valueAsString
        });
        const inputEl = dom.getHiddenInputEl(ctx);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dispatchInputValueEvent"])(inputEl, {
            value: ctx.valueAsString
        });
    }
};
var set = {
    value (ctx, value) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value, value)) return;
        assignValue(ctx, value);
        invoke.change(ctx);
    },
    valueAtIndex (ctx, index, value) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isEqual"])(ctx.value[index], value)) return;
        ctx.value[index] = value;
        invoke.change(ctx);
    }
};
;
}}),
"[project]/node_modules/@zag-js/pin-input/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as pinInputAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "pinInputAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$pin$2d$input$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$pin$2d$input$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/pin-input/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/progress/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
;
;
;
;
;
// src/progress.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("progress").parts("root", "label", "track", "range", "valueText", "view", "circle", "circleTrack", "circleRange");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `progress-${ctx.id}`,
    getTrackId: (ctx)=>ctx.ids?.track ?? `progress-${ctx.id}-track`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `progress-${ctx.id}-label`,
    getCircleId: (ctx)=>ctx.ids?.circle ?? `progress-${ctx.id}-circle`
});
// src/progress.connect.ts
function connect(state, send, normalize) {
    const percent = state.context.percent;
    const percentAsString = state.context.isIndeterminate ? "" : `${percent}%`;
    const max = state.context.max;
    const min = state.context.min;
    const orientation = state.context.orientation;
    const translations = state.context.translations;
    const indeterminate = state.context.isIndeterminate;
    const value = state.context.value;
    const valueAsString = translations.value({
        value,
        max,
        percent,
        min
    });
    const progressState = getProgressState(value, max);
    const progressbarProps = {
        role: "progressbar",
        "aria-label": valueAsString,
        "data-max": max,
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": value ?? void 0,
        "data-orientation": orientation,
        "data-state": progressState
    };
    const circleProps = getCircleProps(state.context);
    return {
        value,
        valueAsString,
        min,
        max,
        percent,
        percentAsString,
        indeterminate,
        setValue (value2) {
            send({
                type: "VALUE.SET",
                value: value2
            });
        },
        setToMax () {
            send({
                type: "VALUE.SET",
                value: max
            });
        },
        setToMin () {
            send({
                type: "VALUE.SET",
                value: min
            });
        },
        getRootProps () {
            return normalize.element({
                dir: state.context.dir,
                ...parts.root.attrs,
                id: dom.getRootId(state.context),
                "data-max": max,
                "data-value": value ?? void 0,
                "data-state": progressState,
                "data-orientation": orientation,
                style: {
                    "--percent": indeterminate ? void 0 : percent
                }
            });
        },
        getLabelProps () {
            return normalize.element({
                dir: state.context.dir,
                id: dom.getLabelId(state.context),
                ...parts.label.attrs,
                "data-orientation": orientation
            });
        },
        getValueTextProps () {
            return normalize.element({
                dir: state.context.dir,
                "aria-live": "polite",
                ...parts.valueText.attrs
            });
        },
        getTrackProps () {
            return normalize.element({
                dir: state.context.dir,
                id: dom.getTrackId(state.context),
                ...parts.track.attrs,
                ...progressbarProps
            });
        },
        getRangeProps () {
            return normalize.element({
                dir: state.context.dir,
                ...parts.range.attrs,
                "data-orientation": orientation,
                "data-state": progressState,
                style: {
                    [state.context.isHorizontal ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
                }
            });
        },
        getCircleProps () {
            return normalize.element({
                dir: state.context.dir,
                id: dom.getCircleId(state.context),
                ...parts.circle.attrs,
                ...progressbarProps,
                ...circleProps.root
            });
        },
        getCircleTrackProps () {
            return normalize.element({
                dir: state.context.dir,
                "data-orientation": orientation,
                ...parts.circleTrack.attrs,
                ...circleProps.track
            });
        },
        getCircleRangeProps () {
            return normalize.element({
                dir: state.context.dir,
                ...parts.circleRange.attrs,
                ...circleProps.range,
                "data-state": progressState
            });
        },
        getViewProps (props2) {
            return normalize.element({
                dir: state.context.dir,
                ...parts.view.attrs,
                "data-state": props2.state,
                hidden: props2.state !== progressState
            });
        }
    };
}
function getProgressState(value, maxValue) {
    return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function getCircleProps(ctx) {
    const circleProps = {
        style: {
            "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
            cx: "calc(var(--size) / 2)",
            cy: "calc(var(--size) / 2)",
            r: "var(--radius)",
            fill: "transparent",
            strokeWidth: "var(--thickness)"
        }
    };
    return {
        root: {
            style: {
                width: "var(--size)",
                height: "var(--size)"
            }
        },
        track: circleProps,
        range: {
            opacity: ctx.value === 0 ? 0 : void 0,
            style: {
                ...circleProps.style,
                "--percent": ctx.percent,
                "--circumference": `calc(2 * 3.14159 * var(--radius))`,
                "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,
                strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
                strokeDasharray: ctx.isIndeterminate ? void 0 : `var(--circumference)`,
                transformOrigin: "center",
                transform: "rotate(-90deg)"
            }
        }
    };
}
function midValue(min, max) {
    return min + (max - min) / 2;
}
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "progress",
        initial: "idle",
        context: {
            max: ctx.max ?? 100,
            min: ctx.min ?? 0,
            value: midValue(ctx.min ?? 0, ctx.max ?? 100),
            orientation: "horizontal",
            translations: {
                value: ({ percent })=>percent === -1 ? "loading..." : `${percent} percent`,
                ...ctx.translations
            },
            ...ctx
        },
        created: [
            "validateContext"
        ],
        computed: {
            isIndeterminate: (ctx2)=>ctx2.value === null,
            percent (ctx2) {
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isNumber"])(ctx2.value)) return -1;
                return Math.round((ctx2.value - ctx2.min) / (ctx2.max - ctx2.min) * 100);
            },
            isAtMax: (ctx2)=>ctx2.value === ctx2.max,
            isHorizontal: (ctx2)=>ctx2.orientation === "horizontal",
            isRtl: (ctx2)=>ctx2.dir === "rtl"
        },
        states: {
            idle: {
                on: {
                    "VALUE.SET": {
                        actions: [
                            "setValue"
                        ]
                    }
                }
            }
        }
    }, {
        actions: {
            setValue: (ctx2, evt)=>{
                ctx2.value = evt.value === null ? null : Math.max(0, Math.min(evt.value, ctx2.max));
            },
            validateContext: (ctx2)=>{
                if (ctx2.value == null) return;
                if (!isValidNumber(ctx2.max)) {
                    throw new Error(`[progress] The max value passed \`${ctx2.max}\` is not a valid number`);
                }
                if (!isValidMax(ctx2.value, ctx2.max)) {
                    throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the max value \`${ctx2.max}\``);
                }
                if (!isValidMin(ctx2.value, ctx2.min)) {
                    throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the min value \`${ctx2.min}\``);
                }
            }
        }
    });
}
function isValidNumber(max) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isNumber"])(max) && !isNaN(max);
}
function isValidMax(value, max) {
    return isValidNumber(value) && value <= max;
}
function isValidMin(value, min) {
    return isValidNumber(value) && value >= min;
}
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "dir",
    "getRootNode",
    "id",
    "ids",
    "max",
    "min",
    "orientation",
    "translations",
    "value"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
;
}}),
"[project]/node_modules/@zag-js/progress/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as progressAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "progressAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$progress$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$progress$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/progress/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/tooltip/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "props": (()=>props),
    "splitProps": (()=>splitProps)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/types/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/store/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/popper/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$visible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/focus-visible/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
// src/tooltip.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getTriggerId: (ctx)=>ctx.ids?.trigger ?? `tooltip:${ctx.id}:trigger`,
    getContentId: (ctx)=>ctx.ids?.content ?? `tooltip:${ctx.id}:content`,
    getArrowId: (ctx)=>ctx.ids?.arrow ?? `tooltip:${ctx.id}:arrow`,
    getPositionerId: (ctx)=>ctx.ids?.positioner ?? `tooltip:${ctx.id}:popper`,
    getTriggerEl: (ctx)=>dom.getById(ctx, dom.getTriggerId(ctx)),
    getContentEl: (ctx)=>dom.getById(ctx, dom.getContentId(ctx)),
    getPositionerEl: (ctx)=>dom.getById(ctx, dom.getPositionerId(ctx)),
    getArrowEl: (ctx)=>dom.getById(ctx, dom.getArrowId(ctx))
});
var store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["proxy"])({
    id: null,
    prevId: null,
    setId (val) {
        this.prevId = this.id;
        this.id = val;
    }
});
// src/tooltip.connect.ts
function connect(state, send, normalize) {
    const id = state.context.id;
    const hasAriaLabel = state.context.hasAriaLabel;
    const open = state.hasTag("open");
    const triggerId = dom.getTriggerId(state.context);
    const contentId = dom.getContentId(state.context);
    const disabled = state.context.disabled;
    const popperStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacementStyles"])({
        ...state.context.positioning,
        placement: state.context.currentPlacement
    });
    return {
        open,
        setOpen (nextOpen) {
            if (nextOpen === open) return;
            send(nextOpen ? "OPEN" : "CLOSE");
        },
        reposition (options = {}) {
            send({
                type: "POSITIONING.SET",
                options
            });
        },
        getTriggerProps () {
            return normalize.button({
                ...parts.trigger.attrs,
                id: triggerId,
                dir: state.context.dir,
                "data-expanded": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(open),
                "data-state": open ? "open" : "closed",
                "aria-describedby": open ? contentId : void 0,
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (disabled) return;
                    if (!state.context.closeOnClick) return;
                    send({
                        type: "CLOSE",
                        src: "trigger.click"
                    });
                },
                onFocus (event) {
                    if (event.defaultPrevented) return;
                    if (disabled) return;
                    if (state.event.src === "trigger.pointerdown") return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$visible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isFocusVisible"])()) return;
                    send({
                        type: "OPEN",
                        src: "trigger.focus"
                    });
                },
                onBlur (event) {
                    if (event.defaultPrevented) return;
                    if (disabled) return;
                    if (id === store.id) {
                        send({
                            type: "CLOSE",
                            src: "trigger.blur"
                        });
                    }
                },
                onPointerDown (event) {
                    if (event.defaultPrevented) return;
                    if (disabled) return;
                    if (!state.context.closeOnPointerDown) return;
                    if (id === store.id) {
                        send({
                            type: "CLOSE",
                            src: "trigger.pointerdown"
                        });
                    }
                },
                onPointerMove (event) {
                    if (event.defaultPrevented) return;
                    if (disabled) return;
                    if (event.pointerType === "touch") return;
                    send("POINTER_MOVE");
                },
                onPointerLeave () {
                    if (disabled) return;
                    send("POINTER_LEAVE");
                },
                onPointerCancel () {
                    if (disabled) return;
                    send("POINTER_LEAVE");
                }
            });
        },
        getArrowProps () {
            return normalize.element({
                id: dom.getArrowId(state.context),
                ...parts.arrow.attrs,
                dir: state.context.dir,
                style: popperStyles.arrow
            });
        },
        getArrowTipProps () {
            return normalize.element({
                ...parts.arrowTip.attrs,
                dir: state.context.dir,
                style: popperStyles.arrowTip
            });
        },
        getPositionerProps () {
            return normalize.element({
                id: dom.getPositionerId(state.context),
                ...parts.positioner.attrs,
                dir: state.context.dir,
                style: popperStyles.floating
            });
        },
        getContentProps () {
            return normalize.element({
                ...parts.content.attrs,
                dir: state.context.dir,
                hidden: !open,
                "data-state": open ? "open" : "closed",
                role: hasAriaLabel ? void 0 : "tooltip",
                id: hasAriaLabel ? void 0 : contentId,
                "data-placement": state.context.currentPlacement,
                onPointerEnter () {
                    send("CONTENT.POINTER_MOVE");
                },
                onPointerLeave () {
                    send("CONTENT.POINTER_LEAVE");
                },
                style: {
                    pointerEvents: state.context.interactive ? "auto" : "none"
                }
            });
        }
    };
}
var { and, not } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guards"];
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "tooltip",
        initial: ctx.open ? "open" : "closed",
        activities: [
            "trackFocusVisible"
        ],
        context: {
            openDelay: 1e3,
            closeDelay: 500,
            closeOnPointerDown: true,
            closeOnEscape: true,
            interactive: false,
            closeOnScroll: true,
            closeOnClick: true,
            ...ctx,
            currentPlacement: void 0,
            hasPointerMoveOpened: false,
            positioning: {
                placement: "bottom",
                ...ctx.positioning
            }
        },
        computed: {
            hasAriaLabel: (ctx2)=>!!ctx2["aria-label"]
        },
        watch: {
            disabled: [
                "closeIfDisabled"
            ],
            open: [
                "toggleVisibility"
            ]
        },
        states: {
            closed: {
                tags: [
                    "closed"
                ],
                entry: [
                    "clearGlobalId"
                ],
                on: {
                    "CONTROLLED.OPEN": "open",
                    OPEN: {
                        target: "open",
                        actions: [
                            "invokeOnOpen"
                        ]
                    },
                    POINTER_LEAVE: {
                        actions: [
                            "clearPointerMoveOpened"
                        ]
                    },
                    POINTER_MOVE: [
                        {
                            guard: and("noVisibleTooltip", not("hasPointerMoveOpened")),
                            target: "opening"
                        },
                        {
                            guard: not("hasPointerMoveOpened"),
                            target: "open",
                            actions: [
                                "setPointerMoveOpened",
                                "invokeOnOpen"
                            ]
                        }
                    ]
                }
            },
            opening: {
                tags: [
                    "closed"
                ],
                activities: [
                    "trackScroll",
                    "trackPointerlockChange"
                ],
                after: {
                    OPEN_DELAY: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "setPointerMoveOpened",
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setPointerMoveOpened",
                                "invokeOnOpen"
                            ]
                        }
                    ]
                },
                on: {
                    "CONTROLLED.OPEN": "open",
                    "CONTROLLED.CLOSE": "closed",
                    OPEN: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen"
                            ]
                        }
                    ],
                    POINTER_LEAVE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "clearPointerMoveOpened",
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "clearPointerMoveOpened",
                                "invokeOnClose"
                            ]
                        }
                    ],
                    CLOSE: {
                        target: "closed",
                        actions: [
                            "invokeOnClose"
                        ]
                    }
                }
            },
            open: {
                tags: [
                    "open"
                ],
                activities: [
                    "trackEscapeKey",
                    "trackScroll",
                    "trackPointerlockChange",
                    "trackPositioning"
                ],
                entry: [
                    "setGlobalId"
                ],
                on: {
                    "CONTROLLED.CLOSE": "closed",
                    CLOSE: {
                        target: "closed",
                        actions: [
                            "invokeOnClose"
                        ]
                    },
                    POINTER_LEAVE: [
                        {
                            guard: "isVisible",
                            target: "closing",
                            actions: [
                                "clearPointerMoveOpened"
                            ]
                        },
                        // == group ==
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "clearPointerMoveOpened",
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "clearPointerMoveOpened",
                                "invokeOnClose"
                            ]
                        }
                    ],
                    "CONTENT.POINTER_LEAVE": {
                        guard: "isInteractive",
                        target: "closing"
                    },
                    "POSITIONING.SET": {
                        actions: "reposition"
                    }
                }
            },
            closing: {
                tags: [
                    "open"
                ],
                activities: [
                    "trackStore",
                    "trackPositioning"
                ],
                after: {
                    CLOSE_DELAY: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ]
                },
                on: {
                    "CONTROLLED.CLOSE": "closed",
                    "CONTROLLED.OPEN": "open",
                    CLOSE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "closed",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    POINTER_MOVE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "setPointerMoveOpened",
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "setPointerMoveOpened",
                                "invokeOnOpen"
                            ]
                        }
                    ],
                    "CONTENT.POINTER_MOVE": {
                        guard: "isInteractive",
                        target: "open"
                    },
                    "POSITIONING.SET": {
                        actions: "reposition"
                    }
                }
            }
        }
    }, {
        activities: {
            trackFocusVisible (ctx2) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$visible$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackFocusVisible"])({
                    root: dom.getRootNode(ctx2)
                });
            },
            trackPositioning (ctx2) {
                ctx2.currentPlacement = ctx2.positioning.placement;
                const getPositionerEl = ()=>dom.getPositionerEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(dom.getTriggerEl(ctx2), getPositionerEl, {
                    ...ctx2.positioning,
                    defer: true,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            trackPointerlockChange (ctx2, _evt, { send }) {
                const onChange = ()=>send({
                        type: "CLOSE",
                        src: "pointerlock:change"
                    });
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])(dom.getDoc(ctx2), "pointerlockchange", onChange, false);
            },
            trackScroll (ctx2, _evt, { send }) {
                if (!ctx2.closeOnScroll) return;
                const triggerEl = dom.getTriggerEl(ctx2);
                if (!triggerEl) return;
                const overflowParents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getOverflowAncestors"])(triggerEl);
                const cleanups = overflowParents.map((overflowParent)=>{
                    const onScroll = ()=>{
                        send({
                            type: "CLOSE",
                            src: "scroll"
                        });
                    };
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])(overflowParent, "scroll", onScroll, {
                        passive: true,
                        capture: true
                    });
                });
                return ()=>{
                    cleanups.forEach((fn)=>fn?.());
                };
            },
            trackStore (ctx2, _evt, { send }) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$store$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["subscribe"])(store, ()=>{
                    if (store.id !== ctx2.id) {
                        send({
                            type: "CLOSE",
                            src: "id.change"
                        });
                    }
                });
            },
            trackEscapeKey (ctx2, _evt, { send }) {
                if (!ctx2.closeOnEscape) return;
                const onKeyDown = (event)=>{
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isComposingEvent"])(event)) return;
                    if (event.key !== "Escape") return;
                    event.stopPropagation();
                    send({
                        type: "CLOSE",
                        src: "keydown.escape"
                    });
                };
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDomEvent"])(dom.getDoc(ctx2), "keydown", onKeyDown, true);
            }
        },
        actions: {
            setGlobalId (ctx2) {
                store.setId(ctx2.id);
            },
            clearGlobalId (ctx2) {
                if (ctx2.id === store.id) {
                    store.setId(null);
                }
            },
            invokeOnOpen (ctx2) {
                ctx2.onOpenChange?.({
                    open: true
                });
            },
            invokeOnClose (ctx2) {
                ctx2.onOpenChange?.({
                    open: false
                });
            },
            closeIfDisabled (ctx2, _evt, { send }) {
                if (!ctx2.disabled) return;
                send({
                    type: "CLOSE",
                    src: "disabled.change"
                });
            },
            reposition (ctx2, evt) {
                const getPositionerEl = ()=>dom.getPositionerEl(ctx2);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(dom.getTriggerEl(ctx2), getPositionerEl, {
                    ...ctx2.positioning,
                    ...evt.options,
                    defer: true,
                    listeners: false,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            toggleVisibility (ctx2, evt, { send }) {
                send({
                    type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
                    previousEvent: evt
                });
            },
            setPointerMoveOpened (ctx2) {
                ctx2.hasPointerMoveOpened = true;
            },
            clearPointerMoveOpened (ctx2) {
                ctx2.hasPointerMoveOpened = false;
            }
        },
        guards: {
            noVisibleTooltip: ()=>store.id === null,
            isVisible: (ctx2)=>ctx2.id === store.id,
            isInteractive: (ctx2)=>ctx2.interactive,
            hasPointerMoveOpened: (ctx2)=>!!ctx2.hasPointerMoveOpened,
            isOpenControlled: (ctx2)=>!!ctx2["open.controlled"]
        },
        delays: {
            OPEN_DELAY: (ctx2)=>ctx2.openDelay,
            CLOSE_DELAY: (ctx2)=>ctx2.closeDelay
        }
    });
}
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createProps"])()([
    "aria-label",
    "closeDelay",
    "closeOnEscape",
    "closeOnPointerDown",
    "closeOnScroll",
    "closeOnClick",
    "dir",
    "disabled",
    "getRootNode",
    "id",
    "ids",
    "interactive",
    "onOpenChange",
    "open.controlled",
    "open",
    "openDelay",
    "positioning"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
;
}}),
"[project]/node_modules/@zag-js/tooltip/dist/index.mjs [app-rsc] (ecmascript) <export anatomy as tooltipAnatomy>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "tooltipAnatomy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$tooltip$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["anatomy"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$tooltip$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/tooltip/dist/index.mjs [app-rsc] (ecmascript)");
}}),
"[project]/node_modules/@zag-js/color-utils/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Color": (()=>Color),
    "getColorAreaGradient": (()=>getColorAreaGradient),
    "normalizeColor": (()=>normalizeColor),
    "parseColor": (()=>parseColor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/numeric-range/dist/index.mjs [app-rsc] (ecmascript)");
;
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, key + "", value);
// src/color-format-gradient.ts
var generateRGB_R = (orientation, dir, zValue)=>{
    const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
    const result = {
        areaStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`
        },
        areaGradientStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,
            WebkitMaskImage: maskImage,
            maskImage
        }
    };
    return result;
};
var generateRGB_G = (orientation, dir, zValue)=>{
    const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
    const result = {
        areaStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`
        },
        areaGradientStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,
            WebkitMaskImage: maskImage,
            maskImage
        }
    };
    return result;
};
var generateRGB_B = (orientation, dir, zValue)=>{
    const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
    const result = {
        areaStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`
        },
        areaGradientStyles: {
            backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,
            WebkitMaskImage: maskImage,
            maskImage
        }
    };
    return result;
};
var generateHSL_H = (orientation, dir, zValue)=>{
    const result = {
        areaStyles: {},
        areaGradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,
                `hsl(${zValue}, 100%, 50%)`
            ].join(",")
        }
    };
    return result;
};
var generateHSL_S = (orientation, dir, alphaValue)=>{
    const result = {
        areaStyles: {},
        areaGradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,
                `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
                "hsl(0, 0%, 50%)"
            ].join(",")
        }
    };
    return result;
};
var generateHSL_L = (orientation, dir, zValue)=>{
    const result = {
        areaStyles: {},
        areaGradientStyles: {
            backgroundImage: [
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,
                `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`
            ].join(",")
        }
    };
    return result;
};
var generateHSB_H = (orientation, dir, zValue)=>{
    const result = {
        areaStyles: {},
        areaGradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,
                `hsl(${zValue}, 100%, 50%)`
            ].join(",")
        }
    };
    return result;
};
var generateHSB_S = (orientation, dir, alphaValue)=>{
    const result = {
        areaStyles: {},
        areaGradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,
                `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
                `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`
            ].join(",")
        }
    };
    return result;
};
var generateHSB_B = (orientation, dir, alphaValue)=>{
    const result = {
        areaStyles: {},
        areaGradientStyles: {
            background: [
                `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,
                `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
                "#000"
            ].join(",")
        }
    };
    return result;
};
// src/area-gradient.ts
function getColorAreaGradient(color, options) {
    const { xChannel, yChannel, dir: dirProp = "ltr" } = options;
    const { zChannel } = color.getColorAxes({
        xChannel,
        yChannel
    });
    const zValue = color.getChannelValue(zChannel);
    const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel);
    const orientation = [
        "top",
        dirProp === "rtl" ? "left" : "right"
    ];
    let dir = false;
    let background = {
        areaStyles: {},
        areaGradientStyles: {}
    };
    let alphaValue = (zValue - zMin) / (zMax - zMin);
    let isHSL = color.getFormat() === "hsla";
    switch(zChannel){
        case "red":
            {
                dir = xChannel === "green";
                background = generateRGB_R(orientation, dir, zValue);
                break;
            }
        case "green":
            {
                dir = xChannel === "red";
                background = generateRGB_G(orientation, dir, zValue);
                break;
            }
        case "blue":
            {
                dir = xChannel === "red";
                background = generateRGB_B(orientation, dir, zValue);
                break;
            }
        case "hue":
            {
                dir = xChannel !== "saturation";
                if (isHSL) {
                    background = generateHSL_H(orientation, dir, zValue);
                } else {
                    background = generateHSB_H(orientation, dir, zValue);
                }
                break;
            }
        case "saturation":
            {
                dir = xChannel === "hue";
                if (isHSL) {
                    background = generateHSL_S(orientation, dir, alphaValue);
                } else {
                    background = generateHSB_S(orientation, dir, alphaValue);
                }
                break;
            }
        case "brightness":
            {
                dir = xChannel === "hue";
                background = generateHSB_B(orientation, dir, alphaValue);
                break;
            }
        case "lightness":
            {
                dir = xChannel === "hue";
                background = generateHSL_L(orientation, dir, zValue);
                break;
            }
    }
    return background;
}
var isEqualObject = (a, b)=>{
    if (Object.keys(a).length !== Object.keys(b).length) return false;
    for(let key in a)if (a[key] !== b[key]) return false;
    return true;
};
var Color = class {
    toHexInt() {
        return this.toFormat("rgba").toHexInt();
    }
    getChannelValue(channel) {
        if (channel in this) return this[channel];
        throw new Error("Unsupported color channel: " + channel);
    }
    getChannelValuePercent(channel, valueToCheck) {
        const value = valueToCheck ?? this.getChannelValue(channel);
        const { minValue, maxValue } = this.getChannelRange(channel);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getValuePercent"])(value, minValue, maxValue);
    }
    getChannelPercentValue(channel, percentToCheck) {
        const { minValue, maxValue, step } = this.getChannelRange(channel);
        const percentValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPercentValue"])(percentToCheck, minValue, maxValue, step);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["snapValueToStep"])(percentValue, minValue, maxValue, step);
    }
    withChannelValue(channel, value) {
        const { minValue, maxValue } = this.getChannelRange(channel);
        if (channel in this) {
            let clone = this.clone();
            clone[channel] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(value, minValue, maxValue);
            return clone;
        }
        throw new Error("Unsupported color channel: " + channel);
    }
    getColorAxes(xyChannels) {
        let { xChannel, yChannel } = xyChannels;
        let xCh = xChannel || this.getChannels().find((c)=>c !== yChannel);
        let yCh = yChannel || this.getChannels().find((c)=>c !== xCh);
        let zCh = this.getChannels().find((c)=>c !== xCh && c !== yCh);
        return {
            xChannel: xCh,
            yChannel: yCh,
            zChannel: zCh
        };
    }
    incrementChannel(channel, stepSize) {
        const { minValue, maxValue, step } = this.getChannelRange(channel);
        const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["snapValueToStep"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(this.getChannelValue(channel) + stepSize, minValue, maxValue), minValue, maxValue, step);
        return this.withChannelValue(channel, value);
    }
    decrementChannel(channel, stepSize) {
        return this.incrementChannel(channel, -stepSize);
    }
    isEqual(color) {
        const isSame = isEqualObject(this.toJSON(), color.toJSON());
        return isSame && this.getChannelValue("alpha") === color.getChannelValue("alpha");
    }
};
var _RGBColor = class _RGBColor extends Color {
    constructor(red, green, blue, alpha){
        super();
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.alpha = alpha;
    }
    static parse(value) {
        let colors = [];
        if (/^#[\da-f]+$/i.test(value) && [
            4,
            5,
            7,
            9
        ].includes(value.length)) {
            const values = (value.length < 6 ? value.replace(/[^#]/gi, "$&$&") : value).slice(1).split("");
            while(values.length > 0){
                colors.push(parseInt(values.splice(0, 2).join(""), 16));
            }
            colors[3] = colors[3] !== void 0 ? colors[3] / 255 : void 0;
        }
        const match = value.match(/^rgba?\((.*)\)$/);
        if (match?.[1]) {
            colors = match[1].split(",").map((value2)=>Number(value2.trim())).map((num, i)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(num, 0, i < 3 ? 255 : 1));
        }
        return colors.length < 3 ? void 0 : new _RGBColor(colors[0], colors[1], colors[2], colors[3] ?? 1);
    }
    toString(format) {
        switch(format){
            case "hex":
                return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0")).toUpperCase();
            case "hexa":
                return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0") + Math.round(this.alpha * 255).toString(16).padStart(2, "0")).toUpperCase();
            case "rgb":
                return `rgb(${this.red}, ${this.green}, ${this.blue})`;
            case "css":
            case "rgba":
                return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
            case "hsl":
                return this.toHSL().toString("hsl");
            case "hsb":
                return this.toHSB().toString("hsb");
            default:
                return this.toFormat(format).toString(format);
        }
    }
    toFormat(format) {
        switch(format){
            case "rgba":
                return this;
            case "hsba":
                return this.toHSB();
            case "hsla":
                return this.toHSL();
            default:
                throw new Error("Unsupported color conversion: rgb -> " + format);
        }
    }
    toHexInt() {
        return this.red << 16 | this.green << 8 | this.blue;
    }
    /**
   * Converts an RGB color value to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSBColor object.
   */ toHSB() {
        const red = this.red / 255;
        const green = this.green / 255;
        const blue = this.blue / 255;
        const min = Math.min(red, green, blue);
        const brightness = Math.max(red, green, blue);
        const chroma = brightness - min;
        const saturation = brightness === 0 ? 0 : chroma / brightness;
        let hue = 0;
        if (chroma !== 0) {
            switch(brightness){
                case red:
                    hue = (green - blue) / chroma + (green < blue ? 6 : 0);
                    break;
                case green:
                    hue = (blue - red) / chroma + 2;
                    break;
                case blue:
                    hue = (red - green) / chroma + 4;
                    break;
            }
            hue /= 6;
        }
        return new HSBColor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(hue * 360, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(saturation * 100, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(brightness * 100, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.alpha, 2));
    }
    /**
   * Converts an RGB color value to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSLColor object.
   */ toHSL() {
        const red = this.red / 255;
        const green = this.green / 255;
        const blue = this.blue / 255;
        const min = Math.min(red, green, blue);
        const max = Math.max(red, green, blue);
        const lightness = (max + min) / 2;
        const chroma = max - min;
        let hue = -1;
        let saturation = -1;
        if (chroma === 0) {
            hue = saturation = 0;
        } else {
            saturation = chroma / (lightness < 0.5 ? max + min : 2 - max - min);
            switch(max){
                case red:
                    hue = (green - blue) / chroma + (green < blue ? 6 : 0);
                    break;
                case green:
                    hue = (blue - red) / chroma + 2;
                    break;
                case blue:
                    hue = (red - green) / chroma + 4;
                    break;
            }
            hue /= 6;
        }
        return new HSLColor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(hue * 360, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(saturation * 100, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(lightness * 100, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.alpha, 2));
    }
    clone() {
        return new _RGBColor(this.red, this.green, this.blue, this.alpha);
    }
    getChannelFormatOptions(channel) {
        switch(channel){
            case "red":
            case "green":
            case "blue":
                return {
                    style: "decimal"
                };
            case "alpha":
                return {
                    style: "percent"
                };
            default:
                throw new Error("Unknown color channel: " + channel);
        }
    }
    formatChannelValue(channel, locale) {
        let options = this.getChannelFormatOptions(channel);
        let value = this.getChannelValue(channel);
        return new Intl.NumberFormat(locale, options).format(value);
    }
    getChannelRange(channel) {
        switch(channel){
            case "red":
            case "green":
            case "blue":
                return {
                    minValue: 0,
                    maxValue: 255,
                    step: 1,
                    pageSize: 17
                };
            case "alpha":
                return {
                    minValue: 0,
                    maxValue: 1,
                    step: 0.01,
                    pageSize: 0.1
                };
            default:
                throw new Error("Unknown color channel: " + channel);
        }
    }
    toJSON() {
        return {
            r: this.red,
            g: this.green,
            b: this.blue,
            a: this.alpha
        };
    }
    getFormat() {
        return "rgba";
    }
    getChannels() {
        return _RGBColor.colorChannels;
    }
};
__publicField(_RGBColor, "colorChannels", [
    "red",
    "green",
    "blue"
]);
var RGBColor = _RGBColor;
// src/hsl-color.ts
var HSL_REGEX = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSLColor = class _HSLColor extends Color {
    constructor(hue, saturation, lightness, alpha){
        super();
        this.hue = hue;
        this.saturation = saturation;
        this.lightness = lightness;
        this.alpha = alpha;
    }
    static parse(value) {
        let m;
        if (m = value.match(HSL_REGEX)) {
            const [h, s, l, a] = (m[1] ?? m[2]).split(",").map((n)=>Number(n.trim().replace("%", "")));
            return new _HSLColor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["mod"])(h, 360), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(s, 0, 100), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(l, 0, 100), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(a ?? 1, 0, 1));
        }
    }
    toString(format) {
        switch(format){
            case "hex":
                return this.toRGB().toString("hex");
            case "hexa":
                return this.toRGB().toString("hexa");
            case "hsl":
                return `hsl(${this.hue}, ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.saturation, 2)}%, ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.lightness, 2)}%)`;
            case "css":
            case "hsla":
                return `hsla(${this.hue}, ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.saturation, 2)}%, ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.lightness, 2)}%, ${this.alpha})`;
            case "hsb":
                return this.toHSB().toString("hsb");
            case "rgb":
                return this.toRGB().toString("rgb");
            default:
                return this.toFormat(format).toString(format);
        }
    }
    toFormat(format) {
        switch(format){
            case "hsla":
                return this;
            case "hsba":
                return this.toHSB();
            case "rgba":
                return this.toRGB();
            default:
                throw new Error("Unsupported color conversion: hsl -> " + format);
        }
    }
    /**
   * Converts a HSL color to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.
   * @returns An HSBColor object.
   */ toHSB() {
        let saturation = this.saturation / 100;
        let lightness = this.lightness / 100;
        let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
        saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
        return new HSBColor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.hue, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(saturation * 100, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(brightness * 100, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.alpha, 2));
    }
    /**
   * Converts a HSL color to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.
   * @returns An RGBColor object.
   */ toRGB() {
        let hue = this.hue;
        let saturation = this.saturation / 100;
        let lightness = this.lightness / 100;
        let a = saturation * Math.min(lightness, 1 - lightness);
        let fn = (n, k = (n + hue / 30) % 12)=>lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return new RGBColor(Math.round(fn(0) * 255), Math.round(fn(8) * 255), Math.round(fn(4) * 255), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.alpha, 2));
    }
    clone() {
        return new _HSLColor(this.hue, this.saturation, this.lightness, this.alpha);
    }
    getChannelFormatOptions(channel) {
        switch(channel){
            case "hue":
                return {
                    style: "unit",
                    unit: "degree",
                    unitDisplay: "narrow"
                };
            case "saturation":
            case "lightness":
            case "alpha":
                return {
                    style: "percent"
                };
            default:
                throw new Error("Unknown color channel: " + channel);
        }
    }
    formatChannelValue(channel, locale) {
        let options = this.getChannelFormatOptions(channel);
        let value = this.getChannelValue(channel);
        if (channel === "saturation" || channel === "lightness") {
            value /= 100;
        }
        return new Intl.NumberFormat(locale, options).format(value);
    }
    getChannelRange(channel) {
        switch(channel){
            case "hue":
                return {
                    minValue: 0,
                    maxValue: 360,
                    step: 1,
                    pageSize: 15
                };
            case "saturation":
            case "lightness":
                return {
                    minValue: 0,
                    maxValue: 100,
                    step: 1,
                    pageSize: 10
                };
            case "alpha":
                return {
                    minValue: 0,
                    maxValue: 1,
                    step: 0.01,
                    pageSize: 0.1
                };
            default:
                throw new Error("Unknown color channel: " + channel);
        }
    }
    toJSON() {
        return {
            h: this.hue,
            s: this.saturation,
            l: this.lightness,
            a: this.alpha
        };
    }
    getFormat() {
        return "hsla";
    }
    getChannels() {
        return _HSLColor.colorChannels;
    }
};
__publicField(_HSLColor, "colorChannels", [
    "hue",
    "saturation",
    "lightness"
]);
var HSLColor = _HSLColor;
// src/hsb-color.ts
var HSB_REGEX = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSBColor = class _HSBColor extends Color {
    constructor(hue, saturation, brightness, alpha){
        super();
        this.hue = hue;
        this.saturation = saturation;
        this.brightness = brightness;
        this.alpha = alpha;
    }
    static parse(value) {
        let m;
        if (m = value.match(HSB_REGEX)) {
            const [h, s, b, a] = (m[1] ?? m[2]).split(",").map((n)=>Number(n.trim().replace("%", "")));
            return new _HSBColor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["mod"])(h, 360), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(s, 0, 100), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(b, 0, 100), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clampValue"])(a ?? 1, 0, 1));
        }
    }
    toString(format) {
        switch(format){
            case "css":
                return this.toHSL().toString("css");
            case "hex":
                return this.toRGB().toString("hex");
            case "hexa":
                return this.toRGB().toString("hexa");
            case "hsb":
                return `hsb(${this.hue}, ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.saturation, 2)}%, ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.brightness, 2)}%)`;
            case "hsba":
                return `hsba(${this.hue}, ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.saturation, 2)}%, ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.brightness, 2)}%, ${this.alpha})`;
            case "hsl":
                return this.toHSL().toString("hsl");
            case "rgb":
                return this.toRGB().toString("rgb");
            default:
                return this.toFormat(format).toString(format);
        }
    }
    toFormat(format) {
        switch(format){
            case "hsba":
                return this;
            case "hsla":
                return this.toHSL();
            case "rgba":
                return this.toRGB();
            default:
                throw new Error("Unsupported color conversion: hsb -> " + format);
        }
    }
    /**
   * Converts a HSB color to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.
   * @returns An HSLColor object.
   */ toHSL() {
        let saturation = this.saturation / 100;
        let brightness = this.brightness / 100;
        let lightness = brightness * (1 - saturation / 2);
        saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
        return new HSLColor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.hue, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(saturation * 100, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(lightness * 100, 2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.alpha, 2));
    }
    /**
   * Converts a HSV color value to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.
   * @returns An RGBColor object.
   */ toRGB() {
        let hue = this.hue;
        let saturation = this.saturation / 100;
        let brightness = this.brightness / 100;
        let fn = (n, k = (n + hue / 60) % 6)=>brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);
        return new RGBColor(Math.round(fn(5) * 255), Math.round(fn(3) * 255), Math.round(fn(1) * 255), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$numeric$2d$range$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toFixedNumber"])(this.alpha, 2));
    }
    clone() {
        return new _HSBColor(this.hue, this.saturation, this.brightness, this.alpha);
    }
    getChannelFormatOptions(channel) {
        switch(channel){
            case "hue":
                return {
                    style: "unit",
                    unit: "degree",
                    unitDisplay: "narrow"
                };
            case "saturation":
            case "brightness":
            case "alpha":
                return {
                    style: "percent"
                };
            default:
                throw new Error("Unknown color channel: " + channel);
        }
    }
    formatChannelValue(channel, locale) {
        let options = this.getChannelFormatOptions(channel);
        let value = this.getChannelValue(channel);
        if (channel === "saturation" || channel === "brightness") {
            value /= 100;
        }
        return new Intl.NumberFormat(locale, options).format(value);
    }
    getChannelRange(channel) {
        switch(channel){
            case "hue":
                return {
                    minValue: 0,
                    maxValue: 360,
                    step: 1,
                    pageSize: 15
                };
            case "saturation":
            case "brightness":
                return {
                    minValue: 0,
                    maxValue: 100,
                    step: 1,
                    pageSize: 10
                };
            case "alpha":
                return {
                    minValue: 0,
                    maxValue: 1,
                    step: 0.01,
                    pageSize: 0.1
                };
            default:
                throw new Error("Unknown color channel: " + channel);
        }
    }
    toJSON() {
        return {
            h: this.hue,
            s: this.saturation,
            b: this.brightness,
            a: this.alpha
        };
    }
    getFormat() {
        return "hsba";
    }
    getChannels() {
        return _HSBColor.colorChannels;
    }
};
__publicField(_HSBColor, "colorChannels", [
    "hue",
    "saturation",
    "brightness"
]);
var HSBColor = _HSBColor;
// src/native-color.ts
var nativeColors = "aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32";
var makeMap = (str)=>{
    const map = /* @__PURE__ */ new Map();
    const list = str.split(",");
    for(let i = 0; i < list.length; i++){
        const [key, val] = list[i].split(":");
        map.set(key, `#${val}`);
        if (key.includes("gray")) map.set(key.replace("gray", "grey"), `#${val}`);
    }
    return map;
};
var nativeColorMap = makeMap(nativeColors);
// src/parse-color.ts
var parseColor = (value)=>{
    if (nativeColorMap.has(value)) {
        return parseColor(nativeColorMap.get(value));
    }
    const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);
    if (!result) {
        const error = new Error("Invalid color value: " + value);
        Error.captureStackTrace?.(error, parseColor);
        throw error;
    }
    return result;
};
var normalizeColor = (v)=>{
    return typeof v === "string" ? parseColor(v) : v;
};
;
}}),
"[project]/node_modules/@zag-js/color-picker/dist/index.mjs [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "anatomy": (()=>anatomy),
    "connect": (()=>connect),
    "machine": (()=>machine),
    "parse": (()=>parse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/form-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dom-event/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/color-utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/popper/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@zag-js/core/dist/index.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/dismissable/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$text$2d$selection$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/text-selection/dist/index.mjs [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
// src/color-picker.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createAnatomy"])("color-picker", [
    "root",
    "label",
    "control",
    "trigger",
    "positioner",
    "content",
    "area",
    "areaThumb",
    "valueText",
    "areaBackground",
    "channelSlider",
    "channelSliderLabel",
    "channelSliderTrack",
    "channelSliderThumb",
    "channelSliderValueText",
    "channelInput",
    "transparencyGrid",
    "swatchGroup",
    "swatchTrigger",
    "swatchIndicator",
    "swatch",
    "eyeDropperTrigger",
    "formatTrigger",
    "formatSelect"
]);
var parts = anatomy.build();
var dom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createScope"])({
    getRootId: (ctx)=>ctx.ids?.root ?? `color-picker:${ctx.id}`,
    getLabelId: (ctx)=>ctx.ids?.label ?? `color-picker:${ctx.id}:label`,
    getHiddenInputId: (ctx)=>ctx.ids?.hiddenInput ?? `color-picker:${ctx.id}:hidden-input`,
    getControlId: (ctx)=>ctx.ids?.control ?? `color-picker:${ctx.id}:control`,
    getTriggerId: (ctx)=>ctx.ids?.trigger ?? `color-picker:${ctx.id}:trigger`,
    getContentId: (ctx)=>ctx.ids?.content ?? `color-picker:${ctx.id}:content`,
    getPositionerId: (ctx)=>ctx.ids?.positioner ?? `color-picker:${ctx.id}:positioner`,
    getFormatSelectId: (ctx)=>ctx.ids?.formatSelect ?? `color-picker:${ctx.id}:format-select`,
    getAreaId: (ctx)=>ctx.ids?.area ?? `color-picker:${ctx.id}:area`,
    getAreaGradientId: (ctx)=>ctx.ids?.areaGradient ?? `color-picker:${ctx.id}:area-gradient`,
    getAreaThumbId: (ctx)=>ctx.ids?.areaThumb ?? `color-picker:${ctx.id}:area-thumb`,
    getChannelSliderTrackId: (ctx, channel)=>ctx.ids?.channelSliderTrack?.(channel) ?? `color-picker:${ctx.id}:slider-track:${channel}`,
    getChannelSliderThumbId: (ctx, channel)=>ctx.ids?.channelSliderThumb?.(channel) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`,
    getContentEl: (ctx)=>dom.getById(ctx, dom.getContentId(ctx)),
    getAreaThumbEl: (ctx)=>dom.getById(ctx, dom.getAreaThumbId(ctx)),
    getChannelSliderThumbEl: (ctx, channel)=>dom.getById(ctx, dom.getChannelSliderThumbId(ctx, channel)),
    getChannelInputEl: (ctx, channel)=>{
        const selector = `input[data-channel="${channel}"]`;
        return [
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["queryAll"])(dom.getContentEl(ctx), selector),
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["queryAll"])(dom.getControlEl(ctx), selector)
        ];
    },
    getFormatSelectEl: (ctx)=>dom.getById(ctx, dom.getFormatSelectId(ctx)),
    getHiddenInputEl: (ctx)=>dom.getById(ctx, dom.getHiddenInputId(ctx)),
    getAreaEl: (ctx)=>dom.getById(ctx, dom.getAreaId(ctx)),
    getAreaValueFromPoint (ctx, point) {
        const areaEl = dom.getAreaEl(ctx);
        if (!areaEl) return;
        const { percent } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRelativePoint"])(point, areaEl);
        return percent;
    },
    getControlEl: (ctx)=>dom.getById(ctx, dom.getControlId(ctx)),
    getTriggerEl: (ctx)=>dom.getById(ctx, dom.getTriggerId(ctx)),
    getPositionerEl: (ctx)=>dom.getById(ctx, dom.getPositionerId(ctx)),
    getChannelSliderTrackEl: (ctx, channel)=>{
        return dom.getById(ctx, dom.getChannelSliderTrackId(ctx, channel));
    },
    getChannelSliderValueFromPoint (ctx, point, channel) {
        const trackEl = dom.getChannelSliderTrackEl(ctx, channel);
        if (!trackEl) return;
        const { percent } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRelativePoint"])(point, trackEl);
        return percent;
    },
    getChannelInputEls: (ctx)=>{
        return [
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["queryAll"])(dom.getContentEl(ctx), "input[data-channel]"),
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["queryAll"])(dom.getControlEl(ctx), "input[data-channel]")
        ];
    }
});
function getChannelDisplayColor(color, channel) {
    switch(channel){
        case "hue":
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseColor"])(`hsl(${color.getChannelValue("hue")}, 100%, 50%)`);
        case "lightness":
        case "brightness":
        case "saturation":
        case "red":
        case "green":
        case "blue":
            return color.withChannelValue("alpha", 1);
        case "alpha":
            {
                return color;
            }
        default:
            throw new Error("Unknown color channel: " + channel);
    }
}
function getChannelValue(color, channel) {
    if (channel == null) return "";
    if (channel === "hex") {
        return color.toString("hex");
    }
    if (channel === "css") {
        return color.toString("css");
    }
    if (channel in color) {
        return color.getChannelValue(channel).toString();
    }
    const isHSL = color.getFormat() === "hsla";
    switch(channel){
        case "hue":
            return isHSL ? color.toFormat("hsla").getChannelValue("hue").toString() : color.toFormat("hsba").getChannelValue("hue").toString();
        case "saturation":
            return isHSL ? color.toFormat("hsla").getChannelValue("saturation").toString() : color.toFormat("hsba").getChannelValue("saturation").toString();
        case "lightness":
            return color.toFormat("hsla").getChannelValue("lightness").toString();
        case "brightness":
            return color.toFormat("hsba").getChannelValue("brightness").toString();
        case "red":
        case "green":
        case "blue":
            return color.toFormat("rgba").getChannelValue(channel).toString();
        default:
            return color.getChannelValue(channel).toString();
    }
}
function getChannelRange(color, channel) {
    switch(channel){
        case "hex":
            const minColor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseColor"])("#000000");
            const maxColor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseColor"])("#FFFFFF");
            return {
                minValue: minColor.toHexInt(),
                maxValue: maxColor.toHexInt(),
                pageSize: 10,
                step: 1
            };
        case "css":
            return void 0;
        case "hue":
        case "saturation":
        case "lightness":
            return color.toFormat("hsla").getChannelRange(channel);
        case "brightness":
            return color.toFormat("hsba").getChannelRange(channel);
        case "red":
        case "green":
        case "blue":
            return color.toFormat("rgba").getChannelRange(channel);
        default:
            return color.getChannelRange(channel);
    }
}
// src/utils/get-slider-background.ts
function getSliderBackgroundDirection(orientation, dir) {
    if (orientation === "vertical") {
        return "top";
    } else if (dir === "ltr") {
        return "right";
    } else {
        return "left";
    }
}
var getSliderBackground = (props)=>{
    const { channel, value, dir, orientation } = props;
    const bgDirection = getSliderBackgroundDirection(orientation, dir);
    const { minValue, maxValue } = value.getChannelRange(channel);
    switch(channel){
        case "hue":
            return `linear-gradient(to ${bgDirection}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;
        case "lightness":
            {
                let start = value.withChannelValue(channel, minValue).toString("css");
                let middle = value.withChannelValue(channel, (maxValue - minValue) / 2).toString("css");
                let end = value.withChannelValue(channel, maxValue).toString("css");
                return `linear-gradient(to ${bgDirection}, ${start}, ${middle}, ${end})`;
            }
        case "saturation":
        case "brightness":
        case "red":
        case "green":
        case "blue":
        case "alpha":
            {
                let start = value.withChannelValue(channel, minValue).toString("css");
                let end = value.withChannelValue(channel, maxValue).toString("css");
                return `linear-gradient(to ${bgDirection}, ${start}, ${end})`;
            }
        default:
            throw new Error("Unknown color channel: " + channel);
    }
};
// src/color-picker.connect.ts
function connect(state, send, normalize) {
    const value = state.context.value;
    const areaValue = state.context.areaValue;
    const valueAsString = state.context.valueAsString;
    const disabled = state.context.isDisabled;
    const interactive = state.context.isInteractive;
    const dragging = state.hasTag("dragging");
    const open = state.hasTag("open");
    const focused = state.hasTag("focused");
    const getAreaChannels = (props)=>{
        const channels = areaValue.getChannels();
        return {
            xChannel: props.xChannel ?? channels[1],
            yChannel: props.yChannel ?? channels[2]
        };
    };
    const currentPlacement = state.context.currentPlacement;
    const popperStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacementStyles"])({
        ...state.context.positioning,
        placement: currentPlacement
    });
    function getSwatchTriggerState(props) {
        const color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeColor"])(props.value).toFormat(state.context.format);
        return {
            value: color,
            valueAsString: color.toString("hex"),
            checked: color.isEqual(value),
            disabled: props.disabled || !interactive
        };
    }
    return {
        dragging,
        open,
        valueAsString,
        value,
        setOpen (nextOpen) {
            if (nextOpen === open) return;
            send({
                type: nextOpen ? "OPEN" : "CLOSE"
            });
        },
        setValue (value2) {
            send({
                type: "VALUE.SET",
                value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeColor"])(value2),
                src: "set-color"
            });
        },
        getChannelValue (channel) {
            return getChannelValue(value, channel);
        },
        getChannelValueText (channel, locale) {
            return value.formatChannelValue(channel, locale);
        },
        setChannelValue (channel, channelValue) {
            const color = value.withChannelValue(channel, channelValue);
            send({
                type: "VALUE.SET",
                value: color,
                src: "set-channel"
            });
        },
        format: state.context.format,
        setFormat (format) {
            const formatValue = value.toFormat(format);
            send({
                type: "VALUE.SET",
                value: formatValue,
                src: "set-format"
            });
        },
        alpha: value.getChannelValue("alpha"),
        setAlpha (alphaValue) {
            const color = value.withChannelValue("alpha", alphaValue);
            send({
                type: "VALUE.SET",
                value: color,
                src: "set-alpha"
            });
        },
        getRootProps () {
            return normalize.element({
                ...parts.root.attrs,
                dir: state.context.dir,
                id: dom.getRootId(state.context),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.readOnly),
                style: {
                    "--value": value.toString("css")
                }
            });
        },
        getLabelProps () {
            return normalize.element({
                ...parts.label.attrs,
                dir: state.context.dir,
                id: dom.getLabelId(state.context),
                htmlFor: dom.getHiddenInputId(state.context),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.readOnly),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                onClick (event) {
                    event.preventDefault();
                    const inputEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["query"])(dom.getControlEl(state.context), "[data-channel=hex]");
                    inputEl?.focus({
                        preventScroll: true
                    });
                }
            });
        },
        getControlProps () {
            return normalize.element({
                ...parts.control.attrs,
                id: dom.getControlId(state.context),
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.readOnly),
                "data-state": open ? "open" : "closed",
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused)
            });
        },
        getTriggerProps () {
            return normalize.button({
                ...parts.trigger.attrs,
                id: dom.getTriggerId(state.context),
                dir: state.context.dir,
                disabled,
                "aria-label": `select color. current color is ${valueAsString}`,
                "aria-controls": dom.getContentId(state.context),
                "aria-labelledby": dom.getLabelId(state.context),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-readonly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(state.context.readOnly),
                "data-placement": currentPlacement,
                "aria-expanded": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(open),
                "data-state": open ? "open" : "closed",
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused),
                type: "button",
                onClick () {
                    if (!interactive) return;
                    send({
                        type: "TRIGGER.CLICK"
                    });
                },
                onBlur () {
                    if (!interactive) return;
                    send({
                        type: "TRIGGER.BLUR"
                    });
                },
                style: {
                    position: "relative"
                }
            });
        },
        getPositionerProps () {
            return normalize.element({
                ...parts.positioner.attrs,
                id: dom.getPositionerId(state.context),
                dir: state.context.dir,
                style: popperStyles.floating
            });
        },
        getContentProps () {
            return normalize.element({
                ...parts.content.attrs,
                id: dom.getContentId(state.context),
                dir: state.context.dir,
                "data-placement": currentPlacement,
                "data-state": open ? "open" : "closed",
                hidden: !open
            });
        },
        getValueTextProps () {
            return normalize.element({
                ...parts.valueText.attrs,
                dir: state.context.dir,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-focus": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(focused)
            });
        },
        getAreaProps (props = {}) {
            const { xChannel, yChannel } = getAreaChannels(props);
            const { areaStyles } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getColorAreaGradient"])(areaValue, {
                xChannel,
                yChannel,
                dir: state.context.dir
            });
            return normalize.element({
                ...parts.area.attrs,
                id: dom.getAreaId(state.context),
                role: "group",
                onPointerDown (event) {
                    if (!interactive) return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLeftClick"])(event)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isModifierKey"])(event)) return;
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    const channel = {
                        xChannel,
                        yChannel
                    };
                    send({
                        type: "AREA.POINTER_DOWN",
                        point,
                        channel,
                        id: "area"
                    });
                    event.preventDefault();
                },
                style: {
                    position: "relative",
                    touchAction: "none",
                    forcedColorAdjust: "none",
                    ...areaStyles
                }
            });
        },
        getAreaBackgroundProps (props = {}) {
            const { xChannel, yChannel } = getAreaChannels(props);
            const { areaGradientStyles } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getColorAreaGradient"])(areaValue, {
                xChannel,
                yChannel,
                dir: state.context.dir
            });
            return normalize.element({
                ...parts.areaBackground.attrs,
                id: dom.getAreaGradientId(state.context),
                style: {
                    position: "relative",
                    touchAction: "none",
                    forcedColorAdjust: "none",
                    ...areaGradientStyles
                }
            });
        },
        getAreaThumbProps (props = {}) {
            const { xChannel, yChannel } = getAreaChannels(props);
            const channel = {
                xChannel,
                yChannel
            };
            const xPercent = areaValue.getChannelValuePercent(xChannel);
            const yPercent = 1 - areaValue.getChannelValuePercent(yChannel);
            const xValue = areaValue.getChannelValue(xChannel);
            const yValue = areaValue.getChannelValue(yChannel);
            return normalize.element({
                ...parts.areaThumb.attrs,
                id: dom.getAreaThumbId(state.context),
                dir: state.context.dir,
                tabIndex: disabled ? void 0 : 0,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                role: "slider",
                "aria-valuemin": 0,
                "aria-valuemax": 100,
                "aria-valuenow": xValue,
                "aria-label": `${xChannel} and ${yChannel}`,
                "aria-roledescription": "2d slider",
                "aria-valuetext": `${xChannel} ${xValue}, ${yChannel} ${yValue}`,
                style: {
                    position: "absolute",
                    left: `${xPercent * 100}%`,
                    top: `${yPercent * 100}%`,
                    transform: "translate(-50%, -50%)",
                    touchAction: "none",
                    forcedColorAdjust: "none",
                    background: areaValue.withChannelValue("alpha", 1).toString("css")
                },
                onFocus () {
                    if (!interactive) return;
                    send({
                        type: "AREA.FOCUS",
                        id: "area",
                        channel
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    const step = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventStep"])(event);
                    const keyMap = {
                        ArrowUp () {
                            send({
                                type: "AREA.ARROW_UP",
                                channel,
                                step
                            });
                        },
                        ArrowDown () {
                            send({
                                type: "AREA.ARROW_DOWN",
                                channel,
                                step
                            });
                        },
                        ArrowLeft () {
                            send({
                                type: "AREA.ARROW_LEFT",
                                channel,
                                step
                            });
                        },
                        ArrowRight () {
                            send({
                                type: "AREA.ARROW_RIGHT",
                                channel,
                                step
                            });
                        },
                        PageUp () {
                            send({
                                type: "AREA.PAGE_UP",
                                channel,
                                step
                            });
                        },
                        PageDown () {
                            send({
                                type: "AREA.PAGE_DOWN",
                                channel,
                                step
                            });
                        },
                        Escape (event2) {
                            event2.stopPropagation();
                        }
                    };
                    const exec = keyMap[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventKey"])(event, state.context)];
                    if (exec) {
                        exec(event);
                        event.preventDefault();
                    }
                }
            });
        },
        getTransparencyGridProps (props = {}) {
            const { size = "12px" } = props;
            return normalize.element({
                ...parts.transparencyGrid.attrs,
                style: {
                    "--size": size,
                    width: "100%",
                    height: "100%",
                    position: "absolute",
                    backgroundColor: "#fff",
                    backgroundImage: "conic-gradient(#eeeeee 0 25%, transparent 0 50%, #eeeeee 0 75%, transparent 0)",
                    backgroundSize: "var(--size) var(--size)",
                    inset: "0px",
                    zIndex: "auto",
                    pointerEvents: "none"
                }
            });
        },
        getChannelSliderProps (props) {
            const { orientation = "horizontal", channel, format } = props;
            return normalize.element({
                ...parts.channelSlider.attrs,
                "data-channel": channel,
                "data-orientation": orientation,
                role: "presentation",
                onPointerDown (event) {
                    if (!interactive) return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLeftClick"])(event)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isModifierKey"])(event)) return;
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    send({
                        type: "CHANNEL_SLIDER.POINTER_DOWN",
                        channel,
                        format,
                        point,
                        id: channel,
                        orientation
                    });
                    event.preventDefault();
                },
                style: {
                    position: "relative",
                    touchAction: "none"
                }
            });
        },
        getChannelSliderTrackProps (props) {
            const { orientation = "horizontal", channel, format } = props;
            const normalizedValue = format ? value.toFormat(format) : areaValue;
            return normalize.element({
                ...parts.channelSliderTrack.attrs,
                id: dom.getChannelSliderTrackId(state.context, channel),
                role: "group",
                "data-channel": channel,
                "data-orientation": orientation,
                style: {
                    position: "relative",
                    forcedColorAdjust: "none",
                    backgroundImage: getSliderBackground({
                        orientation,
                        channel,
                        dir: state.context.dir,
                        value: normalizedValue
                    })
                }
            });
        },
        getChannelSliderLabelProps (props) {
            const { channel } = props;
            return normalize.element({
                ...parts.channelSliderLabel.attrs,
                "data-channel": channel,
                onClick (event) {
                    if (!interactive) return;
                    event.preventDefault();
                    const thumbId = dom.getChannelSliderThumbId(state.context, channel);
                    dom.getById(state.context, thumbId)?.focus({
                        preventScroll: true
                    });
                },
                style: {
                    userSelect: "none",
                    WebkitUserSelect: "none"
                }
            });
        },
        getChannelSliderValueTextProps (props) {
            return normalize.element({
                ...parts.channelSliderValueText.attrs,
                "data-channel": props.channel
            });
        },
        getChannelSliderThumbProps (props) {
            const { orientation = "horizontal", channel, format } = props;
            const normalizedValue = format ? value.toFormat(format) : areaValue;
            const channelRange = normalizedValue.getChannelRange(channel);
            const channelValue = normalizedValue.getChannelValue(channel);
            const offset = (channelValue - channelRange.minValue) / (channelRange.maxValue - channelRange.minValue);
            const placementStyles = orientation === "horizontal" ? {
                left: `${offset * 100}%`,
                top: "50%"
            } : {
                top: `${offset * 100}%`,
                left: "50%"
            };
            return normalize.element({
                ...parts.channelSliderThumb.attrs,
                id: dom.getChannelSliderThumbId(state.context, channel),
                role: "slider",
                "aria-label": channel,
                tabIndex: disabled ? void 0 : 0,
                "data-channel": channel,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "data-orientation": orientation,
                "aria-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "aria-orientation": orientation,
                "aria-valuemax": channelRange.maxValue,
                "aria-valuemin": channelRange.minValue,
                "aria-valuenow": channelValue,
                "aria-valuetext": `${channel} ${channelValue}`,
                style: {
                    forcedColorAdjust: "none",
                    position: "absolute",
                    background: getChannelDisplayColor(areaValue, channel).toString("css"),
                    ...placementStyles
                },
                onFocus () {
                    if (!interactive) return;
                    send({
                        type: "CHANNEL_SLIDER.FOCUS",
                        channel
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    const step = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventStep"])(event) * channelRange.step;
                    const keyMap = {
                        ArrowUp () {
                            send({
                                type: "CHANNEL_SLIDER.ARROW_UP",
                                channel,
                                step
                            });
                        },
                        ArrowDown () {
                            send({
                                type: "CHANNEL_SLIDER.ARROW_DOWN",
                                channel,
                                step
                            });
                        },
                        ArrowLeft () {
                            send({
                                type: "CHANNEL_SLIDER.ARROW_LEFT",
                                channel,
                                step
                            });
                        },
                        ArrowRight () {
                            send({
                                type: "CHANNEL_SLIDER.ARROW_RIGHT",
                                channel,
                                step
                            });
                        },
                        PageUp () {
                            send({
                                type: "CHANNEL_SLIDER.PAGE_UP",
                                channel
                            });
                        },
                        PageDown () {
                            send({
                                type: "CHANNEL_SLIDER.PAGE_DOWN",
                                channel
                            });
                        },
                        Home () {
                            send({
                                type: "CHANNEL_SLIDER.HOME",
                                channel
                            });
                        },
                        End () {
                            send({
                                type: "CHANNEL_SLIDER.END",
                                channel
                            });
                        },
                        Escape (event2) {
                            event2.stopPropagation();
                        }
                    };
                    const exec = keyMap[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEventKey"])(event, state.context)];
                    if (exec) {
                        exec(event);
                        event.preventDefault();
                    }
                }
            });
        },
        getChannelInputProps (props) {
            const { channel } = props;
            const isTextField = channel === "hex" || channel === "css";
            const channelRange = getChannelRange(value, channel);
            return normalize.input({
                ...parts.channelInput.attrs,
                dir: state.context.dir,
                type: isTextField ? "text" : "number",
                "data-channel": channel,
                "aria-label": channel,
                spellCheck: false,
                autoComplete: "off",
                disabled,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                readOnly: state.context.readOnly,
                defaultValue: getChannelValue(value, channel),
                min: channelRange?.minValue,
                max: channelRange?.maxValue,
                step: channelRange?.step,
                onBeforeInput (event) {
                    if (isTextField || !interactive) return;
                    const value2 = event.currentTarget.value;
                    if (value2.match(/[^0-9.]/g)) {
                        event.preventDefault();
                    }
                },
                onFocus (event) {
                    if (!interactive) return;
                    send({
                        type: "CHANNEL_INPUT.FOCUS",
                        channel
                    });
                    event.currentTarget.select();
                },
                onBlur (event) {
                    if (!interactive) return;
                    const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
                    send({
                        type: "CHANNEL_INPUT.BLUR",
                        channel,
                        value: value2,
                        isTextField
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (!interactive) return;
                    if (event.key === "Enter") {
                        const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
                        send({
                            type: "CHANNEL_INPUT.CHANGE",
                            channel,
                            value: value2,
                            isTextField
                        });
                        event.preventDefault();
                    }
                },
                style: {
                    appearance: "none",
                    WebkitAppearance: "none",
                    MozAppearance: "textfield"
                }
            });
        },
        getHiddenInputProps () {
            return normalize.input({
                type: "text",
                disabled,
                name: state.context.name,
                readOnly: state.context.readOnly,
                required: state.context.required,
                id: dom.getHiddenInputId(state.context),
                style: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["visuallyHiddenStyle"],
                defaultValue: valueAsString
            });
        },
        getEyeDropperTriggerProps () {
            return normalize.button({
                ...parts.eyeDropperTrigger.attrs,
                type: "button",
                dir: state.context.dir,
                disabled,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(disabled),
                "aria-label": "Pick a color from the screen",
                onClick () {
                    if (!interactive) return;
                    send("EYEDROPPER.CLICK");
                }
            });
        },
        getSwatchGroupProps () {
            return normalize.element({
                ...parts.swatchGroup.attrs,
                role: "group"
            });
        },
        getSwatchTriggerState,
        getSwatchTriggerProps (props) {
            const swatchState = getSwatchTriggerState(props);
            return normalize.button({
                ...parts.swatchTrigger.attrs,
                disabled: swatchState.disabled,
                dir: state.context.dir,
                type: "button",
                "aria-label": `select ${swatchState.valueAsString} as the color`,
                "data-state": swatchState.checked ? "checked" : "unchecked",
                "data-value": swatchState.valueAsString,
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dataAttr"])(swatchState.disabled),
                onClick () {
                    if (swatchState.disabled) return;
                    send({
                        type: "SWATCH_TRIGGER.CLICK",
                        value: swatchState.value
                    });
                },
                style: {
                    "--color": swatchState.valueAsString,
                    position: "relative"
                }
            });
        },
        getSwatchIndicatorProps (props) {
            const swatchState = getSwatchTriggerState(props);
            return normalize.element({
                ...parts.swatchIndicator.attrs,
                dir: state.context.dir,
                hidden: !swatchState.checked
            });
        },
        getSwatchProps (props) {
            const { respectAlpha = true } = props;
            const swatchState = getSwatchTriggerState(props);
            const color = swatchState.value.toString(respectAlpha ? "css" : "hex");
            return normalize.element({
                ...parts.swatch.attrs,
                dir: state.context.dir,
                "data-state": swatchState.checked ? "checked" : "unchecked",
                "data-value": swatchState.valueAsString,
                style: {
                    "--color": color,
                    position: "relative",
                    background: color
                }
            });
        },
        getFormatTriggerProps () {
            return normalize.button({
                ...parts.formatTrigger.attrs,
                dir: state.context.dir,
                type: "button",
                "aria-label": `change color format to ${getNextFormat(state.context.format)}`,
                onClick (event) {
                    if (event.currentTarget.disabled) return;
                    const nextFormat = getNextFormat(state.context.format);
                    send({
                        type: "FORMAT.SET",
                        format: nextFormat,
                        src: "format-trigger"
                    });
                }
            });
        },
        getFormatSelectProps () {
            return normalize.select({
                ...parts.formatSelect.attrs,
                "aria-label": "change color format",
                dir: state.context.dir,
                defaultValue: state.context.format,
                disabled,
                onChange (event) {
                    const format = assertFormat(event.currentTarget.value);
                    send({
                        type: "FORMAT.SET",
                        format,
                        src: "format-select"
                    });
                }
            });
        }
    };
}
var formats = [
    "hsba",
    "hsla",
    "rgba"
];
var formatRegex = new RegExp(`^(${formats.join("|")})$`);
function getNextFormat(format) {
    const index = formats.indexOf(format);
    return formats[index + 1] ?? formats[0];
}
function assertFormat(format) {
    if (formatRegex.test(format)) return format;
    throw new Error(`Unsupported color format: ${format}`);
}
var parse = (colorString)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseColor"])(colorString);
};
// src/color-picker.machine.ts
var { and } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["guards"];
function machine(userContext) {
    const ctx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"])(userContext);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createMachine"])({
        id: "color-picker",
        initial: ctx.open ? "open" : "idle",
        context: {
            dir: "ltr",
            value: parse("#000000"),
            format: "rgba",
            disabled: false,
            closeOnSelect: false,
            ...ctx,
            activeId: null,
            activeChannel: null,
            activeOrientation: null,
            fieldsetDisabled: false,
            restoreFocus: true,
            positioning: {
                ...ctx.positioning,
                placement: "bottom"
            }
        },
        computed: {
            isRtl: (ctx2)=>ctx2.dir === "rtl",
            isDisabled: (ctx2)=>!!ctx2.disabled || ctx2.fieldsetDisabled,
            isInteractive: (ctx2)=>!(ctx2.isDisabled || ctx2.readOnly),
            valueAsString: (ctx2)=>ctx2.value.toString(ctx2.format),
            areaValue: (ctx2)=>{
                const format = ctx2.format.startsWith("hsl") ? "hsla" : "hsba";
                return ctx2.value.toFormat(format);
            }
        },
        activities: [
            "trackFormControl"
        ],
        watch: {
            value: [
                "syncInputElements"
            ],
            format: [
                "syncFormatSelectElement"
            ],
            open: [
                "toggleVisibility"
            ]
        },
        on: {
            "VALUE.SET": {
                actions: [
                    "setValue"
                ]
            },
            "FORMAT.SET": {
                actions: [
                    "setFormat"
                ]
            },
            "CHANNEL_INPUT.CHANGE": {
                actions: [
                    "setChannelColorFromInput"
                ]
            },
            "EYEDROPPER.CLICK": {
                actions: [
                    "openEyeDropper"
                ]
            },
            "SWATCH_TRIGGER.CLICK": {
                actions: [
                    "setValue"
                ]
            }
        },
        states: {
            idle: {
                tags: [
                    "closed"
                ],
                on: {
                    "CONTROLLED.OPEN": {
                        target: "open",
                        actions: [
                            "setInitialFocus"
                        ]
                    },
                    OPEN: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen",
                                "setInitialFocus"
                            ]
                        }
                    ],
                    "TRIGGER.CLICK": [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen",
                                "setInitialFocus"
                            ]
                        }
                    ],
                    "CHANNEL_INPUT.FOCUS": {
                        target: "focused",
                        actions: [
                            "setActiveChannel"
                        ]
                    }
                }
            },
            focused: {
                tags: [
                    "closed",
                    "focused"
                ],
                on: {
                    "CONTROLLED.OPEN": {
                        target: "open",
                        actions: [
                            "setInitialFocus"
                        ]
                    },
                    OPEN: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen",
                                "setInitialFocus"
                            ]
                        }
                    ],
                    "TRIGGER.CLICK": [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnOpen"
                            ]
                        },
                        {
                            target: "open",
                            actions: [
                                "invokeOnOpen",
                                "setInitialFocus"
                            ]
                        }
                    ],
                    "CHANNEL_INPUT.FOCUS": {
                        actions: [
                            "setActiveChannel"
                        ]
                    },
                    "CHANNEL_INPUT.BLUR": {
                        target: "idle",
                        actions: [
                            "setChannelColorFromInput"
                        ]
                    },
                    "TRIGGER.BLUR": {
                        target: "idle"
                    }
                }
            },
            open: {
                tags: [
                    "open"
                ],
                activities: [
                    "trackPositioning",
                    "trackDismissableElement"
                ],
                on: {
                    "CONTROLLED.CLOSE": [
                        {
                            guard: "shouldRestoreFocus",
                            target: "focused",
                            actions: [
                                "setReturnFocus"
                            ]
                        },
                        {
                            target: "idle"
                        }
                    ],
                    "TRIGGER.CLICK": [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "idle",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    "AREA.POINTER_DOWN": {
                        target: "open:dragging",
                        actions: [
                            "setActiveChannel",
                            "setAreaColorFromPoint",
                            "focusAreaThumb"
                        ]
                    },
                    "AREA.FOCUS": {
                        actions: [
                            "setActiveChannel"
                        ]
                    },
                    "CHANNEL_SLIDER.POINTER_DOWN": {
                        target: "open:dragging",
                        actions: [
                            "setActiveChannel",
                            "setChannelColorFromPoint",
                            "focusChannelThumb"
                        ]
                    },
                    "CHANNEL_SLIDER.FOCUS": {
                        actions: [
                            "setActiveChannel"
                        ]
                    },
                    "AREA.ARROW_LEFT": {
                        actions: [
                            "decrementAreaXChannel"
                        ]
                    },
                    "AREA.ARROW_RIGHT": {
                        actions: [
                            "incrementAreaXChannel"
                        ]
                    },
                    "AREA.ARROW_UP": {
                        actions: [
                            "incrementAreaYChannel"
                        ]
                    },
                    "AREA.ARROW_DOWN": {
                        actions: [
                            "decrementAreaYChannel"
                        ]
                    },
                    "AREA.PAGE_UP": {
                        actions: [
                            "incrementAreaXChannel"
                        ]
                    },
                    "AREA.PAGE_DOWN": {
                        actions: [
                            "decrementAreaXChannel"
                        ]
                    },
                    "CHANNEL_SLIDER.ARROW_LEFT": {
                        actions: [
                            "decrementChannel"
                        ]
                    },
                    "CHANNEL_SLIDER.ARROW_RIGHT": {
                        actions: [
                            "incrementChannel"
                        ]
                    },
                    "CHANNEL_SLIDER.ARROW_UP": {
                        actions: [
                            "incrementChannel"
                        ]
                    },
                    "CHANNEL_SLIDER.ARROW_DOWN": {
                        actions: [
                            "decrementChannel"
                        ]
                    },
                    "CHANNEL_SLIDER.PAGE_UP": {
                        actions: [
                            "incrementChannel"
                        ]
                    },
                    "CHANNEL_SLIDER.PAGE_DOWN": {
                        actions: [
                            "decrementChannel"
                        ]
                    },
                    "CHANNEL_SLIDER.HOME": {
                        actions: [
                            "setChannelToMin"
                        ]
                    },
                    "CHANNEL_SLIDER.END": {
                        actions: [
                            "setChannelToMax"
                        ]
                    },
                    "CHANNEL_INPUT.BLUR": {
                        actions: [
                            "setChannelColorFromInput"
                        ]
                    },
                    INTERACT_OUTSIDE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            guard: "shouldRestoreFocus",
                            target: "focused",
                            actions: [
                                "invokeOnClose",
                                "setReturnFocus"
                            ]
                        },
                        {
                            target: "idle",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    CLOSE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "idle",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    "SWATCH_TRIGGER.CLICK": [
                        {
                            guard: and("isOpenControlled", "closeOnSelect"),
                            actions: [
                                "setValue",
                                "invokeOnClose"
                            ]
                        },
                        {
                            guard: "closeOnSelect",
                            target: "focused",
                            actions: [
                                "setValue",
                                "invokeOnClose",
                                "setReturnFocus"
                            ]
                        },
                        {
                            actions: [
                                "setValue"
                            ]
                        }
                    ]
                }
            },
            "open:dragging": {
                tags: [
                    "open"
                ],
                exit: [
                    "clearActiveChannel"
                ],
                activities: [
                    "trackPointerMove",
                    "disableTextSelection",
                    "trackPositioning",
                    "trackDismissableElement"
                ],
                on: {
                    "CONTROLLED.CLOSE": [
                        {
                            guard: "shouldRestoreFocus",
                            target: "focused",
                            actions: [
                                "setReturnFocus"
                            ]
                        },
                        {
                            target: "idle"
                        }
                    ],
                    "AREA.POINTER_MOVE": {
                        actions: [
                            "setAreaColorFromPoint",
                            "focusAreaThumb"
                        ]
                    },
                    "AREA.POINTER_UP": {
                        target: "open",
                        actions: [
                            "invokeOnChangeEnd"
                        ]
                    },
                    "CHANNEL_SLIDER.POINTER_MOVE": {
                        actions: [
                            "setChannelColorFromPoint",
                            "focusChannelThumb"
                        ]
                    },
                    "CHANNEL_SLIDER.POINTER_UP": {
                        target: "open",
                        actions: [
                            "invokeOnChangeEnd"
                        ]
                    },
                    INTERACT_OUTSIDE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            guard: "shouldRestoreFocus",
                            target: "focused",
                            actions: [
                                "invokeOnClose",
                                "setReturnFocus"
                            ]
                        },
                        {
                            target: "idle",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ],
                    CLOSE: [
                        {
                            guard: "isOpenControlled",
                            actions: [
                                "invokeOnClose"
                            ]
                        },
                        {
                            target: "idle",
                            actions: [
                                "invokeOnClose"
                            ]
                        }
                    ]
                }
            }
        }
    }, {
        guards: {
            closeOnSelect: (ctx2)=>!!ctx2.closeOnSelect,
            isOpenControlled: (ctx2)=>!!ctx2["open.controlled"],
            shouldRestoreFocus: (ctx2)=>!!ctx2.restoreFocus
        },
        activities: {
            trackPositioning (ctx2) {
                ctx2.currentPlacement = ctx2.positioning.placement;
                const anchorEl = dom.getTriggerEl(ctx2);
                const getPositionerEl = ()=>dom.getPositionerEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getPlacement"])(anchorEl, getPositionerEl, {
                    ...ctx2.positioning,
                    defer: true,
                    onComplete (data) {
                        ctx2.currentPlacement = data.placement;
                    }
                });
            },
            trackDismissableElement (ctx2, _evt, { send }) {
                const getContentEl = ()=>dom.getContentEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackDismissableElement"])(getContentEl, {
                    exclude: dom.getTriggerEl(ctx2),
                    defer: true,
                    onInteractOutside (event) {
                        ctx2.onInteractOutside?.(event);
                        if (event.defaultPrevented) return;
                        ctx2.restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
                    },
                    onPointerDownOutside: ctx2.onPointerDownOutside,
                    onFocusOutside: ctx2.onFocusOutside,
                    onDismiss () {
                        send({
                            type: "INTERACT_OUTSIDE"
                        });
                    }
                });
            },
            trackFormControl (ctx2, _evt, { send, initialContext }) {
                const inputEl = dom.getHiddenInputEl(ctx2);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackFormControl"])(inputEl, {
                    onFieldsetDisabledChange (disabled) {
                        ctx2.fieldsetDisabled = disabled;
                    },
                    onFormReset () {
                        send({
                            type: "VALUE.SET",
                            value: initialContext.value,
                            src: "form.reset"
                        });
                    }
                });
            },
            trackPointerMove (ctx2, evt, { send }) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$event$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["trackPointerMove"])(dom.getDoc(ctx2), {
                    onPointerMove ({ point }) {
                        const type = ctx2.activeId === "area" ? "AREA.POINTER_MOVE" : "CHANNEL_SLIDER.POINTER_MOVE";
                        send({
                            type,
                            point,
                            format: evt.format
                        });
                    },
                    onPointerUp () {
                        const type = ctx2.activeId === "area" ? "AREA.POINTER_UP" : "CHANNEL_SLIDER.POINTER_UP";
                        send({
                            type
                        });
                    }
                });
            },
            disableTextSelection (ctx2) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$text$2d$selection$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["disableTextSelection"])({
                    doc: dom.getDoc(ctx2),
                    target: dom.getContentEl(ctx2)
                });
            }
        },
        actions: {
            openEyeDropper (ctx2) {
                const isSupported = "EyeDropper" in dom.getWin(ctx2);
                if (!isSupported) return;
                const win = dom.getWin(ctx2);
                const picker = new win.EyeDropper();
                picker.open().then(({ sRGBHex })=>{
                    const format = ctx2.value.getFormat();
                    const color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseColor"])(sRGBHex).toFormat(format);
                    set.value(ctx2, color);
                    ctx2.onValueChangeEnd?.({
                        value: ctx2.value,
                        valueAsString: ctx2.valueAsString
                    });
                }).catch(()=>void 0);
            },
            setActiveChannel (ctx2, evt) {
                ctx2.activeId = evt.id;
                if (evt.channel) ctx2.activeChannel = evt.channel;
                if (evt.orientation) ctx2.activeOrientation = evt.orientation;
            },
            clearActiveChannel (ctx2) {
                ctx2.activeChannel = null;
                ctx2.activeId = null;
                ctx2.activeOrientation = null;
            },
            setAreaColorFromPoint (ctx2, evt) {
                const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;
                const { xChannel, yChannel } = evt.channel || ctx2.activeChannel;
                const percent = dom.getAreaValueFromPoint(ctx2, evt.point);
                if (!percent) return;
                const xValue = normalizedValue.getChannelPercentValue(xChannel, percent.x);
                const yValue = normalizedValue.getChannelPercentValue(yChannel, 1 - percent.y);
                const color = normalizedValue.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue);
                set.value(ctx2, color);
            },
            setChannelColorFromPoint (ctx2, evt) {
                const channel = evt.channel || ctx2.activeId;
                const normalizedValue = evt.format ? ctx2.value.toFormat(evt.format) : ctx2.areaValue;
                const percent = dom.getChannelSliderValueFromPoint(ctx2, evt.point, channel);
                if (!percent) return;
                const orientation = ctx2.activeOrientation || "horizontal";
                const channelPercent = orientation === "horizontal" ? percent.x : percent.y;
                const value = normalizedValue.getChannelPercentValue(channel, channelPercent);
                const color = normalizedValue.withChannelValue(channel, value);
                set.value(ctx2, color);
            },
            setValue (ctx2, evt) {
                set.value(ctx2, evt.value);
            },
            setFormat (ctx2, evt) {
                set.format(ctx2, evt.format);
            },
            syncInputElements (ctx2) {
                sync.inputs(ctx2);
            },
            invokeOnChangeEnd (ctx2) {
                invoke.changeEnd(ctx2);
            },
            setChannelColorFromInput (ctx2, evt) {
                const { channel, isTextField, value } = evt;
                const currentAlpha = ctx2.value.getChannelValue("alpha");
                let color;
                if (channel === "alpha") {
                    let valueAsNumber = parseFloat(value);
                    valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber;
                    color = ctx2.value.withChannelValue("alpha", valueAsNumber);
                } else if (isTextField) {
                    color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["tryCatch"])(()=>parse(value).withChannelValue("alpha", currentAlpha), ()=>ctx2.value);
                } else {
                    const current = ctx2.value.toFormat(ctx2.format);
                    const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value;
                    color = current.withChannelValue(channel, valueAsNumber);
                }
                sync.inputs(ctx2, color);
                set.value(ctx2, color);
            },
            incrementChannel (ctx2, evt) {
                const color = ctx2.value.incrementChannel(evt.channel, evt.step);
                set.value(ctx2, color);
            },
            decrementChannel (ctx2, evt) {
                const color = ctx2.value.decrementChannel(evt.channel, evt.step);
                set.value(ctx2, color);
            },
            incrementAreaXChannel (ctx2, evt) {
                const { xChannel } = evt.channel;
                const color = ctx2.areaValue.incrementChannel(xChannel, evt.step);
                set.value(ctx2, color);
            },
            decrementAreaXChannel (ctx2, evt) {
                const { xChannel } = evt.channel;
                const color = ctx2.areaValue.decrementChannel(xChannel, evt.step);
                set.value(ctx2, color);
            },
            incrementAreaYChannel (ctx2, evt) {
                const { yChannel } = evt.channel;
                const color = ctx2.areaValue.incrementChannel(yChannel, evt.step);
                set.value(ctx2, color);
            },
            decrementAreaYChannel (ctx2, evt) {
                const { yChannel } = evt.channel;
                const color = ctx2.areaValue.decrementChannel(yChannel, evt.step);
                set.value(ctx2, color);
            },
            setChannelToMax (ctx2, evt) {
                const range = ctx2.value.getChannelRange(evt.channel);
                const color = ctx2.value.withChannelValue(evt.channel, range.maxValue);
                set.value(ctx2, color);
            },
            setChannelToMin (ctx2, evt) {
                const range = ctx2.value.getChannelRange(evt.channel);
                const color = ctx2.value.withChannelValue(evt.channel, range.minValue);
                set.value(ctx2, color);
            },
            focusAreaThumb (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    dom.getAreaThumbEl(ctx2)?.focus({
                        preventScroll: true
                    });
                });
            },
            focusChannelThumb (ctx2, evt) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    dom.getChannelSliderThumbEl(ctx2, evt.channel)?.focus({
                        preventScroll: true
                    });
                });
            },
            setInitialFocus (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getInitialFocus"])({
                        root: dom.getContentEl(ctx2),
                        getInitialEl: ctx2.initialFocusEl
                    });
                    element?.focus({
                        preventScroll: true
                    });
                });
            },
            setReturnFocus (ctx2) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    dom.getTriggerEl(ctx2)?.focus({
                        preventScroll: true
                    });
                });
            },
            syncFormatSelectElement (ctx2) {
                sync.formatSelect(ctx2);
            },
            invokeOnOpen (ctx2) {
                ctx2.onOpenChange?.({
                    open: true
                });
            },
            invokeOnClose (ctx2) {
                ctx2.onOpenChange?.({
                    open: false
                });
            },
            toggleVisibility (ctx2, evt, { send }) {
                send({
                    type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
                    previousEvent: evt
                });
            }
        },
        compareFns: {
            value: (a, b)=>a.isEqual(b)
        }
    });
}
var sync = {
    // sync channel inputs
    inputs (ctx, color) {
        const channelInputs = dom.getChannelInputEls(ctx);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
            channelInputs.forEach((inputEl)=>{
                const channel = inputEl.dataset.channel;
                dom.setValue(inputEl, getChannelValue(color || ctx.value, channel));
            });
        });
    },
    // sync format select
    formatSelect (ctx) {
        const selectEl = dom.getFormatSelectEl(ctx);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["raf"])(()=>{
            dom.setValue(selectEl, ctx.format);
        });
    }
};
var invoke = {
    changeEnd (ctx) {
        const value = ctx.value.toFormat(ctx.format);
        ctx.onValueChangeEnd?.({
            value,
            valueAsString: ctx.valueAsString
        });
    },
    change (ctx) {
        const value = ctx.value.toFormat(ctx.format);
        ctx.onValueChange?.({
            value,
            valueAsString: ctx.valueAsString
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$form$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dispatchInputValueEvent"])(dom.getHiddenInputEl(ctx), {
            value: ctx.valueAsString
        });
    },
    formatChange (ctx) {
        ctx.onFormatChange?.({
            format: ctx.format
        });
    }
};
var set = {
    value (ctx, color) {
        if (!color || ctx.value.isEqual(color)) return;
        ctx.value = color;
        invoke.change(ctx);
    },
    format (ctx, format) {
        if (ctx.format === format) return;
        ctx.format = format;
        invoke.formatChange(ctx);
    }
};
;
}}),
"[project]/node_modules/@zag-js/color-picker/dist/index.mjs [app-rsc] (ecmascript) <export parse as parseColor>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_esm__({
    "parseColor": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$picker$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parse"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$color$2d$picker$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@zag-js/color-picker/dist/index.mjs [app-rsc] (ecmascript)");
}}),

};

//# sourceMappingURL=node_modules_483a26._.js.map